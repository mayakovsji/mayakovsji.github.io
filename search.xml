<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[施图姆-刘维尔的一些研究]]></title>
    <url>%2F2022%2F02%2F26%2Fpage%2F</url>
    <content type="text"></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>数学物理方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复健计划第一弹：mathjax]]></title>
    <url>%2F2022%2F02%2F25%2Fmathjax_learning%2F</url>
    <content type="text"><![CDATA[我回来辣（大声） 断网三年了，常用工具都忘得差不多了，接下来的文章是个人复习的笔记，所以取个名叫“复健”。 基本语法 $...$代表行内引用，$$...$$代表行外引用。 ^ _为上下标，{}用于分组举例: 12sample $C_&#123;a&#125;^b$ sample$$C_&#123;a&#125;^&#123;b&#125;$$ sample $C_{a}^b$ sample C_{a}^{b}常用字符 注意在任意字符前添加\not即可添加不等符号。 字符 含义 效果 \gamma \Gamma \varGamma 希腊字母 $\gamma$ $\Gamma$ $\varGamma$ \vec {a} 矢量 $\vec {a}$ \overline {a} 上划线 $\overline {a}$ \underline {a} 下划线 $\underline {a}$ \hat {a} ^ $\hat {a}$ a \ a 空格 $a \ a$ \langle \rangle 尖括号 $\langle \rangle$ \vert \vert 绝对值 $\vert \vert$ \Vert \Vert 双竖线 $\Vert \Vert$ \frac {a} {b} 分数线 $\frac {a} {b}$ \times \div \pm \mp \cdot \bigotimes 各种算符 $\times \div \pm \mp \cdot \bigotimes$ \leq \geq \approx \not = \equiv 关系 $\leq \geq \approx \not= \equiv$ \in \subset \subseteq \cap \cup \varnothing 集合 $\in \subset \subseteq \cap \cup \varnothing$ \overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0} 上下括号 $\overbrace{a+\underbrace{b+c}_{1}+d}^{2}$ \ldots \partial \rightarrow \Rightarrow 符号 $\ldots \ \partial \rightarrow \ \Rightarrow$ \lim{x\to\infty} \sum{i=1}^N \int_a^b 符号 $\lim{x\to\infty} \sum{i=1}^N \int_a^b$ \nabla \infty \forall \exists \triangle 符号 $\nabla \infty \forall \exists \triangle$ 特殊结构通用规则 起始/结束标记\begin{name} \end{name} 换行\\ 元素分隔符&amp; 矩阵常用的关键字有：无框matrix,小括号pmatrix,中括号bmatrix，单竖线（也就是行列式）vmatrix。如12345$$\begin&#123;bmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;bmatrix&#125;$$ \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \\ \end{bmatrix}在省略元素时，可以用： 横省略号：\cdots 竖省略号：\vdots 斜省略号：\ddots 如123456$$\begin&#123;bmatrix&#125;a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; \cdots &amp; a_&#123;1n&#125; \\a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; \cdots &amp; a_&#123;2n&#125; \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_&#123;n1&#125; &amp; a_&#123;n2&#125; &amp; \cdots &amp; a_&#123;nn&#125; \\\end&#123;bmatrix&#125;$$ \begin{bmatrix} a_{11} & a_{12} & \cdots & a_{1n} \\ a_{21} & a_{22} & \cdots & a_{2n} \\ \vdots & \vdots & \ddots & \vdots \\ a_{n1} & a_{n2} & \cdots & a_{nn} \\ \end{bmatrix}方程组 关键词cases 如1234$$\begin&#123;cases&#125;a_1x+b_1y=c_1 \\a_2x+b_2y=c_2 \\\end&#123;cases&#125;$$ \begin{cases} a_1x+b_1y=c_1 \\ a_2x+b_2y=c_2 \\ \end{cases}连等式 注意把我们期望对齐的符号前加&amp;即可。 1234$$\begin&#123;align&#125;C &amp;= a \\ &amp;= b\end&#123;align&#125;$$ \begin{align} C &= a \\ &= b \end{align}]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP 2019 游记]]></title>
    <url>%2F2019%2F11%2F17%2Fcsp_2019%2F</url>
    <content type="text"><![CDATA[NOIP CSP 2019 游记 Day -n to Day -1停课，每天一场模拟赛，发现我还是太菜了，日常被全机房吊打。 Day 0今天考了一场所谓信心赛（自闭赛），然后是喜闻乐见的CS1.6环节。（传统艺能） 晚上机房毒奶 LLouver 奶了一口今年考DP，看来不用复习DP了（逃 （然而还是考了DP，被爆踩了） Day 1T1一眼切了，就注意一下unsigned long long最大为 $2^{64} - 1$，读入之后如果k++会炸。 T2脑子抽了，直接写的 $n ^ 2$ 暴力，还是太菜了。 T3考虑菊花图，做了1个多小时之后发现讨论的情况太多了，自闭。 期望得分:100 + 50 + 0 = 150pts luogu数据:100 + 90 + 0 = 190pts Day 2开考先看了一遍题，发现没一道题可做，T2，T3暴力比较好打，先开T2，T3。 T2设dp[i][j]为上一次划分点在 $j$，这次在 $i$，暴力转移即可。 T3考虑链的情况，长为奇数时，可以得到 $ans$ 为所有编号之和加开头，结尾，中间点的编号。然后考虑 $n^2$ 暴力删边，获得40pts的好成绩QAQ 然后我猜完美二叉树的情况应该比较可做，（然后找了一个小时的规律，并不会） 最后开T1的时候只有20$min$了，不想写暴力，特判n = 2的情况滚粗。 期望得分:8 + 36 + 55 = 99pts luogu数据:8 + 48 + 55 = 111pts Conclusion首先吐槽一下你谷数据忒水了点吧，(居然上300pts了QAQ)，然后喷一下神奇的题目顺序和难度曲线，CCF:非专业级比专业级更简单 然后好像每道题打的都是暴力。 果然菜是原罪，退役了，再见。]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种模版]]></title>
    <url>%2F2019%2F08%2F15%2Fstd%2F</url>
    <content type="text"><![CDATA[原文地址搬给自己看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598159916001601160216031604160516061607160816091610161116121613161416151616161716181619162016211622162316241625162616271628162916301631163216331634163516361637163816391640164116421643164416451646164716481649165016511652165316541655165616571658165916601661166216631664166516661667166816691670167116721673167416751676167716781679168016811682168316841685168616871688168916901691169216931694169516961697169816991700170117021703170417051706170717081709171017111712171317141715171617171718171917201721172217231724172517261727172817291730173117321733173417351736173717381739174017411742174317441745174617471748174917501751175217531754175517561757175817591760176117621763176417651766176717681769177017711772177317741775177617771778177917801781178217831784178517861787178817891790179117921793179417951796179717981799180018011802180318041805180618071808180918101811181218131814181518161817181818191820182118221823182418251826182718281829183018311832183318341835183618371838183918401841184218431844184518461847184818491850185118521853185418551856185718581859186018611862186318641865186618671868186918701871187218731874187518761877187818791880188118821883188418851886188718881889189018911892189318941895189618971898189919001901190219031904190519061907190819091910191119121913191419151916191719181919192019211922192319241925192619271928192919301931193219331934193519361937193819391940194119421943194419451946194719481949195019511952195319541955195619571958195919601961196219631964196519661967196819691970197119721973197419751976197719781979198019811982198319841985198619871988198919901991199219931994199519961997199819992000200120022003200420052006200720082009201020112012201320142015201620172018#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;tr1/unordered_map&gt;using namespace std;#define ri register int#define ull unsigned long long#define uint unsigned int#define bs bitset&lt;N&gt;typedef long long LL;namespace wjr&#123; const int mod=998244353,inv2=499122177,inf=1&lt;&lt;30; inline int mul(ri a,ri b)&#123;return a*1ll*b%mod;&#125; inline int add(ri a,ri b)&#123;return a+=b,a&gt;=mod?a-mod:a;&#125; inline int del(ri a,ri b)&#123;return a-=b,a&lt;0?a+mod:a;&#125; inline int qpow(ri a,ri b)&#123;ri s=1;for(;b;b&gt;&gt;=1,a=mul(a,a))if(b&amp;1)s=mul(s,a);return s;&#125; template&lt;typename T&gt; inline T sqr(register T x)&#123;return x*x;&#125;&#125;using namespace wjr;//* --- 目录 --- *///*--- 36-520 数学、快速变换等 ---*//*--- 522-585反演、杜教筛、Min_25筛 ---*//*--- 587-839 字符串 ---*//*--- 841-1140 图论 ---*//*--- 1142-1376 网络流 ---*//*--- - 随机化*/ /*--- 1378-1782 数据结构 ---*/ /*--- 1784-1813 BM算法*//*--- - 计算几何*/ /*---快速沃尔什变换*/namespace FWT&#123; inline void FWT_and(ri*a,ri n,ri p)&#123; ri step,s,i,j; for(step=1,s=2;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1) for(i=0;i&lt;n;i+=s) for(j=i;j&lt;i+step;++j) a[j]=~p?add(a[j],a[j+step]):del(a[j],a[j+step]); &#125;inline void FWT_or(ri*a,ri n,ri p)&#123; ri step,s,i,j; for(step=1,s=2;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1) for(i=0;i&lt;n;i+=s) for(j=i;j&lt;i+step;++j) a[j+step]=~p?add(a[j+step],a[j]):del(a[j+step],a[j]); &#125;inline void FWT_xor(ri*a,ri n,ri p)&#123; ri step,s,i,j,x; for(step=1,s=2;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1) for(i=0;i&lt;n;i+=s) for(j=i;j&lt;i+step;++j)&#123; x=a[j]; a[j]=add(a[j],a[j+step]); a[j+step]=del(x,a[j+step]); if(~p)continue; a[j]=mul(a[j],inv2); a[j+step]=mul(a[j+step],inv2); &#125; &#125;&#125;/*---快速子集变换*/namespace FST&#123; const int N=1&lt;&lt;15; inline void work(ri a[][N],ri b[][N],ri c[][N],ri n)&#123;/*---c[x][|x|]即为原来要求的dp[x]*/ ri lim=1&lt;&lt;n; for(ri i=1;i&lt;=n;++i)FWT::FWT_or(a[i],lim,1),FWT::FWT_or(b[i],lim,1); for(ri i=1;i&lt;=n;++i) for(ri j=1;j&lt;=i;++j) for(ri k=0;k&lt;=lim;++k) c[i][k]=add(c[i][k],mul(a[i-j][k],b[j][k])); for(ri i=1;i&lt;=n;++i)FWT::FWT_or(c[i],lim,-1); &#125;inline void work(ri a[][N],ri b[][N],ri n)&#123; ri lim=1&lt;&lt;n; for(ri i=1;i&lt;=n;++i)FWT::FWT_or(b[i],lim,1); a[0][0]=1,FWT::FWT_or(a[0],lim,1); for(ri i=1;i&lt;=n;++i) for(ri j=1;j&lt;=i;++j) for(ri k=0;k&lt;=lim;++k) a[i][k]=add(a[i][k],mul(a[i-j][k],b[j][k])); for(ri i=1;i&lt;=n;++i)FWT::FWT_or(a[i],lim,-1); &#125;&#125;/*---多项式 - NTT */namespace Poly_NTT&#123; const int N=1&lt;&lt;15; int g[25],gi[25],rev[N],INV[N|1]; inline void init(ri n)&#123;/*---初始化*/ ri bit=1; while((1&lt;&lt;bit)&lt;(n&lt;&lt;1))++bit; ri I=qpow(3,mod-2); for(ri i=1;i&lt;=bit;++i)g[i]=qpow(3,(mod-1)&gt;&gt;i),gi[i]=qpow(I,(mod-1)&gt;&gt;i); INV[0]=INV[1]=1;for(ri i=2;i&lt;=(1&lt;&lt;bit);++i)INV[i]=mul(INV[mod%i],mod-mod/i); &#125;inline void NTT(ri*a,ri n,ri p)&#123; ri i,j,step,s,enk,wn,x,now; for(i=0;i&lt;n;++i)if(i&lt;rev[i])swap(a[i],a[rev[i]]); for(step=1,s=2,now=1;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1,++now)&#123; wn=~p?g[now]:gi[now]; for(i=0;i&lt;n;i+=s)&#123; enk=1; for(j=i;j&lt;i+step;++j)&#123; x=mul(enk,a[j+step]); a[j+step]=del(a[j],x); a[j]=add(a[j],x); enk=mul(enk,wn); &#125; &#125; &#125;if(~p)return; for(i=0;i&lt;n;++i)a[i]=mul(a[i],INV[n]); &#125;inline void get_rev(ri s)&#123;ri Maxn=1&lt;&lt;s;for(ri i=0;i&lt;Maxn;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(s-1));&#125; inline void Mul(ri*a,ri n,ri*b,ri m)&#123;/*---多项式乘法*/ static int A[N],B[N]; ri i,bit,s,len;len=n+m-1; bit=1,s=2; while(s&lt;len)++bit,s&lt;&lt;=1; get_rev(bit); memcpy(A,a,n&lt;&lt;2),memset(A+n,0,(s-n)&lt;&lt;2); memcpy(B,b,m&lt;&lt;2),memset(B+m,0,(s-m)&lt;&lt;2); NTT(A,s,1),NTT(B,s,1); for(i=0;i&lt;s;++i)A[i]=mul(A[i],B[i]); NTT(A,s,-1);memcpy(a,A,len&lt;&lt;2); &#125;inline void Inv(ri*a,ri n)&#123;/*---多项式逆元*/ static int A[N],B[N],s,i,j,k,now; s=2;while(s&lt;n)s&lt;&lt;=1; memset(a+n,0,(s-n)&lt;&lt;2); memset(B,0,s&lt;&lt;3); B[0]=a[0]&lt;=N?INV[a[0]]:qpow(a[0],mod-2); for(i=2,j=4,now=2;i&lt;=s;i&lt;&lt;=1,j&lt;&lt;=1,++now)&#123; memcpy(A,a,i&lt;&lt;2),memset(A+i,0,i&lt;&lt;2); get_rev(now); NTT(A,j,1),NTT(B,j,1); for(k=0;k&lt;j;++k)B[k]=mul(B[k],del(2,mul(A[k],B[k]))); NTT(B,j,-1),memset(B+i,0,i&lt;&lt;2); &#125;memcpy(a,B,n&lt;&lt;2); &#125;inline void deriv(ri*a,ri n)&#123;/*---求导函数*/ for(ri i=0;i&lt;n;++i)a[i]=mul(a[i+1],i+1);a[n-1]=0; &#125;inline void intag(ri*a,ri n)&#123;/*---求原函数*/ for(ri i=n-1;i;--i)a[i]=mul(a[i-1],INV[i]);a[0]=0; &#125;inline void Ln(ri*a,ri n)&#123;/*---对数函数*/ static int A[N]; memcpy(A,a,n&lt;&lt;2),Inv(A,n); deriv(a,n), Mul(a,n,A,n); intag(a,n),memset(a+n,0,(n-1)&lt;&lt;2); &#125;inline void Exp(ri*a,ri n)&#123;/*---指数函数*/ static int A[N],B[N],i,j,k,now,s; s=2;while(s&lt;n)s&lt;&lt;=1; memset(a+n,0,(s-n)&lt;&lt;2); memset(B,0,s&lt;&lt;3); B[0]=1; for(i=2,j=4,now=2;i&lt;=s;i&lt;&lt;=1,j&lt;&lt;=1,++now)&#123; memcpy(A,B,i&lt;&lt;2),memset(A+i,0,i&lt;&lt;2); Ln(A,i);for(k=0;k&lt;i;++k)A[k]=del(a[k],A[k]); A[0]=add(A[0],1),get_rev(now); NTT(A,j,1),NTT(B,j,1); for(k=0;k&lt;j;++k)B[k]=mul(B[k],A[k]); NTT(B,j,-1),memset(B+i,0,i&lt;&lt;2); &#125;memcpy(a,B,n&lt;&lt;2); &#125;inline void Ksm(ri*a,ri n,ri k)&#123;/*---快速幂*/ ri t,p,inv; t=0;while(!a[t]&amp;&amp;t&lt;n)++t; if(t&gt;=n)return; p=a[t],inv=p&lt;=N?INV[p]:qpow(p,mod-2); for(ri i=0;i&lt;n-t;++i)a[i]=mul(a[i+t],inv); memset(a+n-t,0,t&lt;&lt;2); Ln(a,n); for(ri i=0;i&lt;n;++i)a[i]=mul(a[i],k); a[0]=0,Exp(a,n); for(ri i=n-1;i&gt;=t;--i) a[i]=mul(p,a[i-t]); memset(a,0,t&lt;&lt;2); &#125;inline void Div(ri*a,ri n,ri*b,ri m)&#123;/*---多项式除法+取模*/ static int F[N],G[N]; memcpy(F,a,(n+1)&lt;&lt;2),memcpy(G,b,(m+1)&lt;&lt;2); reverse(b,b+1+m),reverse(F,F+1+n); for(ri i=n-m+1;i&lt;=m;++i)b[i]=0; Inv(b,n-m+1); for(ri i=n-m+1;i&lt;=n;++i)F[i]=0; Mul(F,n-m+1,b,n-m+1); reverse(F,F+n-m+1); for(ri i=n-m+1;i&lt;=n;++i)F[i]=0; Mul(G,m+1,F,n-m+1); for(ri i=0;i&lt;m;++i)b[i]=del(a[i],G[i]); memcpy(a,F,n&lt;&lt;2); &#125;inline void Sqrt(ri*a,ri n)&#123;//多项式开根 static int A[N],B[N]; ri s,i,j,k,now; s=2;while(s&lt;n)s&lt;&lt;=1; memset(a+n,0,(s-n)&lt;&lt;2),memset(B,0,s&lt;&lt;3); B[0]=1; for(i=2,j=4,now=2;i&lt;=s;i&lt;&lt;=1,j&lt;&lt;=1,++now)&#123; memcpy(A,B,i&lt;&lt;2),memset(A+i,0,i&lt;&lt;2); for(k=0;k&lt;i;++k)A[k]=mul(A[k],2); Inv(A,i); get_rev(now-1); NTT(B,i,1); for(k=0;k&lt;i;++k)B[k]=mul(B[k],B[k]); NTT(B,i,-1); for(k=0;k&lt;i;++k)B[k]=add(B[k],a[k]); get_rev(now); NTT(B,j,1),NTT(A,j,1); for(k=0;k&lt;j;++k)B[k]=mul(B[k],A[k]); NTT(B,j,-1),memset(B+i,0,i&lt;&lt;2); &#125;memcpy(a,B,n&lt;&lt;2); &#125;&#125;/*---多项式 - FFT*/namespace Ploy_FFT&#123; const int N=1&lt;&lt;18,zw=(1&lt;&lt;15)-1; const double PI=acos(-1); int rev[N]; struct cd&#123; double x,y; cd(double a=0,double b=0)&#123;x=a,y=b;&#125; &#125;w[18][N]; inline cd operator+(cd a,cd b)&#123;return cd(a.x+b.x,a.y+b.y);&#125; inline cd operator-(cd a,cd b)&#123;return cd(a.x-b.x,a.y-b.y);&#125; inline cd operator*(cd a,cd b)&#123;return cd(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125; inline cd operator*(cd a,ri b)&#123;return cd(a.x,a.y*b);&#125; inline void init(ri n)&#123; for(ri i=0,k=1,j;i&lt;=17;++i,k&lt;&lt;=1) for(j=0;j&lt;k;++j) w[i][j]=cd(cos(PI*j/k),sin(PI*j/k)); &#125;inline void get_rev(ri s)&#123;ri Maxn=1&lt;&lt;s;for(ri i=0;i&lt;Maxn;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(s-1));&#125; inline void FFT(register cd*a,ri n,ri p)&#123; ri step,s,i,j,now; cd x; for(i=0;i&lt;n;++i)if(i&lt;rev[i])swap(a[i],a[rev[i]]); for(step=1,s=2,now=0;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1,++now) for(i=0;i&lt;n;i+=s) for(j=i;j&lt;i+step;++j)&#123; x=a[j+step]*(w[now][j-i]*p); a[j+step]=a[j]-x; a[j]=a[j]+x; &#125; if(~p)return; for(i=0;i&lt;n;++i)a[i].x/=n; &#125;inline LL get(cd x,ri Mod)&#123;return LL(x.x+0.5)%Mod;&#125; int siz=sizeof(cd); const int pw=32767; inline void MTT(ri*a,ri*b,ri*c,ri n,ri m,ri Mod)&#123; static cd A[N],B[N],C[N],D[N],e[N],f[N],g[N],h[N]; ri i,s,len;len=n+m-1; s=2;while(s&lt;len)s&lt;&lt;=1; for(i=0;i&lt;s;++i)&#123; A[i]=cd(a[i]&gt;&gt;15,0),B[i]=cd(a[i]&amp;pw,0); C[i]=cd(b[i]&gt;&gt;15,0),D[i]=cd(b[i]&amp;pw,0); &#125;FFT(A,s,1),FFT(B,s,1),FFT(C,s,1),FFT(D,s,1); for(i=0;i&lt;s;++i)e[i]=A[i]*C[i],f[i]=A[i]*D[i],g[i]=B[i]*C[i],h[i]=B[i]*D[i]; FFT(e,s,-1),FFT(f,s,-1),FFT(g,s,-1),FFT(h,s,-1); for(i=0;i&lt;len;++i) c[i]=(((get(e[i],Mod)&lt;&lt;30)%Mod+(get(f[i],Mod)&lt;&lt;15)%Mod)%Mod+(get(g[i],Mod)&lt;&lt;15)%Mod+get(h[i],Mod)%Mod)%Mod; &#125;inline void MTT_2(ri*a,ri n,ri*b,ri m)&#123;//黑科技优化版本 static cd A[N],B[N],C[N],D[N]; ri len=n+m-1,s=2,i,t; register LL q,w,e,r; while(s&lt;len)s&lt;&lt;=1; for(i=0;i&lt;n;++i)A[i]=cd(a[i]&amp;zw,a[i]&gt;&gt;15); for(i=n;i&lt;s;++i)A[i]=cd(0,0); for(i=0;i&lt;m;++i)B[i]=cd(b[i]&amp;zw,b[i]&gt;&gt;15); for(i=m;i&lt;s;++i)B[i]=cd(0,0); FFT(A,s,1),FFT(B,s,1); for(i=0;i&lt;s;++i)&#123; t=(s-i)&amp;(s-1); C[i]=cd(0.5*(A[i].x+A[t].x),0.5*(A[i].y-A[t].y))*B[i]; D[i]=cd(0.5*(A[i].y+A[t].y),0.5*(A[t].x-A[i].x))*B[i]; &#125;FFT(C,s,-1),FFT(D,s,-1); for(i=0;i&lt;len;++i)&#123; q=LL(C[i].x+0.5)%mod,w=LL(C[i].y+0.5)%mod,e=LL(D[i].x+0.5)%mod,r=LL(D[i].y+0.5)%mod; a[i]=(q+((w+e)&lt;&lt;15)+(r&lt;&lt;30))%mod;// a[i]=(q+((w+e)&lt;&lt;15)+(r&lt;&lt;30))%mod+mod;// a[i]=a[i]&gt;=mod?a[i]-mod:a[i]; //此题没卡,一般是要写%mod+mod,然后再取模的。 &#125; &#125;&#125;/*---斯特林数*/namespace Stirling&#123; //暂时不想写 &#125;/*---BSGS*/namespace BSGS&#123; const int Hash=19260817,N=1e4+10; int d[Hash],nxt[N],to[N],id[N],tot; int stk[N],tail; inline int get(ri x)&#123;return (x*1ll*x)%Hash;&#125; inline void Insert(ri x,ri i)&#123; ri now=get(x); if(!d[now])stk[++tail]=d[now]; to[++tot]=x,nxt[tot]=d[now],d[now]=tot,id[tot]=i; &#125;inline int query(ri x)&#123; ri now=get(x); for(ri i=d[now];i;i=nxt[i]) if(to[i]==x)return id[i]; return -1; &#125;inline void init()&#123;while(tail)d[stk[tail--]]=0;tot=0;&#125; inline int qpow(ri a,ri b,ri p)&#123;ri s=1;for(;b;b&gt;&gt;=1,a=a*1ll*a%p)if(b&amp;1)s=s*1ll*a%p;return s;&#125; inline int BSGS(ri a,ri b,ri p)&#123;//求a^t ≡b (mod p) if(b==1)return 0; ri tmp=ceil(sqrt(p)); ri t=qpow(a,tmp,p),x=1; for(ri i=1;i&lt;=tmp;++i)&#123; x=x*1ll*t%p; Insert(x,i); &#125;x=1; for(ri i=0;i&lt;tmp;++i)&#123; t=query(x); if(~t)return t*tmp-i; x=x*1ll*a%p; &#125;return -1; &#125;&#125;/*---Matrix_Tree矩阵树*/namespace Matrix_tree&#123;//用于求解生成树个数 const int N=205; int a[N][N]; inline void ins(ri u,ri v)&#123;++a[u][u],++a[v][v],--a[u][v],--a[v][u];&#125; inline int Gauss(ri n)&#123;//如果是m*m矩阵,n=m-1,即忽略最后一行 ri ans=1,i,j,k,div,tmp; for(i=1;i&lt;=n;++i)&#123; k=i; for(j=i;j&lt;=n;++j) if(a[j][i])&#123;k=j;break;&#125; if(k!=i)ans=-ans,swap(a[i],a[k]); if(!a[i][i])return 0; ans=mul(ans,a[i][i]); div=qpow(a[i][i],mod-2); for(j=i+1;j&lt;=n;++j)&#123; if(!a[j][i])continue; tmp=mul(div,a[j][i]); for(k=i;k&lt;=n;++k) a[j][k]=del(a[j][k],mul(tmp,a[i][k])); &#125; &#125;return ans&lt;0?ans+mod:ans; &#125;&#125;/*---中国剩余定理*/ namespace EXCRT&#123; const int N=1e4+10; const double eps=1e-2; typedef long long LL; struct node&#123; LL a[N],b[N]; LL ans,M; &#125;; LL x,y; inline LL exgcd(LL a,LL b,LL&amp;x,LL&amp;y)&#123; if(!b)&#123;x=1,y=0;return a;&#125; LL g=exgcd(b,a%b,y,x); y-=(a/b)*x; return g; &#125;inline LL Mul(LL a,LL b,LL p)&#123; LL d=((long double)a/p*b+eps); LL r=a*b-p*d; return r&lt;0?r+p:r; &#125;inline LL Del(LL a,LL b,LL p)&#123;return a-=b,a&lt;0?a+p:a;&#125; inline void Excrt(node&amp;a,ri n)&#123; a.ans=a.a[1],a.M=a.b[1]; LL c,g,p; for(ri i=2;i&lt;=n;++i)&#123;//a.ans+x*a.M≡a.a[i](mod a.b[i]) c=Del(a.a[i],a.ans,a.b[i]);//x*a.M≡a.a[i]-a.ans(mod a.b[i]) g=exgcd(a.M,a.b[i],x,y); p=a.b[i]/g; if(c%g!=0)&#123;a.ans=-1;return;&#125; x=Mul(x,c/g,p); a.ans+=x*a.M; a.M*=p; a.ans=(a.ans%a.M+a.M)%a.M; &#125; &#125;&#125;/*---高斯消元*/ namespace Gauss&#123; const int M=205; struct Matrix&#123; int a[M][M]; int ans[M];//为了方便起见才将ans放里面 &#125;; inline void Gauss(Matrix&amp;a,ri n)&#123;//n行、n+1列 ri i,j,k,t; for(i=1;i&lt;=n;++i)&#123; k=i; for(j=i;j&lt;=n;++j) if(a.a[j][i])&#123;k=j;break;&#125; if(i!=k)swap(a.a[k],a.a[i]); t=qpow(a.a[i][i],mod-2); for(k=i;k&lt;=n+1;++k)a.a[i][k]=mul(a.a[i][k],t); for(j=i+1;j&lt;=n;++j)&#123; t=a.a[j][i]; for(k=i;k&lt;=n+1;++k) a.a[j][k]=del(a.a[j][k],mul(t,a.a[i][k])); &#125; &#125;a.ans[i]=a.a[n][n+1]; for(i=n-1;i;--i)&#123; a.ans[i]=a.a[i][n+1]; for(j=i+1;j&lt;=n;++j) a.ans[i]=del(a.ans[i],mul(a.a[i][j],a.ans[j])); &#125; &#125;&#125;/*---矩阵*/ namespace Matrix&#123; const int N=205; int n;//假定行列都是n struct Matrix&#123; int a[N][N]; &#125;; inline void init(Matrix&amp;a)&#123;/*---单位矩阵*/ for(ri i=0;i&lt;n;++i) memset(a.a[i],0,n&lt;&lt;2),a.a[i][i]=1; &#125;inline void operator*=(Matrix&amp;a,Matrix b)&#123; static Matrix c; memset(&amp;c,0,sizeof(c)); ri i,j,k; for(i=0;i&lt;n;++i) for(k=0;k&lt;n;++k) if(a.a[i][k]) for(j=0;j&lt;n;++j) c.a[i][j]=add(c.a[i][j],mul(a.a[i][k],b.a[k][j])); memcpy(&amp;a,&amp;c,sizeof(a)); &#125;inline Matrix operator*(Matrix a,Matrix b)&#123; static Matrix c; memset(&amp;c,0,sizeof(c)); ri i,j,k; for(i=0;i&lt;n;++i) for(k=0;k&lt;n;++k) if(a.a[i][k]) for(j=0;j&lt;n;++j) c.a[i][j]=add(c.a[i][j],mul(a.a[i][k],b.a[k][j])); return c; &#125;using namespace Poly_NTT;//需要用到多项式 inline void my_Div(ri*a,ri n,ri*b,ri m)&#123;//配合常系数线性齐次递推 static int F[N],G[N]; memcpy(F,a,(n+1)&lt;&lt;2),memcpy(G,b,(m+1)&lt;&lt;2); reverse(G,G+m+1),reverse(F,F+n+1); for(ri i=n-m+1;i&lt;=m;++i)G[i]=0; Inv(G,n-m+1); for(ri i=n-m+1;i&lt;=n;++i)F[i]=0; Mul(F,n-m+1,G,n-m+1); reverse(F,F+n-m+1); for(ri i=n-m+1;i&lt;=n;++i)F[i]=0; memcpy(G,b,(m+1)&lt;&lt;2); Mul(G,m+1,F,n-m+1); for(ri i=0;i&lt;m;++i)a[i]=del(a[i],G[i]); memset(a+m,0,(n-m+1)&lt;&lt;2); &#125;inline void Multi(ri*a,ri*mod,ri*ans,ri n,ri k)&#123;/*---常系数线性齐次递推 */ memset(&amp;ans,0,sizeof(ans)); ans[0]=1; while(k)&#123; if(k&amp;1)&#123; Mul(ans,n,a,n); my_Div(ans,2*n-2,mod,n); &#125;Mul(a,n,a,n); my_Div(a,2*n-2,mod,n); k&gt;&gt;=1; &#125; &#125;inline int Inv(Matrix a,Matrix&amp;b)&#123;/*---矩阵求逆*/ //用b存inv(a) init(b); ri i,j,k,t; for(i=0;i&lt;n;++i)&#123; for(j=i;j&lt;n;++j) if(a.a[j][i])&#123; swap(a.a[i],a.a[j]),swap(b.a[i],b.a[j]); break; &#125; if(!a.a[i][i])return -1; t=qpow(a.a[i][i],mod-2); for(j=i;j&lt;n;++j)a.a[i][j]=mul(a.a[i][j],t),b.a[i][j]=mul(b.a[i][j],t); for(j=i+1;j&lt;n;++j)&#123; t=a.a[j][i]; for(k=i;j&lt;n;++k) b.a[j][k]=del(b.a[j][k],mul(t,b.a[i][k])),a.a[j][k]=del(a.a[j][k],mul(t,a.a[i][k])); &#125; &#125; &#125;&#125;/*---自适应性辛普森*/namespace Simpson&#123; double a; inline double f(double x)&#123;return pow(x,a/x-x);&#125;//返回函数值 inline double Simpson(double L,double R)&#123;return (R-L)*(f(R)+4*f((L+R)/2)+f(L))/6;&#125; inline double ars(double L,double R,double A,double eps)&#123; double mid=(L+R)/2; double ls=Simpson(L,mid),rs=Simpson(mid,R); if(fabs(ls+rs-A)&lt;15*eps)return ls+rs+(ls+rs-A)/15; return ars(L,mid,ls,eps/2)+ars(mid,R,rs,eps/2); &#125; &#125; /*---线性基*/namespace Linear_basis&#123; const int N=1005; bs a[66]; inline int Insert(bs x)&#123; for(ri i=60;~i;--i) if(x[i])&#123; if(a[i]!=0)x^=a[i]; else &#123;a[i]=x;return 1;&#125;//秩++ &#125; return 0; &#125;inline bs query(bs x)&#123;//可以异或得到的最大 for(ri i=60;~i;--i) if(!x[i]&amp;&amp;a[i]!=0) x^=a[i]; return x; &#125;&#125;/*---杜教筛*/ namespace DJS&#123; //求S(n)=\sum_&#123;i=1&#125;^&#123;n&#125;f(i),h=f*g(*为卷积运算),则有g(1)S(n)=\sum_&#123;i=1&#125;^&#123;n&#125;h(i)-\sum_&#123;i=2&#125;^&#123;n&#125;g(i)S(n/i) //这里以求\mu为例,\mu*1=元函数 const int N=1e6+10; using namespace std::tr1; int sum[N]; unordered_map&lt;int,int&gt;q;//最好是手写hash inline int S(ri n)&#123; if(n&lt;N)return sum[n]; if(q[n])return q[n]; ri ans=1,i,j; j=sqrt(n); for(i=2;i&lt;=j;++i) ans-=S(n/i); for(;i&lt;=n;i=j+1)&#123; j=n/(n/i); ans-=(j-i+1)*S(n/i); &#125;return q[n]=ans; &#125;&#125;/*---莫比乌斯反演(只是一个整除分块没什么好写的)*//*---Min_25筛*/namespace Min_25&#123;//这里以简单的函数LOJ 5063为例 const int N=1e4+10; int n,m,lim,cnt,prime[N],w[N],s[N],c[N]; bool no[N]; inline int id(ri x)&#123;return x&lt;=lim?x:m-(n/x)+1;&#125; inline int f(ri x,ri c)&#123;return x^c;&#125;//返回f(x的c次方)(那题f(x^(次方)c)=x^(异或)c) inline int g(ri x)&#123;return x;&#125; inline int h(ri x)&#123;return 1;&#125; inline int S(register LL n,ri k)&#123;//\sum_&#123;i=1&#125;^n f(i)*[i\in prime or min_i&gt;=prime[k]] if(n&lt;=1||n&lt;prime[k])return 0;//递归版本 ri i,c;register LL j; ri ans=del(s[id(n)],s[prime[k-1]]);//先算出prime的贡献 for(i=k;i&lt;=cnt&amp;&amp;prime[i]*1ll*prime[i]&lt;=n;++i) for(j=n,c=1;(j/=prime[i])&gt;=prime[i];++c) ans=add(ans,add(mul(f(prime[i],c),S(j,i+1)),f(prime[i],c+1))); //不会统计到因子全是p_i的,所以直接加上 return ans; &#125;inline void pre(ri*F)&#123;//非递归版本 //\sum f(prime_&#123;b&#125;^&#123;i&#125;)*(S(n/prime_&#123;b&#125;^&#123;i&#125;,b+1)-g(prime_&#123;b&#125;)+f(prime_&#123;b&#125;^&#123;i+1&#125;)) ri i,j,tmp; for(i=cnt;i;--i) for(j=m;w[j]&gt;=i*i;--j) for(tmp=w[j];(tmp/=prime[i])&gt;=prime[i];) F[j]+=(f(prime[i],i)*(F[id(tmp)]-s[prime[i]])+f(prime[i],i+1)); &#125;inline void init(register LL n)&#123;m=cnt=0; lim=sqrt(n); for(register LL i=1,j;i&lt;=n;i=j+1)&#123; w[++m]=j=n/(n/i); s[m]=del(mul(j%mod,(j+1)%mod),1),c[m]=(j-1)%mod;//代表筛第0轮的初始值 &#125;//g(n,i)筛了i轮后1-n中所有质数的f之和 for(ri i=2,j,t;i&lt;=lim;++i)&#123; if(c[i]==c[i-1])continue;//如果不是质数,可以线性筛预处理也可以利用c数组 prime[++cnt]=i; for(j=m;w[j]&gt;=i*i;--j) s[j]=del(s[j],mul(g(i),del(s[t=id(w[j]/i)],s[i-1]))),//g(x)=x,1-n指数和 c[j]=del(c[j],mul(h(i),del(c[t],c[i-1])));//g(x)=1,1-n质数个数 &#125;for(ri i=2;i&lt;=m;++i)s[i]=del(s[i],del(c[i],2)); &#125;&#125;/*---AC自动机*/namespace ACM&#123; const int N=1e4+10; int ch[N][26],nxt[N]; queue&lt;int&gt;q; int now,cnt; inline void Insert(register char*s)&#123; ri len=strlen(s+1),c; now=1; for(ri i=1;i&lt;=len;++i)&#123; c=s[i]-&apos;a&apos;; if(!ch[now][c])ch[now][c]=++cnt; now=ch[now][c]; &#125; /* is_end[now]=1; or ++siz[now]; or else */ &#125;inline void build()&#123; ri i,u,x; for(i=0;i&lt;26;++i)ch[0][i]=1; nxt[1]=0,q.push(1); while(!q.empty())&#123; x=q.front(); q.pop(); for(i=0;i&lt;26;++i)&#123; u=ch[x][i]; if(!u)ch[x][i]=ch[nxt[x]][i]; else&#123; q.push(u); nxt[u]=ch[nxt[x]][i]; &#125; &#125; &#125; &#125;&#125;/*---Hash of string字符串hash*/namespace hash_of_string&#123; const int N=1e5+10,bas=237;//N,bas自定义 ull pw[N]; inline void init(ri n)&#123;pw[0]=1;for(ri i=1;i&lt;n;++i)pw[i]=pw[i-1]*bas;&#125; inline void hash(register char*s,register ull*a,ri n)&#123; for(ri i=1;i&lt;=n;++i) a[i]=a[i-1]*bas+(s[i]-&apos;a&apos;); &#125;inline ull get_hash(ri L,ri R,register ull*a)&#123;return a[R]-pw[R-L+1]*a[L-1];&#125;&#125;/*--- Hash of num or else */namespace hash_of_else&#123;//以二维坐标为例 const int Hash=19260817,N=1e4+10,bas=998244353; struct node&#123; int x,y; &#125;; int d[Hash],nxt[N],tot; node to[N]; LL val[N]; inline int get_hash(node x)&#123;return (x.x*1ll*bas+x.y)%Hash;&#125; inline bool operator==(node a,node b)&#123;return a.x==b.x&amp;&amp;a.y==b.y;&#125; inline void Insert(node x,LL v)&#123; ri now=get_hash(x); to[++tot]=x,nxt[now]=d[now],d[now]=++tot,val[tot]=v; &#125;inline LL find(node x)&#123; ri now=get_hash(x); for(ri i=d[now];i;i=nxt[i]) if(to[i]==x)return val[i]; return -1;//返回一个val不会出现的值 &#125;&#125;/*---KMP*/namespace KMP&#123; const int N=1e4+10; inline void get_nxt(register char*s,ri*nxt)&#123; ri n=strlen(s+1); for(ri i=2,j=0;i&lt;=n;++i)&#123; while(j&amp;&amp;s[j+1]!=s[i])j=nxt[j]; j+=s[j+1]==s[i]; nxt[i]=j; &#125; &#125;&#125;/*---马拉车算法,有了PAM还有学Manacher的必要吗(雾*/namespace Manacher&#123; inline void Manacher(register char*s,ri*rad,ri n)&#123; for(ri i=1,j=0,k;i&lt;n;i+=k)&#123; while(s[i-j-1]==s[i+j+1])++j; rad[i]=j; for(k=1;k&lt;=rad[i]&amp;&amp;rad[i-k]!=rad[i]-k;++k) rad[i+k]=min(rad[i-k],rad[i]-k); j=max(j-k,0); &#125; &#125;&#125;/*---trie树(没啥好写的)*/namespace trie_tree&#123;&#125;/*---后缀平衡树*/namespace suffix_balance_tree&#123; const double alpha=0.7; const int N=1e4+10; int ch[N][2],pos[N],a[N],siz[N],tail,rt; char s[N]; int fail_pos,fail_fa; double v[N],fail_ls,fail_rs; #define lc ch[x][0] #define rc ch[x][1] inline bool cmp(ri x,ri y)&#123;return (s[x]!=s[y])?s[x]&lt;s[y]:v[pos[x]]&lt;v[pos[y]];&#125;//pos代表上一个插入位置 inline int rebuild(ri L,ri R,register double ls,register double rs)&#123; if(L&gt;R)return 0; ri mid=(L+R)&gt;&gt;1,x=a[mid]; v[x]=(ls+rs)/2,siz[x]=R-L+1; lc=rebuild(L,mid-1,ls,v[x]),rc=rebuild(mid+1,R,v[x],rs); return x; &#125;inline void ck(ri x,ri k,register double ls,register double rs)&#123; if(siz[ch[x][k]]&gt;alpha*siz[x])fail_pos=x,fail_fa=-1,fail_ls=ls,fail_rs=rs; else if(ch[x][k]==fail_pos)fail_fa=x; &#125;inline void Insert(ri&amp;x,ri y,register double ls,register double rs)&#123; if(!x)&#123;x=y;v[x]=(ls+rs)/2;return;&#125; ++siz[x]; ri d=cmp(x,y); if(d)Insert(rc,y,(ls+rs)/2,rs); else Insert(lc,y,ls,(ls+rs)/2); ck(x,d,ls,rs); &#125;inline void recover(ri x)&#123;if(!x)return ;recover(lc),a[++tail]=x,recover(rc);&#125; inline void Insert(ri x)&#123; siz[x]=1,fail_pos=fail_fa=-1; Insert(rt,x,0,1); if(~fail_pos)&#123; tail=0; recover(fail_pos); ri T=rebuild(1,tail,fail_ls,fail_rs); if(~fail_fa)ch[fail_fa][ch[fail_fa][1]==fail_pos]=T; else rt=T; &#125; &#125; #undef lc #undef rc&#125; /*---SA后缀数组*/namespace SA&#123; const int N=1e4+10; int tax[N],sa[N],rk[N],tp[N]; int h[N],bit[N],s[30]; int n,m; int Min[N][19]; inline void init(ri n)&#123;//预处理 for(ri i=2;i&lt;=n;++i)bit[i]=bit[i&gt;&gt;1]+1; s[0]=1; for(ri i=1;i&lt;=bit[n];++i)s[i]=s[i-1]&lt;&lt;1; &#125;inline void qsort()&#123;ri i; memset(tax+1,0,m&lt;&lt;2); for(i=1;i&lt;=n;++i)++tax[rk[i]]; for(i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; for(i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; &#125;inline void suffix_sort(register char*s)&#123;ri i,j,p; n=strlen(s+1),m=26; for(i=1;i&lt;=n;++i)rk[i]=s[i]-&apos;a&apos;,tp[i]=i; qsort(); for(i=1,p=0;p&lt;n;m=p,i&lt;&lt;=1)&#123; p=0; for(j=1;j&lt;=i;++j)tp[++p]=n-i+j; for(j=1;j&lt;=n;++j)if(sa[j]&gt;i)tp[++p]=sa[j]-i; qsort(),swap(tp,rk); rk[sa[1]]=p=1; for(j=2;j&lt;=n;++j)rk[sa[j]]=(tp[sa[j]]==tp[sa[j-1]]&amp;&amp;tp[sa[j]+i]==tp[sa[j-1]+i])?p:++p; &#125; &#125;inline void work(register char*s)&#123; suffix_sort(s); ri i,j,k=0; for(i=1;i&lt;=n;++i)&#123; if(k)--k; j=sa[rk[i]-1]; while(s[i+k]==s[j+k])++k; h[rk[i]]=k; &#125;for(i=1;i&lt;=n;++i)Min[i][0]=h[i]; for(j=1;j&lt;=bit[n];++j)&#123; ri p=s[j-1],q=s[j]; for(i=1;i&lt;=n-q+1;++i) Min[i][j]=min(Min[i][j-1],Min[i+p][j-1]); &#125; &#125;&#125;/*---后缀自动机*/ namespace SAM&#123; const int N=1e4+10; int las,cnt,now,p,q,nq; int len[N&lt;&lt;1],ch[N&lt;&lt;1][26],fa[N&lt;&lt;1]; inline void init()&#123;las=cnt=1;&#125;//初始化 inline void Insert(ri c)&#123;/*---普通的SAM构造,广义的如果不涉及拓扑序可以每个串init后insert,否则要有特判*/ now=++cnt,p=las,len[now]=len[p]+1; while(p&amp;&amp;!ch[p][c])ch[p][c]=now,p=fa[p]; if(!p)fa[now]=1; else&#123; q=ch[p][c]; if(len[q]==len[p]+1)fa[now]=q; else&#123; nq=++cnt,len[nq]=len[p]+1; memcpy(ch[nq],ch[q],26&lt;&lt;2); /*---有的题目需要用LCT维护*/ fa[nq]=fa[q],fa[q]=fa[now]=nq; /*如若splay维护改成 fa[nq]=fa[q]; splay(q),New(nq,right[q]); link(nq,fa[nq]),cut(q,fa[q]); fa[q]=fa[now]=nq,New(q,right[q]); link(q,fa[q]); //New是fa改变或是新建节点或是copy节点更改LCT中节点的信息 */ while(p&amp;&amp;ch[p][c]==q)ch[p][c]=nq,p=fa[p]; &#125; &#125;/*---同样的如果是LCT维护还要处理now和fa[now]*/ /* New(now,1); LCT::link(now,fa[now]); LCT::access(now),LCT::splay(now); c=LCT::s[LCT::ch[now][0]]; LCT::pushr(LCT::ch[now][0],1); */ &#125;&#125;/*---回文自动机*/ namespace PAM&#123; const int N=1e4+10; struct node&#123; int ch[26],fa,len; &#125;prt[N]; char s[N]; int pos;//处理到的位置pos inline int get_fa(ri x)&#123;while(s[pos-1-prt[x].len]!=s[pos])x=prt[x].fa;return x;&#125; int las,cnt; inline void init()&#123;prt[0].fa=prt[1].fa=1,prt[1].len=-1,las=cnt=1;&#125;//初始化 inline int Insert(ri c)&#123;/*---构建回文自动机*/ ri p=get_fa(las),now; if(!prt[p].ch[c])&#123; now=++cnt; prt[now].len=prt[p].len+2; prt[now].fa=prt[get_fa(prt[p].fa)].ch[c]; prt[p].ch[c]=now; &#125;return las=prt[p].ch[c]; &#125;//可以用lca求出s串中两个回文串最长公共回文串 //亦或者可以快速求出以某个位置开头或者结尾的最长回文串 //也可以求出以每个位置为中心的最长回文串,Manacher哭了 &#125;/*---2-SAT*/namespace two_SAT&#123;//建图之后跑tarjan即可,貌似没什么可以写的？(雾 //令i是选i,i&apos;是不选i //i-&gt;j连边:选i就必选j //然后就根据题意建图 &#125;/*---Tarjan算法*/ namespace Tarjan&#123;//过于简单 const int N=1e4+10,M=3e4+10; int d[N],nxt[M&lt;&lt;1],to[M&lt;&lt;1],tot; int dfn[N],low[N],stk[N],tail,cnt; int id[N],cl; bool in[N]; inline void tarjan(ri x)&#123; dfn[x]=low[x]=++cnt; stk[++tail]=x,in[x]=1; for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(in[u])low[x]=min(low[x],dfn[u]); else if(!dfn[u])tarjan(u),low[x]=min(low[x],low[u]); &#125;if(low[x]==dfn[x])&#123; ri now; ++cl; do&#123; now=stk[tail--]; in[now]=0; id[now]=cl; &#125;while(now!=x); &#125; &#125;inline void work(ri n)&#123;for(ri i=1;i&lt;=n;++i)if(!dfn[i])tarjan(i);&#125;&#125;/*---斯坦纳树*/namespace Staineer_Tree&#123; const int N=1e4+10,M=1&lt;&lt;7,E=N&lt;&lt;2,inf=1&lt;&lt;27; int dp[N][M],d[N],nxt[E],to[E],cost[E],tot; bool in[N]; queue&lt;int&gt;q; inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,cost[tot]=c;&#125; inline void spfa(ri sta)&#123; ri i,x,u; while(!q.empty())&#123; x=q.front(),q.pop(); in[x]=1; for(i=d[x];i;i=nxt[i])&#123; u=to[i]; if(dp[u][sta]&gt;dp[x][sta]+cost[i])&#123;//以边权为例 dp[u][sta]=dp[x][sta]+cost[i]; if(!in[u])in[u]=1,q.push(u); &#125; &#125; &#125; &#125;inline void init()&#123;/*---一般是随机化每个点颜色,因题而异*/&#125; inline void solve(ri n,ri k)&#123; init();ri sta,s,i,lim; lim=k&lt;&lt;1; for(i=1;i&lt;=n;++i)memset(dp[i],0,lim&lt;&lt;2); for(sta=0;sta&lt;lim;++sta)&#123; for(i=1;i&lt;=n;++i)&#123; for(s=(sta-1)&amp;sta;s;s=(s-1)&amp;sta) dp[i][sta]=min(dp[i][sta],dp[i][s]+dp[i][s^sta]);//如果是点权还有减去v[i] /*dp[i][sta]=min(dp[i][sta],dp[i][s]+dp[i][s^sta]-v[i]);*/ if(dp[i][sta]&lt;inf)q.push(i); &#125;spfa(sta); &#125; &#125;&#125;/*---广义圆方树*/namespace YF_Tree&#123; const int N=1e4+10,M=4e4+10; struct node&#123; int d[N&lt;&lt;1],nxt[M],to[M],tot; inline void ins(ri a,ri b)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot;&#125; &#125;e,g;//e:原图,g:圆方树 int dfn[N],low[N]; int st[N],tail,cnt,cl;//cl初始为n,为方点编号。 inline void tarjan(ri x)&#123;/*---构建广义圆方树(不能用于仙人掌,可以用于一般图)*/ dfn[x]=low[x]=++cnt; st[++tail]=x; for(ri i=e.d[x];i;i=e.nxt[i])&#123; ri u=e.to[i]; if(!dfn[u])&#123; tarjan(u); low[x]=min(low[x],low[u]); if(low[u]==dfn[x])&#123; ++cl;//新建方点 ri now; do&#123; now=st[tail--]; g.ins(now,cl),g.ins(cl,now); &#125; while(now!=u); g.ins(cl,x),g.ins(x,cl); &#125; &#125;else low[x]=min(low[x],dfn[u]); &#125; &#125;&#125;/*---正规圆方树(处理仙人掌)*/namespace YF_Tree_2&#123; const int N=1e4+10,M=2e4+10; struct node&#123; int d[N&lt;&lt;1],nxt[M],to[M],cost[M],tot; inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot;&#125; &#125;e,g; int sum[N&lt;&lt;1],stk[N],dfn[N],low[N],tail,cnt,cl; inline void tarjan(ri x,ri fa)&#123; dfn[x]=low[x]=++cnt; stk[++tail]=x; for(ri i=e.d[x];i;i=e.nxt[i])&#123; ri u=e.to[i]; if(u==fa)continue; if(!dfn[u])&#123; sum[u]=sum[x]+e.cost[i]; tarjan(u,x); low[x]=min(low[x],low[u]); if(low[u]&gt;dfn[x])g.ins(x,u,e.cost[i]); &#125;else if(dfn[u]&lt;low[x])&#123; low[x]=dfn[u]; sum[++cl]=sum[x]+e.cost[i]-sum[u]; for(ri i=tail;stk[i]^u;--i)&#123; ri p=stk[i]; g.ins(cl,p,min(sum[p]-sum[u],sum[cl]-sum[p]+sum[u])); &#125;g.ins(u,cl,0); &#125; &#125;--tail; &#125;&#125;/*---树上倍增优化建图*/namespace unknown_name_1&#123;//通常是某个点和某条链连边或者两条树上的链连边 //这里以XR-1 逛森林 为例(因为我真的没做过其他树上倍增优化建图的题了) const int N=1e4+10,M=N*18; int fa[N][20],cid[N][20],rid[N][20]; int D[N],Nxt[N&lt;&lt;1],To[N&lt;&lt;1],Tot; int d[N],nxt[M],to[M],cost[M],tot; inline void ins(ri a,ri b)&#123;To[++Tot]=b,Nxt[Tot]=D[a],D[a]=Tot;&#125; int Log[N],dep[N],cnt; inline void link(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,cost[tot]=c;&#125; inline void init()&#123;for(ri i=2;i&lt;N;++i)Log[i]=Log[i&gt;&gt;1]+1;&#125; inline void clear(ri n)&#123; memset(D,0,sizeof(D)),memset(d,0,sizeof(d)); tot=Tot=0; cnt=n; &#125;inline void dfs(ri x)&#123;//预处理 cid[x][0]=rid[x][0]=x; ri i,u; for(i=1;i&lt;20;++i)//这样写可以不用初始化 fa[x][i]=fa[fa[x][i-1]][i-1]; for(i=1;i&lt;=Log[dep[x]-1];++i)&#123; cid[x][i]=++cnt; rid[x][i]=++cnt; link(cid[x][i-1],cid[x][i],0), link(cid[fa[x][i-1]][i-1],cid[x][i],0); link(rid[x][i],rid[x][i-1],0), link(rid[x][i],rid[fa[x][i-1]][i-1],0); &#125;for(i=D[x];i;i=Nxt[i])&#123; u=To[i]; if(u!=fa[x][0])&#123; fa[u][0]=x; dep[u]=dep[x]+1; dfs(u); &#125; &#125; &#125;inline int Lca(ri u,ri v)&#123; if(dep[u]&lt;dep[v])swap(u,v); while(dep[u]&gt;dep[v])u=fa[u][Log[dep[u]-dep[v]]]; if(u==v)return u; for(ri i=Log[dep[u]-1];~i;--i) if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i]; return fa[u][0]; &#125;inline int kfa(ri x,ri k)&#123;/*k-fa*/ ri z; while(k)&#123; z=k&amp;-k; x=fa[x][Log[z]]; k-=z; &#125;return x; &#125;inline void build(ri u,ri v,ri w,ri t)&#123;//将u-&gt;v(必须满足是祖先关系)和cnt连边,w为边权,t为种类,0/1:连向cnt/cnt连向链 ri c,p; p=Log[dep[u]-dep[v]+1]; c=kfa(u,dep[u]-dep[v]+1-(1&lt;&lt;p)); link(t?cnt:cid[u][p],t?rid[u][p]:cnt,w); if(c==u)return; link(t?cnt:cid[c][p],t?rid[c][p]:cnt,w); &#125;inline void work(ri u1,ri v1,ri u2,ri v2,ri w)&#123; ++cnt; ri p=Lca(u1,v1); if(dep[u1]&gt;dep[v1])swap(u1,v1); if(dep[u2]&gt;dep[v2])swap(u2,v2); if(u1!=p) build(u1,p,0,0); build(v1,p,0,0); p=Lca(u2,v2); if(u2!=p) build(u2,p,w,1); build(v2,p,w,1); &#125;&#125;/*---线段树优化建图*/namespace unknown_name_2&#123;&#125;/*---spfa(SLF+容错优化)*/namespace Spfa&#123; const int N=1e4+10,M=N&lt;&lt;1; int d[N],nxt[M],to[M],cost[M],tot; int dis[N],W,n,m; deque&lt;int&gt;q; bool in[N]; inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,cost[tot]=c,W+=abs(c);&#125; inline void init()&#123;W=pow(W/sqrt(m+1),2.0/3),W=W&lt;pow(m+1,1.0/3)?pow(m,1.0/3):W,W=W&gt;pow(m+1,2.0/3)?pow(m+1,2.0/3):W;&#125; inline void spfa(ri S)&#123; memset(dis,0x7f,sizeof(dis)); q.push_back(S),dis[S]=0; while(!q.empty())&#123; ri x=q.front(); q.pop_front(); in[x]=0; for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(dis[u]&gt;dis[x]+cost[i])&#123; dis[u]=dis[x]+cost[i]; if(!in[u])&#123; in[u]=1; if(!q.empty()&amp;&amp;dis[u]&gt;dis[*q.begin()]+W) q.push_back(u); else q.push_back(u); &#125; &#125; &#125; &#125; &#125;&#125;/*---dijkstra*/namespace Dijkstra&#123;//堆优化dijkstra,可以升级成线段树优化dijkstra const int N=1e5+10; struct node&#123; int id,dis; node(ri a=0,ri b=0)&#123;id=a,dis=b;&#125; bool operator &lt;(const node&amp;other)const&#123;return dis&gt;other.dis;&#125; &#125;; priority_queue&lt;node&gt;q; int d[N],nxt[N],to[N],cost[N],dis[N]; inline void dijkstra(ri S)&#123; memset(dis,0x3f,sizeof(dis)); q.push(node(S,0)),dis[S]=0; while(!q.empty())&#123; node x=q.top(); q.pop(); if(x.dis&gt;dis[x.id])continue; for(ri i=d[x.id];i;i=nxt[i])&#123; ri u=to[i]; if(dis[u]&gt;dis[x.id]+cost[i])&#123; dis[u]=dis[x.id]+cost[i]; q.push(node(u,dis[u])); &#125; &#125; &#125; &#125;&#125;/*---虚树*/namespace vtree&#123; const int N=1e5+10,M=N&lt;&lt;1; int dfn[N],stk[N],dep[N],top; int st[N],tp; int Min[M][20],bit[M],fir[N];//tarjan求LCA inline bool cmp(ri a,ri b)&#123;return dfn[a]&lt;dfn[b];&#125; #define compare(a,b) (dep[a]&lt;dep[b]?a:b) struct edge&#123; int d[N],nxt[M],to[M],tot;//假设原树无边权 inline void ins(ri a,ri b)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot;&#125; &#125;s,t; inline int lca(ri u,ri v)&#123; u=fir[u],v=fir[v]; if(u&gt;v)swap(u,v); ri p=bit[v-u+1]; return compare(Min[u][p],Min[v-(1&lt;&lt;p)+1][p]); &#125;inline void buildv(ri x)&#123; if(tp==1)&#123;st[++tp]=x;return;&#125; ri Lca=lca(x,st[tp]); while(tp&gt;1&amp;&amp;dep[st[tp-1]]&gt;=dep[Lca])t.ins(st[tp-1],st[tp]),--tp; if(Lca!=st[tp])t.ins(Lca,st[tp]),st[tp]=Lca; st[++tp]=x; &#125;inline void work()&#123; t.tot=0; sort(stk+1,stk+1+top,cmp); st[tp=1]=1; if(stk[1]!=1)buildv(stk[1]); for(ri i=2;i&lt;=top;++i)buildv(stk[i]); while(tp&gt;1)t.ins(st[tp-1],st[tp]),--tp;// Dp(1); &#125; #undef compare&#125; /*---Dinic*/namespace Dinic&#123; const int N=1e4+10,M=2e4+10; int d[N],nxt[M],to[M],flow[M],tot; int dep[N],cur[N]; int S,T;//源、汇 queue&lt;int&gt;q; int Maxflow; inline void init()&#123;memset(d,-1,sizeof(d)),tot=-1;&#125; inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,flow[tot]=c;&#125; inline void add(ri a,ri b,ri c)&#123;ins(a,b,c),ins(b,a,0);&#125; inline bool bfs()&#123; memset(dep,0,sizeof(dep)); memcpy(cur,d,sizeof(cur)); q.push(S),dep[S]=1; while(!q.empty())&#123; ri x=q.front(); q.pop(); for(ri i=d[x];~i;i=nxt[i])&#123; ri u=to[i]; if(!dep[u]&amp;&amp;flow[i]) dep[u]=dep[x]+1,q.push(u); &#125; &#125;return dep[T]!=0; &#125;inline int dfs(ri now,ri lim)&#123; if(now==T||!lim)&#123;Maxflow+=lim;return lim;&#125; int fl=0,f; for(ri i=cur[now];~i;i=nxt[i])&#123; ri u=to[i]; cur[now]=i; if(dep[u]==dep[now]+1&amp;&amp;(f=dfs(u,min(flow[i],lim))))&#123; flow[i]-=f,flow[i^1]+=f; fl+=f,lim-=f; if(!lim)break; &#125; &#125;return fl; &#125;inline int Dinic()&#123;Maxflow=0; while(bfs())&#123; while(dfs(S,inf)); &#125;return Maxflow; &#125;&#125;/*---ISAP*/namespace ISAP&#123; const int N=1e4+10,M=2e4+10; int d[N],nxt[M],to[M],flow[M],tot; int S,T; int cur[N],dep[N],num[N],pre[N]; queue&lt;int&gt;q; inline void init()&#123;memset(d,-1,sizeof(d)),tot=-1;&#125; inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,flow[tot]=c;&#125; inline void add(ri a,ri b,ri c)&#123;ins(a,b,c),ins(b,a,0);&#125; inline bool bfs()&#123; memset(dep,0,sizeof(dep)); memset(num,0,sizeof(num)); memcpy(cur,d,sizeof(cur)); dep[T]=1,q.push(T); while(!q.empty())&#123; ri x=q.front(); q.pop(); ++num[dep[x]]; for(ri i=d[x];~i;i=nxt[i])&#123; ri u=to[i]; if(!dep[u]&amp;&amp;flow[i^1]) dep[u]=dep[x]+1,q.push(u); &#125; &#125;return dep[S]!=0; &#125;inline int add_flow()&#123; ri now=T,ans=inf; while(now!=S)ans=min(ans,flow[pre[now]]),now=to[pre[now]^1]; now=T; while(now!=S)flow[pre[now]]-=ans,flow[pre[now]^1]+=ans,now=to[pre[now]^1]; return ans; &#125;inline int ISAP()&#123; if(!bfs())return 0; ri Maxflow=0,now=S; while(233)&#123; if(now==T)&#123;Maxflow+=add_flow(),now=S;&#125; bool have_way=0; for(ri i=cur[now];~i;i=nxt[i])&#123; ri u=to[i]; if(flow[i]&amp;&amp;dep[u]+1==dep[now])&#123; pre[u]=i,have_way=1; cur[now]=i,now=u;break; &#125; &#125;if(!have_way)&#123; if(!--num[dep[now]])return Maxflow; ++num[++dep[now]]; cur[now]=d[now]; if(now!=S)now=to[pre[now]^1]; &#125; &#125;return Maxflow; &#125;&#125;/*---HLPP*/namespace HLPP&#123;//太难写了 &#125;/*---费用流(EK,Dinic,zkw)*/namespace cost_flow&#123;//以最小费用最大流为例 const int N=205,M=550; int d[N],nxt[M],to[M],flow[M],cost[M],tot; int dis[N],S,T; inline void ins(ri a,ri b,ri c,ri e)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,flow[tot]=c,cost[tot]=e;&#125; inline void add(ri a,ri b,ri c,ri e)&#123;ins(a,b,c,e),ins(b,a,0,-e);&#125; int W;//W为pow(sum w(w&gt;0)/sqrt(n+1),0.666667),W=W&lt;down:down:W,W=W&gt;up?up:W; namespace EK&#123; int pre[N]; deque&lt;int&gt;q; bool in[N]; inline bool spfa()&#123;//SLF+容错(个人感觉挺不错的) memset(dis,0x7f,sizeof(dis)); ri i,u,x; q.push_back(S),dis[S]=0; while(!q.empty())&#123; x=*(q.begin()); q.pop_front(); in[x]=0; for(i=d[x];~i;i=nxt[i])&#123; u=to[i]; if(flow[i]&amp;&amp;dis[u]&gt;dis[x]+cost[i])&#123; dis[u]=dis[x]+cost[i]; pre[u]=i; if(!in[u])&#123; in[u]=1; if(!q.empty()&amp;&amp;dis[u]&gt;dis[*q.begin()]+W) q.push_back(u); else q.push_front(u); &#125; &#125; &#125; &#125;return dis[T]&lt;inf; &#125;inline int EK()&#123;ri Mincost=0,Maxflow=0,now,ans; while(spfa())&#123; ans=inf; for(now=T;now!=S;now=to[pre[now]^1]) ans=min(ans,flow[pre[now]]); for(now=T;now!=S;now=to[pre[now]^1]) flow[pre[now]]-=ans,flow[pre[now]^1]+=ans; Mincost+=ans*dis[T]; Maxflow+=ans; &#125;return Mincost; &#125; &#125; namespace Dinic&#123; deque&lt;int&gt;q; bool in[N]; int vis[N],cur[N],Tim,Mincost,Maxflow; inline bool spfa()&#123; memset(dis,0x7f,sizeof(dis)); memcpy(cur,d,sizeof(cur)); ri i,u,x; q.push_back(S),dis[S]=0; while(!q.empty())&#123; x=q.front(); q.pop_front(); in[x]=0; for(i=d[x];~i;i=nxt[i])&#123; u=to[i]; if(dis[u]&gt;dis[x]+cost[i])&#123; dis[u]=dis[x]+cost[i]; if(!in[u])&#123; in[u]=1; if(!q.empty()&amp;&amp;dis[u]&gt;dis[*q.begin()]+W) q.push_back(u); else q.push_front(u); &#125; &#125; &#125; &#125;return dis[T]&lt;inf; &#125;inline int dfs(ri now,ri lim)&#123; if(now==T||!lim)&#123;Mincost+=dis[now]*lim,Maxflow+=lim;return lim;&#125; ri fl=0,f; vis[now]=Tim; for(ri i=cur[now];~i;i=nxt[i])&#123; cur[now]=i; ri u=to[i]; if(dis[u]==dis[now]+cost[i]&amp;&amp;vis[u]!=Tim&amp;&amp;(f=dfs(u,min(lim,flow[i]))))&#123; fl+=f, flow[i]-=f, flow[i^1]+=f; lim-=f; if(!lim)break; &#125; &#125;return fl; &#125;inline int Dinic()&#123;Mincost=Maxflow=0; while(spfa())&#123; do&#123; ++Tim; &#125;while(dfs(S,inf)); &#125;return Mincost; &#125; &#125; namespace zkw&#123; int cur[N],vis[N],Tim,cnt;//节点编号为0-cnt int Mincost,Maxflow; inline bool zkw()&#123; memcpy(cur,d,sizeof(cur)); ri i,x,mn=inf; for(x=0;x&lt;=cnt;++x) if(vis[x]==Tim) for(i=d[x];~i;i=nxt[i]) if(flow[i]&amp;&amp;vis[to[i]]!=Tim) mn=min(mn,dis[x]-dis[to[i]]+cost[i]); if(mn&gt;=inf)return 0; for(x=0;x&lt;=cnt;++i)if(vis[x]==Tim)dis[x]-=mn; return 1; &#125;inline int dfs(ri now,ri lim)&#123; if(!lim||now==T)&#123;Mincost-=dis[now]*lim,Maxflow+=lim;return lim;&#125; ri fl=0,f; vis[now]=Tim; for(ri i=cur[now];~i;i=nxt[i])&#123; ri u=to[i]; cur[now]=i; if(dis[u]==dis[now]+cost[i]&amp;&amp;vis[u]!=Tim&amp;&amp;(f=dfs(u,min(lim,flow[i]))))&#123; fl+=f, flow[i]-=f, flow[i^1]+=f; lim-=f; if(!lim)break; &#125; &#125;return lim; &#125;inline int work()&#123;Mincost=Maxflow=0; do&#123; do&#123; ++Tim; &#125;while(dfs(S,inf)); &#125;while(zkw()); return Mincost; &#125; &#125;&#125;/*---随机化乱搞(模拟退火,随机化数组,爬山算法)*/namespace Random_work&#123; /*---模拟退火*/ const double eps=1e-6; namespace SA&#123; struct Pnt&#123; double x,y; Pnt(double a=0,double b=0)&#123;x=a,y=b;&#125; inline void get()&#123;x=rand(),y=rand();&#125; &#125;;// template&lt;typename T&gt; inline double calc(Pnt x)&#123;/*---估价函数*/return 0;&#125; inline double get_rand()&#123;return rand()*1.0/RAND_MAX;&#125;//如果可以是负数再随机一次符号 inline void work()&#123; double tmp=1000;//可以是系数或是步长,这里是步长 Pnt O,now; O.get(); double Ans=calc(O),ans; bool find; while(tmp&gt;eps)&#123; find=0; now=Pnt(O.x+tmp*get_rand(),O.y+tmp*get_rand()); ans=calc(now); if(ans&lt;Ans)Ans=ans,O=now,find=1; &#125;if(!find)tmp/=2; &#125; &#125;&#125;/*---splay_one*/namespace Splay_one&#123;//此处为一个spaly const int N=1e4+10; int ch[N][2],fa[N],siz[N],rt; int v[N],cnt;//以权值排序为例,当然也可以不用排序, #define lc ch[x][0] #define rc ch[x][1] inline void pushup(ri x)&#123;siz[x]=siz[lc]+siz[rc]+1;/*---*/&#125; inline void rotate(ri x)&#123; ri y=fa[x],z=fa[y],k=ch[y][1]!=x; ch[z][ch[z][1]==y]=x,fa[x]=z; ch[y][!k]=ch[x][k],fa[ch[x][k]]=y; ch[x][k]=y,fa[y]=x,pushup(y);//降低常数 &#125;inline void pushdown(ri x)&#123;/*---懒惰标记下放*/&#125; int stk[N],tail; inline void splay(ri x,ri goal)&#123; ri y,z; /* stk[++tail]=x; for(y=x;fa[y]!=goal;y=fa[y])stk[++tail]=fa[y]; while(tail)pushdown(stk[tail--]); */ while(fa[x]!=goal)&#123; y=fa[x],z=fa[y]; if(z!=goal)(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y); rotate(x); &#125;if(!goal)rt=x; pushup(x); &#125;inline void Insert(ri x)&#123;//加入节点,加入前已初始化 ri y=rt; if(!y)&#123;rt=x;return;&#125; ri f=0; //pushdown(y); while(y)&#123; f=y,y=ch[y][v[x]&gt;=v[y]];// pushdown(y); &#125;fa[x]=f,ch[f][v[x]&gt;=v[f]]=x; splay(x,0); &#125;inline void del()&#123; ri x=rt,k; if(lc)k=0; else if(rc)k=1; else &#123;rt=0;lc=rc=fa[x]=0;return;&#125; ri y=ch[x][k];// pushdown(y); while(ch[y][!k])&#123; y=ch[y][!k];// pushdown(y); &#125;splay(y,x); ch[y][!k]=ch[x][!k],fa[ch[x][!k]]=y,fa[y]=0,rt=y; pushup(y),lc=rc=fa[x]=0; &#125;inline void Del(ri val)&#123;//删除权值为val的点,此处如有多个只删一个 ri x=rt; while(x)&#123;// pushdown(x); if(v[x]!=val)x=ch[x][val&gt;v[x]]; else&#123; splay(x,0),del(); return; &#125; &#125; &#125;inline int kth(ri k)&#123; ri x=rt; while(x)&#123; pushdown(x); if(siz[lc]&gt;=k)x=lc; else &#123; k-=siz[lc]+1; if(!k)return x;//之后要splay一次 x=rc; &#125; &#125; &#125;inline void split(ri L,ri R)&#123;//以加入-inf,inf哨兵为例 ri x=kth(L);splay(x,0); ri y=kth(R+2);splay(y,x); //ch[y][0]即为区间[L,R] &#125;inline int build(ri L,ri R)&#123;//笛卡尔建树 if(L&gt;R)return 0; ri x=(L+R)&gt;&gt;1; lc=build(L,x-1),rc=build(x+1,R); fa[lc]=fa[rc]=x; pushup(x);return x; &#125;//最后别忘了fa[rt]=0;如果多次建树的话 #undef lc #undef rc&#125;/*---splay_two*/namespace Splay_two&#123;//多颗spaly,内含启发式合并 const int N=1e4+10; int ch[N][2],fa[N],siz[N],rt[N]; int v[N]; #define lc ch[x][0] #define rc ch[x][1] inline void pushup(ri x)&#123;siz[x]=siz[lc]+siz[rc]+1;&#125; inline void rotate(ri x)&#123; ri y=fa[x],z=fa[y],k=ch[y][1]!=x; ch[z][ch[z][1]==y]=x,fa[x]=z; ch[y][!k]=ch[x][k],fa[ch[x][k]]=y; ch[x][k]=y,fa[y]=x,pushup(y); &#125;inline void pushdown(ri x)&#123;/*---*/&#125; int stk[N],tail; int st[N],tot; /*---begin 这段部分与一棵树的差别只在于记录了是处理哪棵树*/ inline void splay(ri p,ri x,ri goal)&#123; ri y,z; /* stk[++tail]=x; for(y=x;fa[y]!=goal;y=fa[y])stk[++tail]=fa[y]; while(tail)pushdown(stk[tail--]); */ while(fa[x]!=goal)&#123; y=fa[x],z=fa[y]; if(z!=goal)(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y); rotate(x); &#125;if(!goal)rt[p]=x; pushup(x); &#125;inline void Insert(ri p,ri x)&#123; ri y=rt[p]; if(!y)&#123;rt[p]=x;return;&#125; ri f=0;// pushdown(y); while(y)&#123; f=y,y=ch[y][v[x]&gt;=v[y]];// pushdown(y); &#125;fa[x]=f,ch[f][v[x]&gt;=v[f]]=x; splay(p,x,0); &#125;inline void del(ri p)&#123; ri x=rt[p],k; if(lc)k=0; else if(rc)k=1; else &#123;rt[p]=0;lc=rc=fa[x]=0;return;&#125; ri y=ch[x][k];// pushdown(y); while(ch[y][!k])&#123; y=ch[y][!k];// pushdown(y); &#125;splay(p,y,x); ch[y][!k]=ch[x][!k],fa[ch[x][!k]]=y,fa[y]=0,rt[p]=y; pushup(y),lc=rc=fa[x]=0; &#125;inline void Del(ri p,ri val)&#123; ri x=rt[p]; while(x)&#123;// pushdown(x); if(v[x]!=val)x=ch[x][val&gt;v[x]]; else&#123; splay(p,x,0),del(p); return; &#125; &#125; &#125;inline int kth(ri p,ri k)&#123; ri x=rt[p]; while(x)&#123; //pushdown(x); if(siz[lc]&gt;=k)x=lc; else &#123; k-=siz[lc]+1; if(!k)return x;//之后要splay一次 x=rc; &#125; &#125; &#125;inline void split(ri p,ri L,ri R)&#123;//以加入-inf,inf哨兵为例 ri x=kth(p,L);splay(p,x,0); ri y=kth(p,R+2);splay(p,y,x); //ch[y][0]即为区间[L,R] &#125; /*---end*/ inline void dfs(ri x)&#123;if(!x)return;dfs(lc),st[++tot]=x,dfs(rc);lc=rc=fa[x]=0;&#125; inline void Merge(ri x,ri y)&#123;//合并两颗splay if(siz[x]&gt;siz[y])swap(x,y); //不过大部分题目用启发式合并并不需要对每个点维护siz,一般只用维护rt的siz,可以降低常数(少pushup) tot=0,dfs(rt[x]);//遍历较小的spaly for(ri i=1;i&lt;=tot;++i)Insert(y,st[i]); &#125; #undef lc #undef rc&#125;/*---标准LCT*/namespace LCT&#123; const int N=1e5+10; int ch[N][2],fa[N],rev[N],stk[N],top; #define lc ch[x][0] #define rc ch[x][1] inline bool rt(ri x)&#123;ri y=fa[x];return ch[y][0]!=x&amp;&amp;ch[y][1]!=x;&#125; inline void pushdown(ri x)&#123;if(rev[x])swap(lc,rc),rev[lc]^=1,rev[rc]^=1,rev[x]=0;&#125; inline void pushup(ri x)&#123;&#125; inline void rotate(ri x)&#123; ri y=fa[x],z=fa[y],k=ch[y][1]!=x; if(!rt(y))ch[z][ch[z][1]==y]=x;fa[x]=z; ch[y][!k]=ch[x][k],fa[ch[x][k]]=y; ch[x][k]=y,fa[y]=x;pushup(y); &#125;inline void splay(ri x)&#123; ri y,z; for(stk[++top]=y=x;!rt(y);y=fa[y])stk[++top]=fa[y]; while(top)pushdown(stk[top--]); while(!rt(x))&#123; y=fa[x],z=fa[y]; if(!rt(y))(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y); rotate(x); &#125;pushup(x); &#125;inline int access(ri x)&#123;ri y; for(y=0;x;x=fa[y=x]) splay(x),rc=y,pushup(x); return y; &#125;inline void makeroot(ri x)&#123;access(x),splay(x),rev[x]^=1;&#125; inline void link(ri x,ri y)&#123;makeroot(x),fa[x]=y;&#125; inline void split(ri x,ri y)&#123;makeroot(x),access(y),splay(y);&#125; inline int findroot(ri x)&#123; access(x),splay(x); while(lc)x=lc; splay(x); return x; &#125; #undef lc #undef rc&#125; /*---较难版本LCT*/namespace LCT_2&#123;//以可以实现链反转,链求和为例(不带链修改,懒得写) const int N=1e4+10; #define lc ch[x][0] #define rc ch[x][1] struct Splay&#123; int ch[N][2],fa[N],v[N],rev[N],siz[N],s[N]; inline void pushup(ri x)&#123; siz[x]=siz[lc]+siz[rc]+1; s[x]=s[lc]+s[rc]+v[x]; &#125;inline void pushdown(ri x)&#123;if(rev[x])swap(lc,rc),rev[lc]^=1,rev[rc]^=1,rev[x]=0;&#125; int stk[N],tail; inline void rotate(ri x)&#123; ri y=fa[x],z=fa[y],k=ch[y][1]!=x; ch[z][ch[z][1]==y]=x,fa[x]=z; ch[y][!k]=ch[x][k],fa[ch[x][k]]=y; ch[x][k]=y,fa[y]=x,pushup(y); &#125;inline void splay(ri x,ri goal)&#123; ri y,z; stk[++tail]=x; for(y=x;fa[y]!=goal;y=fa[y])stk[++tail]=fa[y]; while(tail)pushdown(stk[tail--]); while(fa[x]!=goal)&#123; y=fa[x],z=fa[y]; if(z!=goal)(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y); rotate(x); &#125;pushup(x); &#125;inline void split(ri x,ri k,ri&amp;a,ri&amp;b)&#123; while(x)&#123; pushdown(x); if(siz[lc]&gt;=k)x=lc; else&#123; k-=siz[lc]+1; if(!k)&#123; splay(x,0); a=x,b=rc; rc=fa[b]=0; pushup(x); return; &#125;x=rc; &#125; &#125; &#125;inline void Merge(ri x,ri y,ri&amp;a)&#123; pushdown(x); while(rc)x=rc,pushdown(x); splay(x,0); rc=y,a=x; pushup(x); &#125; &#125;S; int ch[N][2],fa[N],siz[N];//如果需要实现链反转需要维护siz int rt[N],rev[N]; inline bool rot(ri x)&#123;ri y=fa[x];return ch[y][0]!=x&amp;&amp;ch[y][1]!=x;&#125; inline void pushup(ri x)&#123;siz[x]=siz[lc]+siz[rc]+1;&#125; inline void rotate(ri x)&#123; ri y=fa[x],z=fa[y],k=ch[y][1]!=x; if(!rot(y))ch[z][ch[z][1]==y]=x;fa[x]=z; ch[y][!k]=ch[x][k],fa[ch[x][k]]=y; ch[x][k]=y,fa[y]=x,pushup(y); &#125;inline void pushdown(ri x)&#123;if(rev[x])swap(lc,rc),rev[lc]^=1,rev[rc]^=1,rev[x]=0;&#125; int stk[N],tail; inline void splay(ri x)&#123; ri y,z; stk[++tail]=x; for(y=x;!rot(y);y=fa[y])stk[++tail]=fa[y]; while(tail)pushdown(stk[tail--]); swap(rt[x],rt[y]); while(!rot(x))&#123; y=fa[x],z=fa[y]; if(!rot(y))(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y); rotate(x); &#125;pushup(x); &#125;inline void access(ri x)&#123; for(ri y=0;x;x=fa[y=x])&#123; splay(x); if(rc)S.split(rt[x],siz[lc]+1,rt[x],rt[rc]); if(y)S.Merge(rt[x],rt[y],rt[x]),rt[y]=0; rc=y,pushup(x); &#125; &#125;inline void makeroot(ri x)&#123;access(x),splay(x),rev[x]^=1,S.rev[rt[x]]^=1;&#125; inline void link(ri x,ri y)&#123;makeroot(x),fa[x]=y;&#125; inline void split(ri x,ri y)&#123;makeroot(x),access(y),splay(y);&#125; inline void reverse(ri x,ri y)&#123;split(x,y),S.rev[rt[y]]^=1;&#125;/*---链反转*/ #undef lc #undef rc&#125;/*---吉司林线段树*/namespace JSL_Segment_Tree&#123; const int N=2e4; int l[N],r[N],mn[N],cn[N],sn[N],sum[N],tag[N];//以取max,求区间和为例,记录最小、次小、最小个数,总和,以及懒惰标记 int a[N],rt,cnt; #define lc l[x] #define rc r[x] inline void pushup(ri x)&#123; if(mn[lc]&lt;mn[rc])mn[x]=mn[lc],sn[x]=sn[lc],cn[x]=min(cn[lc],mn[rc]); else if(mn[rc]&lt;mn[lc])mn[x]=mn[rc],sn[x]=sn[rc],cn[x]=min(cn[rc],mn[lc]); else mn[x]=mn[lc],sn[x]=sn[lc]+sn[rc],cn[x]=min(cn[lc],cn[rc]); &#125;inline void build(ri&amp;x,ri L,ri R)&#123; x=++cnt;tag[x]=-inf; if(L==R)&#123;mn[x]=sum[x]=a[L],cn[x]=inf,sn[x]=1;return;&#125; ri mid=(L+R)&gt;&gt;1; build(lc,L,mid),build(rc,mid+1,R); pushup(x); &#125;inline void push_tag(ri x,ri v)&#123; if(v&lt;=tag[x])return; sum[x]+=(v-tag[x])*sn[x],mn[x]=tag[x]=v; &#125;inline void pushdown(ri x)&#123; if(tag[x]!=-inf)push_tag(lc,tag[x]),push_tag(rc,tag[x]),tag[x]=-inf; &#125;inline void Modify(ri x,ri L,ri R,ri ll,ri rr,ri v)&#123; if(mn[x]&gt;=v)return; if(ll&lt;=L&amp;&amp;R&lt;=rr&amp;&amp;cn[x]&gt;v)return push_tag(x,v); ri mid=(L+R)&gt;&gt;1;pushdown(x); if(ll&lt;=mid)Modify(lc,L,mid,ll,rr,v); if(rr&gt;mid)Modify(rc,mid+1,R,ll,rr,v); pushup(x); &#125;inline int query(ri x,ri L,ri R,ri ll,ri rr)&#123; if(ll&lt;=L&amp;&amp;R&lt;=rr)return sum[x]; int mid=(L+R)&gt;&gt;1;pushdown(x); if(ll&gt;mid)return query(rc,mid+1,R,ll,rr); else if(rr&lt;=mid)return query(lc,L,mid,ll,rr); else return query(lc,L,mid,ll,rr)+query(rc,mid+1,R,ll,rr); &#125; #undef lc #undef rc&#125;/*---李超树*/namespace LC_Tree&#123; const int N=1e5+10; #define lc ch[x][0] #define rc ch[x][1] int ch[N][2],l[N],r[N],cnt; LL dl[N],dr[N],K[N],B[N],mn[N],dis[N]; inline LL f(ri x,LL k,LL b)&#123;return b+k*x;&#125; inline void pushup(ri x)&#123;mn[x]=min(mn[x],min(mn[lc],mn[rc]));&#125; inline void build(ri&amp;x,ri L,ri R)&#123; x=++cnt;B[x]=mn[x]=inf;l[x]=L,r[x]=R; if(L==R)&#123;dl[x]=dr[x]=dis[L];return;&#125; ri mid=(L+R)&gt;&gt;1; build(lc,L,mid),build(rc,mid+1,R); dl[x]=dl[lc],dr[x]=dr[rc]; &#125;inline void extand(ri x,LL k,LL b)&#123;//以维护最下方的线段为例 LL f1,f2,f3,f4; f1=f(dl[x],K[x],B[x]),f2=f(dr[x],K[x],B[x]); f3=f(dl[x],k,b),f4=f(dr[x],k,b); if(f3&lt;=f1&amp;&amp;f4&lt;=f2)&#123;K[x]=k,B[x]=b;mn[x]=min(mn[x],min(f3,f4));return;&#125; if(f3&gt;f1&amp;&amp;f4&gt;f2)return; LL g=(b-B[x])/(K[x]-k); LL h=dr[lc]; if(g&lt;=h||f3&lt;=f1)extand(lc,k,b); if(g&gt;h||f4&lt;=f2)extand(rc,k,b); pushup(x); &#125;inline void Modify(ri x,ri ll,ri rr,ri k,ri b)&#123; if(ll&lt;=l[x]&amp;&amp;r[x]&lt;=rr)return extand(x,k,b); ri mid=(l[x]+r[x])&gt;&gt;1; if(ll&lt;=mid)Modify(lc,ll,rr,k,b); if(rr&gt;mid)Modify(rc,ll,rr,k,b); pushup(x); &#125;inline LL query(ri x,ri ll,ri rr)&#123; if(ll&lt;=l[x]&amp;&amp;r[x]&lt;=rr)return mn[x]; ri mid=(l[x]+r[x])&gt;&gt;1; LL ans=inf; if(ll&lt;=mid)ans=min(ans,query(lc,ll,rr)); if(rr&gt;mid)ans=min(ans,query(rc,ll,rr)); ri L=max(ll,l[x]),R=min(rr,r[x]); ans=min(ans,f(dis[L],K[x],B[x])); ans=min(ans,f(dis[R],K[x],B[x])); return ans; &#125; #undef lc #undef rc&#125;/*---KD-Tree*/namespace KDT&#123;//以k远点对为例 const int N=1e5+10,M=N&lt;&lt;1; #define lc ch[x][0] #define rc ch[x][1] struct pnt&#123; int x[2]; &#125;a[N]; int opt; struct node&#123;int dis;node(ri a=0)&#123;dis=a;&#125;inline bool operator &lt;(const node&amp;other)const&#123;return dis&gt;other.dis;&#125;&#125;;;//小根堆 priority_queue&lt;node&gt;q; inline bool cmp(register pnt a,register pnt b)&#123;return a.x[opt]&lt;b.x[opt];&#125; inline int f(pnt a,pnt b)&#123;return sqr(a.x[0]-b.x[0])+sqr(a.x[1]-b.x[1]);&#125; struct ST&#123; int ch[M][2],minn[M][2],maxn[M][2],cnt; pnt d[M]; inline void pushup(ri x)&#123; for(ri i=0;i&lt;2;++i)maxn[x][i]=minn[x][i]=d[x].x[i]; if(lc)for(ri i=0;i&lt;2;++i)maxn[x][i]=max(maxn[x][i],maxn[lc][i]),minn[x][i]=min(minn[x][i],minn[lc][i]); if(rc)for(ri i=0;i&lt;2;++i)maxn[x][i]=max(maxn[x][i],maxn[rc][i]),minn[x][i]=min(minn[x][i],minn[rc][i]); &#125;inline int build(ri L,ri R,ri k)&#123; if(L&gt;R)return 0; ri x=++cnt;opt=k; ri mid=(L+R)&gt;&gt;1; nth_element(a+L,a+mid,a+R+1,cmp); d[x]=a[mid]; lc=build(L,mid-1,k^1),rc=build(mid+1,R,k^1); pushup(x); &#125;inline int g(pnt a,ri b)&#123; return max(sqr(maxn[b][0]-a.x[0]),sqr(minn[b][0]-a.x[0]))+max(sqr(maxn[b][1]-a.x[1]),sqr(minn[b][1]-a.x[1])); &#125;inline void query(ri x,pnt O)&#123; ri dl=-inf,dr=-inf; if(lc)dl=g(O,lc); if(rc)dr=g(O,rc); ri dis=f(d[x],O); if(q.top().dis&lt;dis)q.pop(),q.push(dis); if(dl&gt;dr)&#123;if(q.top().dis&lt;dl)query(lc,O);if(q.top().dis&lt;dr)query(rc,O);&#125; else &#123;if(q.top().dis&lt;dr)query(rc,O);if(q.top().dis&lt;dl)query(lc,O);&#125; &#125; &#125;; #undef lc #undef rc &#125;/*---左偏树*/namespace leftist_heap&#123; const int N=1e4+10; int rt,dep[N],l[N],r[N],v[N]; inline void pushr(ri x,ri v)&#123;/*---*/&#125; inline void pushdown(ri x)&#123;/*---下放懒惰标记*/&#125; inline int Merge(ri k1,ri k2)&#123;//以大跟堆为例 if(!k1||!k2)return k1|k2; pushdown(k1),pushdown(k2); if(v[k1]&lt;v[k2])swap(k1,k2); r[k1]=Merge(r[k1],k2); if(dep[r[k1]]&gt;dep[l[k1]])swap(l[k1],r[k1]); dep[k1]=dep[r[k1]]+1;return k1; &#125;inline int top()&#123;return rt;&#125; inline void pop()&#123;rt=Merge(l[rt],r[rt]),l[rt]=r[rt]=0;&#125;&#125;/*---长链剖分(通常是处理树上与dep深度有关的dp问题)*/namespace unknown_name_3&#123; const int N=1e4+10; int len[N],d[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],fa[N],son[N]; int tmp[N],*id,*dp[N]; inline void dfs(ri x)&#123; for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(u!=fa[x]) fa[u]=x,dfs(u),son[x]=len[u]&gt;len[son[x]]?u:son[x]; &#125;len[x]=len[son[x]]+1; &#125;inline void Dp(ri x)&#123; /*---此处预处理*/ if(son[x])&#123; dp[son[x]]=dp[x]+1; Dp(son[x]); /*---因题而异,有的题需要继承son[x]的答案什么的*/ &#125;for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(u!=fa[x])&#123; Dp(u); /*---work,此处dp*/ &#125; &#125; &#125;&#125;/*---重链剖分HDT*/namespace HDT&#123;//可以用重链剖分将树上的链转化为不超过logn条轻,每条链的编号是连续的 //因此可以将部分较麻烦的树上问题改成维护若干条链。 //也可以O(logn)求Lca,自带1/4的常数,还可以实现链反转,以及做动态链反转、链排序等等神仙题qwq const int N=1e5+10; int low[N],dfn[N],top[N],son[N],fa[N],siz[N],Tim; int d[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],tot; int dep[N]; inline void dfs1(ri x)&#123; siz[x]=1; for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(u==fa[x])continue; fa[u]=x,dep[u]=dep[x]+1; dfs1(u),siz[x]+=siz[u]; son[x]=siz[u]&gt;siz[son[x]]?u:son[x]; &#125; &#125;inline void dfs2(ri x)&#123; low[dfn[x]=++Tim]=x; if(!son[x])return; top[son[x]]=top[x]; dfs2(son[x]); for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(u==fa[x]||u==son[x])continue; top[u]=u; dfs2(u); &#125; &#125;inline void init()&#123;dep[1]=top[1]=1;dfs1(1),dfs2(1);&#125; inline int Lca(ri u,ri v)&#123;while(top[u]!=top[v])&#123;if(dep[top[u]]&lt;dep[top[v]])swap(u,v);u=fa[top[u]];&#125;return dep[u]&lt;dep[v]?u:v;&#125; inline void Modify(ri u,ri v)&#123; while(top[u]!=top[v])&#123; if(dep[top[u]]&lt;dep[top[v]])swap(u,v);// modify(dfn[top[u]],dfn[u]);//因题而异,有的题甚至是将这些链存起来再进行操作 &#125;if(dep[u]&gt;dep[v])swap(u,v);// modify(dfn[u],dfn[v]); &#125;inline int query(ri u,ri v)&#123; //大体同上 &#125;&#125; /*---线段树合并*/namespace unknown_name_4&#123; const int N=1e4+10; int l[N*50],r[N*50],siz[N*50],cnt;//以你的名字为例 #define lc l[x] #define rc r[x] inline void New(ri&amp;x,ri L,ri R,ri pos)&#123; siz[x=++cnt]=1; if(L==R)return; ri mid=(L+R)&gt;&gt;1; if(pos&lt;=mid)New(lc,L,mid,pos); else New(rc,mid+1,R,pos); &#125;inline int Merge(ri x,ri y)&#123; if(!x||!y)return x|y; ri o=++cnt; siz[o]=siz[x]+siz[y]; l[o]=Merge(l[x],l[y]),r[o]=Merge(r[x],r[y]); return o; &#125;inline int query(ri x,ri L,ri R,ri ll,ri rr)&#123; if(!x)return 0; if(ll&lt;=L&amp;&amp;R&lt;=rr)return siz[x]; ri mid=(L+R)&gt;&gt;1; if(ll&gt;mid)return query(rc,mid+1,R,ll,rr); else if(rr&lt;=mid)return query(lc,L,mid,ll,rr); else return query(lc,L,mid,ll,rr)+query(rc,mid+1,R,ll,rr); &#125; #undef lc #undef rc&#125;/*---莫队合集*/namespace MD&#123; namespace MD_1&#123;//不带修改普通莫队 &#125;namespace MD_2&#123;//带修改普通莫队 &#125;namespace MD_3&#123;//不带修改树上莫队 &#125;namespace MD_4&#123;//带修改树上莫队 &#125;&#125;/*---分块*/namespace FK&#123;//有预处理出单个块的答案,预处理出块与块之间的答案(部分可用ST表优化),权值分块,将询问分块,树上分块等等 &#125;/*---Berlekamp-Massey算法*/namespace Berlekamp_Massey&#123; const int N=505; const double eps=1e-8; vector&lt;double&gt;ans[N]; double delta[N]; int fail[N]; inline void calc(ri*a,ri n,ri*b,ri&amp;cnt)&#123; ri Max,Mul; for(ri i=1,j,tmp;i&lt;=n;++i)&#123; tmp=a[i]; for(j=ans[cnt].size()-1;~j;--j) tmp-=ans[cnt][j]*a[i-j-1]; delta[i]=tmp; if(fabs(tmp)&lt;eps)continue; fail[cnt]=i; if(!cnt)&#123;ans[++cnt].resize(i);continue;&#125; Mul=tmp/delta[fail[cnt-1]]; ++cnt,ans[cnt].resize(i-fail[cnt-2]-1); ans[cnt].push_back(Mul); Max=ans[cnt-2].size(); for(j=0;j&lt;Max;++j)ans[cnt].push_back(ans[cnt-2][j]*-Mul); Max=ans[cnt-1].size(); if(ans[cnt].size()&lt;Max)ans[cnt].resize(Max); for(j=0;j&lt;Max;++j) ans[cnt][j]+=ans[cnt-1][j]; &#125;for(ri i=ans[cnt].size()-1;~i;--i)b[i]=ans[cnt][i]; cnt=ans[cnt].size(); &#125;&#125;/*--- 凸包*/namespace convex_hull&#123;&#125;int main()&#123; return 0;&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
