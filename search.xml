<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>施图姆-刘维尔的一些研究</title>
    <url>/2022/02/26/Storm_liouville_equation_researches/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们知道，任何二阶线性常微分方程都可以化为施图姆-刘维尔方程：</p>
<script type="math/tex; mode=display">
\frac {\rm d} {\rm dx} \left [p(x)\frac {\rm dy} {\rm dx} \right] + q(x)y+\lambda \rho(x) y = 0</script><p>鉴于一般的施图姆-刘维尔理论没什么意思，<del>因为我不会</del>，我们来看一些特殊情况。</p>
<a id="more"></a>
<p>（不想写，摸了）</p>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>数学物理方法</tag>
      </tags>
  </entry>
  <entry>
    <title>日本的近代化01 序言和背景（更新中）</title>
    <url>/2022/05/10/japan-modernization-1/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>声明：笔者为业余历史爱好者，本文中将不可避免出现考据不严谨或者历史暴论，希望读者不吝赐教，感激不尽。</p>
<a id="more"></a>
<hr>
<p>众所周知，简中互联网上关于日本战国和旧日本帝国的内容非常充实,但对日本的近代化历程的关注度一直有限。<img src="https://cdn.jsdelivr.net/gh/mayakovsji/images@main/20220512102407.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/mayakovsji/images@main/image-20220512102613104.png" alt="image-20220512102613104"></p>
<p><img src="https://cdn.jsdelivr.net/gh/mayakovsji/images@main/tewst.png" alt=""></p>
<center style="font-size:11px;"> 从某乎的关注度可见一斑  </center>



<p>然而“明治维新”这一在义务教育课本中都有所涉猎课题，讨论度如此有限让笔者感到惊讶。经过一些粗浅的研究后，笔者的收获包括但不限于了解到了日本海陆矛盾的起源，大正民主的幻想如何从起源到破灭，法西斯分子如何夺取政权，旧日本帝国军队的诞生和异化，等等有趣的话题。笔者希望通过一系列大纲性质的专栏，为大家科普日本的近代化进程。同时也希望抛砖引玉，吸引更多的朋友来研究该领域。</p>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>1853年7月8日，大清咸丰三年，也是日本嘉永六年，美国东印度舰队司令官马修·佩里率领四艘蒸汽战舰“萨斯喀那”号、“普利茅斯”号、“萨拉托加”号和“密西西比”号，驶入江户湾的门户——浦贺港，向日本递交美国总统的国书。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mayakovsji/images@main/1853Yokohama_01.jpg" alt="1853Yokohama_01"></p>
 <center style="font-size:11px;"> 黑船来航事件 </center> 



<p>在日本人看来如天狗下凡，喷吐着浓烟，发出巨响的美国军舰，全身涂抹着玄黑色，于是被称为“黑船”，这就是著名的“黑船事件”。</p>
<p>是时，江户城中居民们惊恐地望向这些不可撼动的钢铁巨兽；武士们奔走于街巷，忙于备战；城外的寺院钟声齐鸣，人们涌入神社，祷告神灵，祈求曾经击败蒙古大军的“护国神风”再临，赶走米利幹国来的侵略者。</p>
<p>当天午夜，江户城的信鸽将“黑船”到来的消息送往京都，孝明天皇天颜失色，幕府两百年来维持的统治正遭受严峻的挑战，而幕府上下都毫无应对之策。孝明天皇本人一筹莫展，只得亲自前往神社连续祈祷十七天，祈求天下太平，皇祚长久。征夷大将军德川家庆接到美国国书之后，带病与幕阁讨论时急火攻心而逝世。</p>
<p>7月14日，幕府最终决定接受国书，双方在久里滨举行了接受仪式，日方承诺向美方开放港口，提供煤水补给，保护美国船员等，但对条款的细节拖延到次年答复。在返航前夕，佩里舰队开入江户湾深处测量水文，面对日本官员的质问，佩里告诉日方，来年春天将带着一支更大的舰队再来日本，在寻求一个更大的锚地。7月17日，佩里舰队经琉球返回上海。</p>
<p>自德川家康的“锁国令”颁布以来，日本的国门就这样向西方国家再次洞开了。</p>
<p>1854年《日美和亲条约》（神奈川条约）、《日美修好通商条约》（下田条约）、《日英协约》、《日俄和亲条约》相继签订，随后1858年更是与美、俄、英、荷、法签订了有关开港、领事裁判权、居留地的《安政五国条约》，作为中国人的我们无疑会有“既视感”：幕府似乎正步大清国之后尘，落入西方列强的殖民深渊。</p>
<p>但历史告诉我们，在短短二十年之后，幕府的封建统治被各藩联军推翻，而日本也在追赶工业化末班车的道路上狂奔，作为近代东亚率先掀起文明开化浪潮的日本，却选择了走向军国主义道路。从德川时代的和平，到明治时代的内战外战，从大正民主的幻梦，到昭和民族主义的野兽，近代日本历史的“变异性”在此展现无遗。</p>
<p>大起大落，沉浮兴亡。是为序。</p>
<h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><h3 id="江户幕府的统治"><a href="#江户幕府的统治" class="headerlink" title="江户幕府的统治"></a>江户幕府的统治</h3><p>作为日本统一以来事实上的统治者，自1603年德川家康自立为征夷大将军以来，江户幕府已走过了两个多世纪的历史。终结战国乱世的德川家康试图不依靠皇室、贵族的旧有权威管理国家，无论德川一派，还是与德川对抗的一派大名均得到了新的封地。全国大名分为三大类，即亲藩、谱带和外样。亲藩之中御三家的藩祖都是家康的亲儿子，代代子孙可为将军候补者，确保幕府将军血统纯正。除御三家外，又有将军庶子一系的御三卿，御三家的庶子分流而出的御连枝等，枝繁叶茂支撑起江户幕府。谱代大名的藩主大多是以“德川四天王”为代表的德川老根据地三河国的地头家族。而位居下层的外样大名，多是曾与德川家对抗或在秀吉死后才归顺的，他们在幕末蜂起打破幕藩制度，是开创明治新时代的主力。</p>
<p>所谓幕藩体制，由幕府和藩组成，最大的特征是遵照分割统治与世袭的身份制原则来进行统治。在这一体制下，全国的土地主要分为幕领和大名领，幕领又分为直辖地（天领）和旗本领（幕府的直参家臣），大名领分为藩直辖地和家臣给地。幕府直参的武士和各藩藩士都没有给地，有的由幕府或藩支给一部分禄米。</p>
<p><img src="https://cdn.jsdelivr.net/gh/mayakovsji/images@main/canjinjiaodai.jpeg" alt="canjinjiaodai"></p>
<center style="font-size:11px;">大名的参觐交代队列</center> 

<p>幕府与各大名之间的关系是以幕府可以要求各大名的军役，但幕府对各大名不行使征税权，各藩的领地收入原则上由各藩支配。于是幕府控制大名的主要手段——参觐交代——各藩的大名需要前往江户替幕府将军执行政务一段时间，然后返回自己领土执行政务。等于是让大名定期作人质。除此之外，各大名还要承担“普请”劳役，为幕府修筑城池、道路、水利工程等。</p>
<h3 id="幕藩体制下的等级制社会"><a href="#幕藩体制下的等级制社会" class="headerlink" title="幕藩体制下的等级制社会"></a>幕藩体制下的等级制社会</h3><p>经历了日本战国乱象，无论是统一日本过程中的织田信长、丰臣秀吉，还是德川家康，都希望建立起组织严密的封建政权。以丰臣秀吉的“太阁检地”丈量土地并确立耕地所有权为标志，庄园制宣告解体，一方面将农民世世代代束缚在土地上，从事农业生产，另一方面也切断了武士阶级与农业的联系，使他们依赖俸禄为生。即所谓“兵农分离”。</p>
<p>在这里我们可以聊一聊在日本家喻户晓的《忠臣藏》的原型，也就是江户时代的“赤穗事件”</p>
<p>播磨国赤穗藩藩主浅野长矩在奉命接待朝廷敕使一事上深觉受到总指导高家旗本吉良义央的刁难与侮辱，愤而在幕府将军居城江户城的大廊上拔刀砍伤吉良义央。此事让将军德川纲吉在敕使面前蒙羞，将军怒不可遏，在尚未深究事件原由的情况下，当日便命令浅野长矩切腹谢罪并将赤穗废藩，而吉良义央未受任何处分。以首席家老大石良雄为首的赤穗家臣们虽然试图向幕府请愿以图复藩再兴，但一年后确定复藩无望，大石遂率领赤穗家臣共47人夜袭吉良宅邸，斩杀吉良义央，将其首级供在泉岳寺主君墓前，成功复仇。事发后虽然舆论皆谓之为忠臣义士，但幕府最后仍决定命令与事的赤穗家臣切腹自尽，而吉良家也遭到没收领地及流放的处分。<sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<p>在这里我不讨论故事本身，而是想借此指明一点，驱使四十七士赴死的除了为主复仇的忠诚之外，很大一部分的原因是灭藩之后生活没有保障，无奈舍命抗争。大石留下的账簿反映出义士们的生活落魄，由此可见“兵农分离”确实使武士阶级成为了仰仗上级俸禄为生的寄生阶级，无法脱离藩而独活。由此，江户幕府也得以维持长期的平稳统治。同样，当先进的外国火器传入日本，武士军队可以被平民军队所轻松击败时，幕府的倒台也是可以预见的了。</p>
<p>关于江户时代等级社会的细节，这里引用一段材料<sup><a href="#fn_2" id="reffn_2">2</a></sup></p>
<blockquote>
<p>兵农分离，奠定了士农工商社会等级身份制的基础。在德川时代，据享保六年（1721）进行的首次人口统计，日本全国被编入身份制的人口大约为2600万，加上身份制之外人口，大约为3000万左右。据幕末人口统计，武士约为总人口的6％—7％，农民约为总人口的80％—85％，也就是说，仅士农两个等级，已占据了日本人口总数的90％左右；其下依次为：町人为5％—6％，秽多、非人等贱民为1.6％，神官、僧尼为1.5％。兵农分离的结果，使绝大多数的日本人分别被划定在武士与农民等两大身份等级之内，其余的数百万日本人，主要是手工业者“职人”和商人“町人”，从而形成了士农工商顺序排列的身份等级制。</p>
<p>在士农工商等级身份制度的框架内，统治阶级武士作为世袭的职业军人，垄断军事、警察部门，拥有佩刀、称姓，即通称“苗字带刀”和“杀人而官不问其罪”，即“切舍御免”等特权，凌驾于农工商等其他社会等级之上。在武士内部，又分成从执掌幕藩各级政权的家臣幕僚到冲锋陷阵的步兵“足轻”等几十个等级。武士内部的上下级之间层层隶属，个人不得“退仕”自行改变武士身份或“脱藩”擅离职守，以效忠主君为第一要务，形成相对稳固的统治序列。作为体现武士阶级的人生价值观念、道德准绳和社会优越意识的精神信条，武士道在德川时期非常盛行。</p>
<p>农民在德川时代被称为“百姓”，是农业社会的主要生产劳动者。封建领主认为“百姓乃天下之根本” ，推行重农抑商政策。因此，农民的社会地位仅次于武士，而居工匠、商人之上。在农民等级内部，也按照各自在村中的地位、财产的多寡、担负封建地税的能力和数量，划分成不同层次。地位最高者，是在当地素有影响和实力的“草分百姓”、“持高百姓”，有权出任村吏，管理和代表本村，完成赋役、治安、禁教等各项差遣。位居其下者，是农民中人数最多的自耕农“本百姓”，他们的名字被写进土地户口账簿“检地账”，拥有家屋和耕地使用权；他们也被记入村内收租账本“名寄账”，承担缴纳年贡、杂税等义务。作为交换，他们拥有领主承认其在村社地位的“百姓株”，享有田渠用水权和山林用益权。地位又等而次之的，是相当于佃农的“名子”、“被官”，他们是隶属于“本百姓”的依附农民，不具有相应的权利。处于农民等级最下层的赤贫农民，称为“水吞百姓”，他们未被记入检地账，也无任何权力，经常流离失所。</p>
<p>居住在城市街区城下町的手工业者和商人，也各按行业分工分别居住在职人町或商人町，各由职人头或商人司负责管理，内部实行自治。职人分成效劳于领主的“御职人”或从事一般手工业生产的“平职人”，彼此地位高低不同。商人则分成地产和店铺的规模很大、独立经营并拥有专卖权的御用商人“本町人”，其中少数御用大豪商为“扶持町人”，可以称姓、佩刀、骑马，分享准武士的特权待遇；“家持”、“大屋”等上层本町人把持了町街事务。无地产、房产的商人地位低下，其中借地租房者“借家人”无权参与町政，也不受任何保护，处于被支配的地位；“驻马”、“连雀”，是摆地摊的小商贩或走街串巷的流动商贩，地位最低，无任何权利保障。</p>
<p>在士农工商等级序列之外，还存在一种特殊的贱民。他们居住在町街特别划定的区域内，与外界隔绝，备受屈辱和蔑视。贱民分成从事屠宰、制革等被佛教视为不洁行业的“秽多”，由“秽多头”管理；此外，行乞者“非人”主要从事行刑时的服务性工作，他们被禁止束发，以示区别。</p>
</blockquote>
<p>当然，稳定的江户幕府也不能逃脱历史周期律，在18世纪中叶，幕府统治的腐化已经不可质疑。尽管武士仍尊为士农工商之首，但由于普遍贫穷或冒名顶替服役，武士阶级的战斗力正如八旗一样下降到了难以置信的地步。脱离生产又远离战乱的武士家族，人口自然飞速增长。同时维持着奢侈生活的武士家族走向破产，于是不得不拿出不动产，以至于武器、盔甲，典当给商人维持生活。</p>
<h3 id="江户时代的经济发展"><a href="#江户时代的经济发展" class="headerlink" title="江户时代的经济发展"></a>江户时代的经济发展</h3><p>经济基础决定上层建筑，日本步入资本主义社会，离不开江户时代的经济积累和市场发展。</p>
<h3 id="社会思潮的演变"><a href="#社会思潮的演变" class="headerlink" title="社会思潮的演变"></a>社会思潮的演变</h3><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p>一些本人研究该课题的参考书目：</p>
<ul>
<li>日本的近代化——与中国的比较 【日】依田憙家 （较为成体系地论述了日本各领域的近代化，推荐阅读）</li>
<li>黑船来航 【日】三谷博 （关于日本开国前后的一些讨论）</li>
<li>日俄战争：起源和开战【日】和田春树 </li>
<li>日本陆军史：近代化的异化  【日】户部良一 （对旧日本帝国陆军的综述性讨论）</li>
<li>菊花与锚 刘怡、阎京生 （对旧日本帝国海军的兴亡史的全面总结，其中不乏对政治格局和历史背景的讨论）</li>
</ul>
<blockquote id="fn_1">
<sup>1</sup>. <a href="https://zh.wikipedia.org/zh-hans/%E8%B5%A4%E7%A9%97%E4%BA%8B%E4%BB%B6" target="_blank" rel="external">赤穗事件维基百科</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 新编日本近代史 宋成有<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>复健计划第一弹：mathjax</title>
    <url>/2022/02/25/mathjax_learning/</url>
    <content><![CDATA[<h1 id="我回来辣（大声）"><a href="#我回来辣（大声）" class="headerlink" title="我回来辣（大声）"></a>我回来辣（大声）</h1><a id="more"></a>
<p>断网三年了，常用工具都忘得差不多了，接下来的文章是个人复习的笔记，所以取个名叫“复健”。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li><code>$...$</code>代表行内引用，<code>$$...$$</code>代表行外引用。</li>
<li><code>^  _</code>为上下标，<code>{}</code>用于分组<br>举例:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sample $C_&#123;a&#125;^b$ sample</div><div class="line">$$C_&#123;a&#125;^&#123;b&#125;$$</div></pre></td></tr></table></figure>
<p>sample $C_{a}^b$ sample</p>
<script type="math/tex; mode=display">C_{a}^{b}</script><h2 id="常用字符"><a href="#常用字符" class="headerlink" title="常用字符"></a>常用字符</h2><ul>
<li>注意在任意字符前添加<code>\not</code>即可添加不等符号。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\gamma \Gamma \varGamma</td>
<td style="text-align:center">希腊字母</td>
<td style="text-align:center">$\gamma$ $\Gamma$ $\varGamma$</td>
</tr>
<tr>
<td style="text-align:center">\vec {a}</td>
<td style="text-align:center">矢量</td>
<td style="text-align:center">$\vec {a}$</td>
</tr>
<tr>
<td style="text-align:center">\overline {a}</td>
<td style="text-align:center">上划线</td>
<td style="text-align:center">$\overline {a}$</td>
</tr>
<tr>
<td style="text-align:center">\underline {a}</td>
<td style="text-align:center">下划线</td>
<td style="text-align:center">$\underline {a}$</td>
</tr>
<tr>
<td style="text-align:center">\hat {a}</td>
<td style="text-align:center">^</td>
<td style="text-align:center">$\hat {a}$</td>
</tr>
<tr>
<td style="text-align:center">a \ a</td>
<td style="text-align:center">空格</td>
<td style="text-align:center">$a \ a$</td>
</tr>
<tr>
<td style="text-align:center">\langle \rangle</td>
<td style="text-align:center">尖括号</td>
<td style="text-align:center">$\langle \rangle$</td>
</tr>
<tr>
<td style="text-align:center">\vert \vert</td>
<td style="text-align:center">绝对值</td>
<td style="text-align:center">$\vert \vert$</td>
</tr>
<tr>
<td style="text-align:center">\Vert \Vert</td>
<td style="text-align:center">双竖线</td>
<td style="text-align:center">$\Vert \Vert$</td>
</tr>
<tr>
<td style="text-align:center">\frac {a} {b}</td>
<td style="text-align:center">分数线</td>
<td style="text-align:center">$\frac {a} {b}$</td>
</tr>
<tr>
<td style="text-align:center">\times \div \pm \mp \cdot \bigotimes</td>
<td style="text-align:center">各种算符</td>
<td style="text-align:center">$\times \div \pm \mp \cdot \bigotimes$</td>
</tr>
<tr>
<td style="text-align:center">\leq \geq \approx \not = \equiv</td>
<td style="text-align:center">关系</td>
<td style="text-align:center">$\leq \geq \approx \not= \equiv$</td>
</tr>
<tr>
<td style="text-align:center">\in \subset \subseteq \cap \cup \varnothing</td>
<td style="text-align:center">集合</td>
<td style="text-align:center">$\in \subset \subseteq \cap \cup \varnothing$</td>
</tr>
<tr>
<td style="text-align:center">\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}</td>
<td style="text-align:center">上下括号</td>
<td style="text-align:center">$\overbrace{a+\underbrace{b+c}_{1}+d}^{2}$</td>
</tr>
<tr>
<td style="text-align:center">\ldots \partial \rightarrow \Rightarrow</td>
<td style="text-align:center">符号</td>
<td style="text-align:center">$\ldots \ \partial \rightarrow \ \Rightarrow$</td>
</tr>
<tr>
<td style="text-align:center">\lim<em>{x\to\infty} \sum</em>{i=1}^N \int_a^b</td>
<td style="text-align:center">符号</td>
<td style="text-align:center">$\lim<em>{x\to\infty} \sum</em>{i=1}^N \int_a^b$</td>
</tr>
<tr>
<td style="text-align:center">\nabla \infty \forall \exists \triangle</td>
<td style="text-align:center">符号</td>
<td style="text-align:center">$\nabla \infty \forall \exists \triangle$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="特殊结构"><a href="#特殊结构" class="headerlink" title="特殊结构"></a>特殊结构</h2><h3 id="通用规则"><a href="#通用规则" class="headerlink" title="通用规则"></a>通用规则</h3><ul>
<li>起始/结束标记<code>\begin{name} \end{name}</code></li>
<li>换行<code>\\</code> 元素分隔符<code>&amp;</code></li>
</ul>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>常用的关键字有：无框<code>matrix</code>,小括号<code>pmatrix</code>,中括号<code>bmatrix</code>，单竖线（也就是行列式）<code>vmatrix</code>。<br>如<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$$\begin&#123;bmatrix&#125;</div><div class="line">1 &amp; 0 &amp; 0 \\</div><div class="line">0 &amp; 1 &amp; 0 \\</div><div class="line">0 &amp; 0 &amp; 1 \\</div><div class="line">\end&#123;bmatrix&#125;$$</div></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1 \\
\end{bmatrix}</script><p>在省略元素时，可以用：</p>
<ul>
<li>横省略号：\cdots</li>
<li>竖省略号：\vdots</li>
<li>斜省略号：\ddots</li>
</ul>
<p>如<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$$\begin&#123;bmatrix&#125;</div><div class="line">a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; \cdots &amp; a_&#123;1n&#125; \\</div><div class="line">a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; \cdots &amp; a_&#123;2n&#125; \\</div><div class="line">\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\</div><div class="line">a_&#123;n1&#125; &amp; a_&#123;n2&#125; &amp; \cdots &amp; a_&#123;nn&#125; \\</div><div class="line">\end&#123;bmatrix&#125;$$</div></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{n1} & a_{n2} & \cdots & a_{nn} \\
\end{bmatrix}</script><h3 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h3><ul>
<li>关键词<code>cases</code></li>
</ul>
<p>如<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$$\begin&#123;cases&#125;</div><div class="line">a_1x+b_1y=c_1 \\</div><div class="line">a_2x+b_2y=c_2 \\</div><div class="line">\end&#123;cases&#125;$$</div></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">
\begin{cases}
a_1x+b_1y=c_1 \\
a_2x+b_2y=c_2 \\
\end{cases}</script><h3 id="连等式"><a href="#连等式" class="headerlink" title="连等式"></a>连等式</h3><ul>
<li>注意把我们期望对齐的符号前加<code>&amp;</code>即可。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$$\begin&#123;align&#125;</div><div class="line">C &amp;= a \\</div><div class="line">  &amp;= b</div><div class="line">\end&#123;align&#125;$$</div></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{align}
C &= a \\
  &= b
\end{align}</script>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title>to_do_list</title>
    <url>/2035/01/01/to-do-list/</url>
    <content><![CDATA[<p>记录一些想学的东西，如果有空或者大家感兴趣可能会写成文章吧</p>
<ul>
<li><p>[ ] python</p>
</li>
<li><p>[ ] 复习一下算法（都忘得差不多了）</p>
</li>
<li><p>[x] 日本近代史</p>
</li>
<li><p>[ ] 中世纪的继承法、法理和宣称</p>
</li>
<li><p>[ ] 国际共运史</p>
</li>
</ul>
<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>python学习/踩坑记录</title>
    <url>/2022/09/21/python-learning/</url>
    <content><![CDATA[<h2 id="引用-amp-拷贝1"><a href="#引用-amp-拷贝1" class="headerlink" title="引用 &amp; 拷贝1"></a>引用 &amp; 拷贝<sup><a href="#fn_1" id="reffn_1">1</a></sup></h2><a id="more"></a>
<h3 id="可变对象-amp-不可变对象"><a href="#可变对象-amp-不可变对象" class="headerlink" title="可变对象 &amp; 不可变对象"></a>可变对象 &amp; 不可变对象</h3><ul>
<li><p>在Python中，对象分为两种：可变对象和不可变对象。</p>
</li>
<li><p>不可变对象包括int，float，long，str，tuple等，可变对象包括list，set，dict等。</p>
</li>
<li><p>不可变对象修改时，事实上创建了新的变量，如：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line">a = <span class="number">1</span></div><div class="line">print(id(a))</div><div class="line">a += <span class="number">1</span></div><div class="line">print(id(a))</div><div class="line">output:</div><div class="line"><span class="number">2259924156656</span></div><div class="line"><span class="number">2259924156688</span></div></pre></td></tr></table></figure>
<p>因此，在函数传参时，若传入可变对象，修改之后指向的是新的变量，不影响原变量，而传入不可变对象，修改将涉及原变量。（我戏称为“可变不可变，不可变可变”）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def func(dat):</div><div class="line">    dat += 1</div><div class="line">a = 1</div><div class="line">func(a)</div><div class="line">print(a)</div><div class="line">output : 1</div><div class="line"></div><div class="line">def func(dat):</div><div class="line">    dat += [1]</div><div class="line">a = [1, 2, 3]</div><div class="line">func(a)</div><div class="line">print(a)</div><div class="line">output : [1, 2, 3, 1]</div></pre></td></tr></table></figure>
<h3 id="深复制-amp-浅复制"><a href="#深复制-amp-浅复制" class="headerlink" title="深复制 &amp; 浅复制"></a>深复制 &amp; 浅复制</h3><p>一般<code>=</code>代表引用，（浅）复制列表<code>value</code>的语法是`value[:]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a = [0, [1, 2], 3]</div><div class="line">b = a[:]</div><div class="line">a[0] = 8</div><div class="line">a[1][1] = 9</div></pre></td></tr></table></figure>
<p>问：此时 a 和 b 分别是多少？</p>
<p>正确答案是 a 为 [8, [1, 9], 3]，b 为 [0, [1, 9], 3]。发现没？b 的第二个元素也被改变了。想想是为什么？不明白的话看下图</p>
<p><img src="https://draapho.github.io/images/1618/python_point_5.jpg" alt="python_point"></p>
<p>真正的深复制（完全创造一份新的副本）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import copy</div><div class="line">a = [0, [1, 2], 3]</div><div class="line">b = copy.deepcopy(a)</div></pre></td></tr></table></figure>
<p><sup><a href="#fn_1" id="reffn_1">1</a></sup>:1 部分引自<a href="https://draapho.github.io/2016/11/21/1618-python-variable/" target="_blank" rel="external">python基础： 深入理解 python 中的赋值、引用、拷贝、作用域</a></p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p><strong>默认参数必须指向不变对象, 指向可变变量时，每次改变都会保存！</strong></p>
<p>若</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def func(l = [])</div><div class="line">	l.append(1)</div><div class="line">	return l</div><div class="line"></div><div class="line">&gt;&gt;&gt;func()</div><div class="line">[1]</div><div class="line">&gt;&gt;&gt;func()</div><div class="line">[1, 1]</div><div class="line"></div><div class="line">修改</div><div class="line"></div><div class="line">def func(l = None)</div><div class="line">	if l == None:</div><div class="line">		l = []</div><div class="line">	l.append(1)</div><div class="line">	return l</div></pre></td></tr></table></figure>
<h3 id="使用全局变量前用global-声明"><a href="#使用全局变量前用global-声明" class="headerlink" title="使用全局变量前用global 声明"></a>使用全局变量前用global 声明</h3>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP 2019 游记</title>
    <url>/2019/11/17/csp_2019/</url>
    <content><![CDATA[<h1 id="NOIP-CSP-2019-游记"><a href="#NOIP-CSP-2019-游记" class="headerlink" title="NOIP CSP 2019 游记"></a><del>NOIP</del> CSP 2019 游记</h1><a id="more"></a>
<h3 id="Day-n-to-Day-1"><a href="#Day-n-to-Day-1" class="headerlink" title="Day -n to Day -1"></a>Day -n to Day -1</h3><p>停课，每天一场模拟赛，发现我还是太菜了，日常被全机房吊打。</p>
<h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>今天考了一场所谓信心赛<del>（自闭赛）</del>，然后是喜闻乐见的CS1.6环节。<del>（传统艺能）</del></p>
<p><del>晚上机房毒奶 <a href="https://www.luogu.org/user/130970" target="_blank" rel="external">LLouver</a> 奶了一口今年考DP，看来不用复习DP了（逃</del> （然而还是考了DP，被爆踩了）</p>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>T1一眼切了，就注意一下<code>unsigned long long</code>最大为 $2^{64} - 1$，读入之后如果<code>k++</code>会炸。</p>
<p>T2脑子抽了，直接写的 $n ^  2$ 暴力，还是太菜了。</p>
<p>T3考虑菊花图，做了1个多小时之后发现讨论的情况太多了，自闭。</p>
<p>期望得分:100 + 50 + 0 = 150pts</p>
<p>luogu数据:100 + 90 + 0 = 190pts</p>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>开考先看了一遍题，发现没一道题可做，T2，T3暴力比较好打，先开T2，T3。</p>
<p>T2设<code>dp[i][j]</code>为上一次划分点在 $j$，这次在 $i$，暴力转移即可。</p>
<p>T3考虑链的情况，长为奇数时，可以得到 $ans$ 为所有编号之和加开头，结尾，中间点的编号。<br>然后考虑 $n^2$ 暴力删边，获得40pts的好成绩QAQ</p>
<p>然后我猜完美二叉树的情况应该比较可做，<del>（然后找了一个小时的规律，并不会）</del></p>
<p>最后开T1的时候只有20$min$了，不想写暴力，特判<code>n = 2</code>的情况滚粗。</p>
<p>期望得分:8 + 36 + 55 = 99pts</p>
<p>luogu数据:8 + 48 + 55 = 111pts</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>首先吐槽一下你谷数据忒水了点吧，<del>(居然上300pts了QAQ)</del>，然后喷一下神奇的题目顺序和难度曲线，<del>CCF:非专业级比专业级更简单</del></p>
<p>然后好像每道题打的都是暴力。</p>
<p>果然菜是原罪，退役了，再见。</p>
]]></content>
  </entry>
  <entry>
    <title>各种模版</title>
    <url>/2019/08/15/std/</url>
    <content><![CDATA[<p><a href="https://www.luogu.org/blog/wjr5082/ge-lei-mu-ban-hui-zong" target="_blank" rel="external">原文地址</a><br>搬给自己看</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#include &lt;ctime&gt;</div><div class="line">#include &lt;cmath&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;deque&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;bitset&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;tr1/unordered_map&gt;</div><div class="line">using namespace std;</div><div class="line">#define ri register int</div><div class="line">#define ull unsigned long long</div><div class="line">#define uint unsigned int</div><div class="line">#define bs bitset&lt;N&gt;</div><div class="line">typedef long long LL;</div><div class="line">namespace wjr&#123;</div><div class="line">    const int mod=998244353,inv2=499122177,inf=1&lt;&lt;30;</div><div class="line">    inline int mul(ri a,ri b)&#123;return a*1ll*b%mod;&#125;</div><div class="line">    inline int add(ri a,ri b)&#123;return a+=b,a&gt;=mod?a-mod:a;&#125;</div><div class="line">    inline int del(ri a,ri b)&#123;return a-=b,a&lt;0?a+mod:a;&#125;</div><div class="line">    inline int qpow(ri a,ri b)&#123;ri s=1;for(;b;b&gt;&gt;=1,a=mul(a,a))if(b&amp;1)s=mul(s,a);return s;&#125;</div><div class="line">    template&lt;typename T&gt;</div><div class="line">    inline T sqr(register T x)&#123;return x*x;&#125;</div><div class="line">&#125;using namespace wjr;</div><div class="line"></div><div class="line">//*  ---  目录  ---  *//</div><div class="line"></div><div class="line">/*--- 36-520 数学、快速变换等 ---*/</div><div class="line">/*--- 522-585反演、杜教筛、Min_25筛 ---*/</div><div class="line">/*--- 587-839 字符串 ---*/</div><div class="line">/*--- 841-1140 图论 ---*/</div><div class="line">/*--- 1142-1376 网络流 ---*/</div><div class="line">/*--- - 随机化*/ </div><div class="line">/*--- 1378-1782 数据结构 ---*/ </div><div class="line">/*--- 1784-1813 BM算法*/</div><div class="line">/*---  -  计算几何*/ </div><div class="line"></div><div class="line">/*---快速沃尔什变换*/</div><div class="line">namespace FWT&#123;</div><div class="line">    inline void FWT_and(ri*a,ri n,ri p)&#123;</div><div class="line">        ri step,s,i,j;</div><div class="line">        for(step=1,s=2;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1)</div><div class="line">            for(i=0;i&lt;n;i+=s)</div><div class="line">                for(j=i;j&lt;i+step;++j)</div><div class="line">                    a[j]=~p?add(a[j],a[j+step]):del(a[j],a[j+step]);</div><div class="line">    &#125;inline void FWT_or(ri*a,ri n,ri p)&#123;</div><div class="line">        ri step,s,i,j;</div><div class="line">        for(step=1,s=2;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1)</div><div class="line">            for(i=0;i&lt;n;i+=s)</div><div class="line">                for(j=i;j&lt;i+step;++j)</div><div class="line">                    a[j+step]=~p?add(a[j+step],a[j]):del(a[j+step],a[j]);</div><div class="line">    &#125;inline void FWT_xor(ri*a,ri n,ri p)&#123;</div><div class="line">        ri step,s,i,j,x;</div><div class="line">        for(step=1,s=2;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1)</div><div class="line">            for(i=0;i&lt;n;i+=s)</div><div class="line">                for(j=i;j&lt;i+step;++j)&#123;</div><div class="line">                    x=a[j];</div><div class="line">                    a[j]=add(a[j],a[j+step]);</div><div class="line">                    a[j+step]=del(x,a[j+step]);</div><div class="line">                    if(~p)continue;</div><div class="line">                    a[j]=mul(a[j],inv2);</div><div class="line">                    a[j+step]=mul(a[j+step],inv2);</div><div class="line">                &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---快速子集变换*/</div><div class="line">namespace FST&#123;</div><div class="line">    const int N=1&lt;&lt;15;</div><div class="line">    inline void work(ri a[][N],ri b[][N],ri c[][N],ri n)&#123;/*---c[x][|x|]即为原来要求的dp[x]*/</div><div class="line">        ri lim=1&lt;&lt;n;</div><div class="line">        for(ri i=1;i&lt;=n;++i)FWT::FWT_or(a[i],lim,1),FWT::FWT_or(b[i],lim,1);</div><div class="line">        for(ri i=1;i&lt;=n;++i)</div><div class="line">            for(ri j=1;j&lt;=i;++j)</div><div class="line">                for(ri k=0;k&lt;=lim;++k)</div><div class="line">                    c[i][k]=add(c[i][k],mul(a[i-j][k],b[j][k]));</div><div class="line">        for(ri i=1;i&lt;=n;++i)FWT::FWT_or(c[i],lim,-1);</div><div class="line">    &#125;inline void work(ri a[][N],ri b[][N],ri n)&#123;</div><div class="line">        ri lim=1&lt;&lt;n;</div><div class="line">        for(ri i=1;i&lt;=n;++i)FWT::FWT_or(b[i],lim,1);</div><div class="line">        a[0][0]=1,FWT::FWT_or(a[0],lim,1);</div><div class="line">        for(ri i=1;i&lt;=n;++i)</div><div class="line">            for(ri j=1;j&lt;=i;++j)</div><div class="line">                for(ri k=0;k&lt;=lim;++k)</div><div class="line">                    a[i][k]=add(a[i][k],mul(a[i-j][k],b[j][k]));</div><div class="line">        for(ri i=1;i&lt;=n;++i)FWT::FWT_or(a[i],lim,-1);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---多项式 - NTT */</div><div class="line">namespace Poly_NTT&#123;</div><div class="line">    const int N=1&lt;&lt;15;</div><div class="line">    int g[25],gi[25],rev[N],INV[N|1];</div><div class="line">    inline void init(ri n)&#123;/*---初始化*/</div><div class="line">        ri bit=1;</div><div class="line">        while((1&lt;&lt;bit)&lt;(n&lt;&lt;1))++bit;</div><div class="line">        ri I=qpow(3,mod-2);</div><div class="line">        for(ri i=1;i&lt;=bit;++i)g[i]=qpow(3,(mod-1)&gt;&gt;i),gi[i]=qpow(I,(mod-1)&gt;&gt;i);</div><div class="line">        INV[0]=INV[1]=1;for(ri i=2;i&lt;=(1&lt;&lt;bit);++i)INV[i]=mul(INV[mod%i],mod-mod/i);</div><div class="line">    &#125;inline void NTT(ri*a,ri n,ri p)&#123;</div><div class="line">        ri i,j,step,s,enk,wn,x,now;</div><div class="line">        for(i=0;i&lt;n;++i)if(i&lt;rev[i])swap(a[i],a[rev[i]]);</div><div class="line">        for(step=1,s=2,now=1;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1,++now)&#123;</div><div class="line">            wn=~p?g[now]:gi[now];</div><div class="line">            for(i=0;i&lt;n;i+=s)&#123;</div><div class="line">                enk=1;</div><div class="line">                for(j=i;j&lt;i+step;++j)&#123;</div><div class="line">                    x=mul(enk,a[j+step]);</div><div class="line">                    a[j+step]=del(a[j],x);</div><div class="line">                    a[j]=add(a[j],x);</div><div class="line">                    enk=mul(enk,wn);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;if(~p)return;</div><div class="line">        for(i=0;i&lt;n;++i)a[i]=mul(a[i],INV[n]);</div><div class="line">    &#125;inline void get_rev(ri s)&#123;ri Maxn=1&lt;&lt;s;for(ri i=0;i&lt;Maxn;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(s-1));&#125;</div><div class="line">    inline void Mul(ri*a,ri n,ri*b,ri m)&#123;/*---多项式乘法*/</div><div class="line">        static int A[N],B[N];</div><div class="line">        ri i,bit,s,len;len=n+m-1;</div><div class="line">        bit=1,s=2;</div><div class="line">        while(s&lt;len)++bit,s&lt;&lt;=1;</div><div class="line">        get_rev(bit);</div><div class="line">        memcpy(A,a,n&lt;&lt;2),memset(A+n,0,(s-n)&lt;&lt;2);</div><div class="line">        memcpy(B,b,m&lt;&lt;2),memset(B+m,0,(s-m)&lt;&lt;2);</div><div class="line">        NTT(A,s,1),NTT(B,s,1);</div><div class="line">        for(i=0;i&lt;s;++i)A[i]=mul(A[i],B[i]);</div><div class="line">        NTT(A,s,-1);memcpy(a,A,len&lt;&lt;2);</div><div class="line">    &#125;inline void Inv(ri*a,ri n)&#123;/*---多项式逆元*/ </div><div class="line">        static int A[N],B[N],s,i,j,k,now;</div><div class="line">        s=2;while(s&lt;n)s&lt;&lt;=1;</div><div class="line">        memset(a+n,0,(s-n)&lt;&lt;2);</div><div class="line">        memset(B,0,s&lt;&lt;3);</div><div class="line">        B[0]=a[0]&lt;=N?INV[a[0]]:qpow(a[0],mod-2);</div><div class="line">        for(i=2,j=4,now=2;i&lt;=s;i&lt;&lt;=1,j&lt;&lt;=1,++now)&#123;</div><div class="line">            memcpy(A,a,i&lt;&lt;2),memset(A+i,0,i&lt;&lt;2);</div><div class="line">            get_rev(now);</div><div class="line">            NTT(A,j,1),NTT(B,j,1);</div><div class="line">            for(k=0;k&lt;j;++k)B[k]=mul(B[k],del(2,mul(A[k],B[k])));</div><div class="line">            NTT(B,j,-1),memset(B+i,0,i&lt;&lt;2);</div><div class="line">        &#125;memcpy(a,B,n&lt;&lt;2);</div><div class="line">    &#125;inline void deriv(ri*a,ri n)&#123;/*---求导函数*/</div><div class="line">        for(ri i=0;i&lt;n;++i)a[i]=mul(a[i+1],i+1);a[n-1]=0;</div><div class="line">    &#125;inline void intag(ri*a,ri n)&#123;/*---求原函数*/</div><div class="line">        for(ri i=n-1;i;--i)a[i]=mul(a[i-1],INV[i]);a[0]=0;</div><div class="line">    &#125;inline void Ln(ri*a,ri n)&#123;/*---对数函数*/</div><div class="line">        static int A[N];</div><div class="line">        memcpy(A,a,n&lt;&lt;2),Inv(A,n);</div><div class="line">        deriv(a,n),</div><div class="line">        Mul(a,n,A,n);</div><div class="line">        intag(a,n),memset(a+n,0,(n-1)&lt;&lt;2);</div><div class="line">    &#125;inline void Exp(ri*a,ri n)&#123;/*---指数函数*/ </div><div class="line">        static int A[N],B[N],i,j,k,now,s;</div><div class="line">        s=2;while(s&lt;n)s&lt;&lt;=1;</div><div class="line">        memset(a+n,0,(s-n)&lt;&lt;2);</div><div class="line">        memset(B,0,s&lt;&lt;3);</div><div class="line">        B[0]=1;</div><div class="line">        for(i=2,j=4,now=2;i&lt;=s;i&lt;&lt;=1,j&lt;&lt;=1,++now)&#123;</div><div class="line">            memcpy(A,B,i&lt;&lt;2),memset(A+i,0,i&lt;&lt;2);</div><div class="line">            Ln(A,i);for(k=0;k&lt;i;++k)A[k]=del(a[k],A[k]);</div><div class="line">            A[0]=add(A[0],1),get_rev(now);</div><div class="line">            NTT(A,j,1),NTT(B,j,1);</div><div class="line">            for(k=0;k&lt;j;++k)B[k]=mul(B[k],A[k]);</div><div class="line">            NTT(B,j,-1),memset(B+i,0,i&lt;&lt;2);</div><div class="line">        &#125;memcpy(a,B,n&lt;&lt;2);</div><div class="line">    &#125;inline void Ksm(ri*a,ri n,ri k)&#123;/*---快速幂*/ </div><div class="line">        ri t,p,inv;</div><div class="line">        t=0;while(!a[t]&amp;&amp;t&lt;n)++t;</div><div class="line">        if(t&gt;=n)return;</div><div class="line">        p=a[t],inv=p&lt;=N?INV[p]:qpow(p,mod-2);</div><div class="line">        for(ri i=0;i&lt;n-t;++i)a[i]=mul(a[i+t],inv);</div><div class="line">        memset(a+n-t,0,t&lt;&lt;2);</div><div class="line">        Ln(a,n);</div><div class="line">        for(ri i=0;i&lt;n;++i)a[i]=mul(a[i],k);</div><div class="line">        a[0]=0,Exp(a,n);</div><div class="line">        for(ri i=n-1;i&gt;=t;--i)</div><div class="line">            a[i]=mul(p,a[i-t]);</div><div class="line">        memset(a,0,t&lt;&lt;2);</div><div class="line">    &#125;inline void Div(ri*a,ri n,ri*b,ri m)&#123;/*---多项式除法+取模*/ </div><div class="line">        static int F[N],G[N];</div><div class="line">        memcpy(F,a,(n+1)&lt;&lt;2),memcpy(G,b,(m+1)&lt;&lt;2);</div><div class="line">        reverse(b,b+1+m),reverse(F,F+1+n);</div><div class="line">        for(ri i=n-m+1;i&lt;=m;++i)b[i]=0;</div><div class="line">        Inv(b,n-m+1);</div><div class="line">        for(ri i=n-m+1;i&lt;=n;++i)F[i]=0;</div><div class="line">        Mul(F,n-m+1,b,n-m+1);</div><div class="line">        reverse(F,F+n-m+1);</div><div class="line">        for(ri i=n-m+1;i&lt;=n;++i)F[i]=0;</div><div class="line">        Mul(G,m+1,F,n-m+1);</div><div class="line">        for(ri i=0;i&lt;m;++i)b[i]=del(a[i],G[i]);</div><div class="line">        memcpy(a,F,n&lt;&lt;2);</div><div class="line">    &#125;inline void Sqrt(ri*a,ri n)&#123;//多项式开根 </div><div class="line">        static int A[N],B[N];</div><div class="line">        ri s,i,j,k,now;</div><div class="line">        s=2;while(s&lt;n)s&lt;&lt;=1;</div><div class="line">        memset(a+n,0,(s-n)&lt;&lt;2),memset(B,0,s&lt;&lt;3);</div><div class="line">        B[0]=1;</div><div class="line">        for(i=2,j=4,now=2;i&lt;=s;i&lt;&lt;=1,j&lt;&lt;=1,++now)&#123;</div><div class="line">            memcpy(A,B,i&lt;&lt;2),memset(A+i,0,i&lt;&lt;2);</div><div class="line">            for(k=0;k&lt;i;++k)A[k]=mul(A[k],2);</div><div class="line">            Inv(A,i);</div><div class="line">            get_rev(now-1);</div><div class="line">            NTT(B,i,1);</div><div class="line">            for(k=0;k&lt;i;++k)B[k]=mul(B[k],B[k]);</div><div class="line">            NTT(B,i,-1);</div><div class="line">            for(k=0;k&lt;i;++k)B[k]=add(B[k],a[k]);</div><div class="line">            get_rev(now);</div><div class="line">            NTT(B,j,1),NTT(A,j,1);</div><div class="line">            for(k=0;k&lt;j;++k)B[k]=mul(B[k],A[k]);</div><div class="line">            NTT(B,j,-1),memset(B+i,0,i&lt;&lt;2);</div><div class="line">        &#125;memcpy(a,B,n&lt;&lt;2);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---多项式 - FFT*/</div><div class="line">namespace Ploy_FFT&#123;</div><div class="line">    const int N=1&lt;&lt;18,zw=(1&lt;&lt;15)-1;</div><div class="line">    const double PI=acos(-1);</div><div class="line">    int rev[N];</div><div class="line">    struct cd&#123;</div><div class="line">        double x,y;</div><div class="line">        cd(double a=0,double b=0)&#123;x=a,y=b;&#125;</div><div class="line">    &#125;w[18][N];</div><div class="line">    inline cd operator+(cd a,cd b)&#123;return cd(a.x+b.x,a.y+b.y);&#125;</div><div class="line">    inline cd operator-(cd a,cd b)&#123;return cd(a.x-b.x,a.y-b.y);&#125;</div><div class="line">    inline cd operator*(cd a,cd b)&#123;return cd(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;</div><div class="line">    inline cd operator*(cd a,ri b)&#123;return cd(a.x,a.y*b);&#125;</div><div class="line">    inline void init(ri n)&#123;</div><div class="line">        for(ri i=0,k=1,j;i&lt;=17;++i,k&lt;&lt;=1)</div><div class="line">            for(j=0;j&lt;k;++j)</div><div class="line">                w[i][j]=cd(cos(PI*j/k),sin(PI*j/k));</div><div class="line">    &#125;inline void get_rev(ri s)&#123;ri Maxn=1&lt;&lt;s;for(ri i=0;i&lt;Maxn;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(s-1));&#125;</div><div class="line">    inline void FFT(register cd*a,ri n,ri p)&#123;</div><div class="line">        ri step,s,i,j,now;</div><div class="line">        cd x;</div><div class="line">        for(i=0;i&lt;n;++i)if(i&lt;rev[i])swap(a[i],a[rev[i]]);</div><div class="line">        for(step=1,s=2,now=0;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1,++now)</div><div class="line">            for(i=0;i&lt;n;i+=s)</div><div class="line">                for(j=i;j&lt;i+step;++j)&#123;</div><div class="line">                    x=a[j+step]*(w[now][j-i]*p);</div><div class="line">                    a[j+step]=a[j]-x;</div><div class="line">                    a[j]=a[j]+x;</div><div class="line">                &#125;</div><div class="line">        if(~p)return;</div><div class="line">        for(i=0;i&lt;n;++i)a[i].x/=n;</div><div class="line">    &#125;inline LL get(cd x,ri Mod)&#123;return LL(x.x+0.5)%Mod;&#125;</div><div class="line">    int siz=sizeof(cd);</div><div class="line">    const int pw=32767;</div><div class="line">    inline void MTT(ri*a,ri*b,ri*c,ri n,ri m,ri Mod)&#123;</div><div class="line">        static cd A[N],B[N],C[N],D[N],e[N],f[N],g[N],h[N];</div><div class="line">        ri i,s,len;len=n+m-1;</div><div class="line">        s=2;while(s&lt;len)s&lt;&lt;=1;</div><div class="line">        for(i=0;i&lt;s;++i)&#123;</div><div class="line">            A[i]=cd(a[i]&gt;&gt;15,0),B[i]=cd(a[i]&amp;pw,0);</div><div class="line">            C[i]=cd(b[i]&gt;&gt;15,0),D[i]=cd(b[i]&amp;pw,0);</div><div class="line">        &#125;FFT(A,s,1),FFT(B,s,1),FFT(C,s,1),FFT(D,s,1);</div><div class="line">        for(i=0;i&lt;s;++i)e[i]=A[i]*C[i],f[i]=A[i]*D[i],g[i]=B[i]*C[i],h[i]=B[i]*D[i];</div><div class="line">        FFT(e,s,-1),FFT(f,s,-1),FFT(g,s,-1),FFT(h,s,-1);</div><div class="line">        for(i=0;i&lt;len;++i)</div><div class="line">            c[i]=(((get(e[i],Mod)&lt;&lt;30)%Mod+(get(f[i],Mod)&lt;&lt;15)%Mod)%Mod+(get(g[i],Mod)&lt;&lt;15)%Mod+get(h[i],Mod)%Mod)%Mod;</div><div class="line">    &#125;inline void MTT_2(ri*a,ri n,ri*b,ri m)&#123;//黑科技优化版本 </div><div class="line">        static cd A[N],B[N],C[N],D[N];</div><div class="line">        ri len=n+m-1,s=2,i,t;</div><div class="line">        register LL q,w,e,r;</div><div class="line">        while(s&lt;len)s&lt;&lt;=1;</div><div class="line">        for(i=0;i&lt;n;++i)A[i]=cd(a[i]&amp;zw,a[i]&gt;&gt;15);</div><div class="line">        for(i=n;i&lt;s;++i)A[i]=cd(0,0);</div><div class="line">        for(i=0;i&lt;m;++i)B[i]=cd(b[i]&amp;zw,b[i]&gt;&gt;15);</div><div class="line">        for(i=m;i&lt;s;++i)B[i]=cd(0,0);</div><div class="line">        FFT(A,s,1),FFT(B,s,1);</div><div class="line">        for(i=0;i&lt;s;++i)&#123;</div><div class="line">            t=(s-i)&amp;(s-1);</div><div class="line">            C[i]=cd(0.5*(A[i].x+A[t].x),0.5*(A[i].y-A[t].y))*B[i];</div><div class="line">            D[i]=cd(0.5*(A[i].y+A[t].y),0.5*(A[t].x-A[i].x))*B[i];</div><div class="line">        &#125;FFT(C,s,-1),FFT(D,s,-1);</div><div class="line">        for(i=0;i&lt;len;++i)&#123;</div><div class="line">            q=LL(C[i].x+0.5)%mod,w=LL(C[i].y+0.5)%mod,e=LL(D[i].x+0.5)%mod,r=LL(D[i].y+0.5)%mod;</div><div class="line">            a[i]=(q+((w+e)&lt;&lt;15)+(r&lt;&lt;30))%mod;</div><div class="line">//          a[i]=(q+((w+e)&lt;&lt;15)+(r&lt;&lt;30))%mod+mod;</div><div class="line">//          a[i]=a[i]&gt;=mod?a[i]-mod:a[i];</div><div class="line">            //此题没卡,一般是要写%mod+mod,然后再取模的。 </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---斯特林数*/</div><div class="line">namespace Stirling&#123;</div><div class="line">    //暂时不想写 </div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---BSGS*/</div><div class="line">namespace BSGS&#123;</div><div class="line">    const int Hash=19260817,N=1e4+10;</div><div class="line">    int d[Hash],nxt[N],to[N],id[N],tot;</div><div class="line">    int stk[N],tail;</div><div class="line">    inline int get(ri x)&#123;return (x*1ll*x)%Hash;&#125;</div><div class="line">    inline void Insert(ri x,ri i)&#123;</div><div class="line">        ri now=get(x);</div><div class="line">        if(!d[now])stk[++tail]=d[now];</div><div class="line">        to[++tot]=x,nxt[tot]=d[now],d[now]=tot,id[tot]=i;</div><div class="line">    &#125;inline int query(ri x)&#123;</div><div class="line">        ri now=get(x);</div><div class="line">        for(ri i=d[now];i;i=nxt[i])</div><div class="line">            if(to[i]==x)return id[i];</div><div class="line">        return -1;</div><div class="line">    &#125;inline void init()&#123;while(tail)d[stk[tail--]]=0;tot=0;&#125;</div><div class="line">    inline int qpow(ri a,ri b,ri p)&#123;ri s=1;for(;b;b&gt;&gt;=1,a=a*1ll*a%p)if(b&amp;1)s=s*1ll*a%p;return s;&#125;</div><div class="line">    inline int BSGS(ri a,ri b,ri p)&#123;//求a^t ≡b (mod p)</div><div class="line">        if(b==1)return 0;</div><div class="line">        ri tmp=ceil(sqrt(p));</div><div class="line">        ri t=qpow(a,tmp,p),x=1;</div><div class="line">        for(ri i=1;i&lt;=tmp;++i)&#123;</div><div class="line">            x=x*1ll*t%p;</div><div class="line">            Insert(x,i);</div><div class="line">        &#125;x=1;</div><div class="line">        for(ri i=0;i&lt;tmp;++i)&#123;</div><div class="line">            t=query(x);</div><div class="line">            if(~t)return t*tmp-i;</div><div class="line">            x=x*1ll*a%p;</div><div class="line">        &#125;return -1;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---Matrix_Tree矩阵树*/</div><div class="line">namespace Matrix_tree&#123;//用于求解生成树个数 </div><div class="line">    const int N=205;</div><div class="line">    int a[N][N];</div><div class="line">    inline void ins(ri u,ri v)&#123;++a[u][u],++a[v][v],--a[u][v],--a[v][u];&#125;</div><div class="line">    inline int Gauss(ri n)&#123;//如果是m*m矩阵,n=m-1,即忽略最后一行 </div><div class="line">        ri ans=1,i,j,k,div,tmp;</div><div class="line">        for(i=1;i&lt;=n;++i)&#123;</div><div class="line">            k=i;</div><div class="line">            for(j=i;j&lt;=n;++j)</div><div class="line">                if(a[j][i])&#123;k=j;break;&#125;</div><div class="line">            if(k!=i)ans=-ans,swap(a[i],a[k]);</div><div class="line">            if(!a[i][i])return 0;</div><div class="line">            ans=mul(ans,a[i][i]);</div><div class="line">            div=qpow(a[i][i],mod-2);</div><div class="line">            for(j=i+1;j&lt;=n;++j)&#123;</div><div class="line">                if(!a[j][i])continue;</div><div class="line">                tmp=mul(div,a[j][i]);</div><div class="line">                for(k=i;k&lt;=n;++k)</div><div class="line">                    a[j][k]=del(a[j][k],mul(tmp,a[i][k]));</div><div class="line">            &#125;</div><div class="line">        &#125;return ans&lt;0?ans+mod:ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---中国剩余定理*/ </div><div class="line">namespace EXCRT&#123;</div><div class="line">    const int N=1e4+10;</div><div class="line">    const double eps=1e-2;</div><div class="line">    typedef long long LL;</div><div class="line">    struct node&#123;</div><div class="line">        LL a[N],b[N];</div><div class="line">        LL ans,M;</div><div class="line">    &#125;;</div><div class="line">    LL x,y;</div><div class="line">    inline LL exgcd(LL a,LL b,LL&amp;x,LL&amp;y)&#123;</div><div class="line">        if(!b)&#123;x=1,y=0;return a;&#125;</div><div class="line">        LL g=exgcd(b,a%b,y,x);</div><div class="line">        y-=(a/b)*x;</div><div class="line">        return g;</div><div class="line">    &#125;inline LL Mul(LL a,LL b,LL p)&#123;</div><div class="line">        LL d=((long double)a/p*b+eps);</div><div class="line">        LL r=a*b-p*d;</div><div class="line">        return r&lt;0?r+p:r;</div><div class="line">    &#125;inline LL Del(LL a,LL b,LL p)&#123;return a-=b,a&lt;0?a+p:a;&#125;</div><div class="line">    inline void Excrt(node&amp;a,ri n)&#123;</div><div class="line">        a.ans=a.a[1],a.M=a.b[1];</div><div class="line">        LL c,g,p;</div><div class="line">        for(ri i=2;i&lt;=n;++i)&#123;//a.ans+x*a.M≡a.a[i](mod a.b[i]) </div><div class="line">            c=Del(a.a[i],a.ans,a.b[i]);//x*a.M≡a.a[i]-a.ans(mod a.b[i])</div><div class="line">            g=exgcd(a.M,a.b[i],x,y);</div><div class="line">            p=a.b[i]/g;</div><div class="line">            if(c%g!=0)&#123;a.ans=-1;return;&#125;</div><div class="line">            x=Mul(x,c/g,p);</div><div class="line">            a.ans+=x*a.M;</div><div class="line">            a.M*=p;</div><div class="line">            a.ans=(a.ans%a.M+a.M)%a.M;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---高斯消元*/ </div><div class="line">namespace Gauss&#123;</div><div class="line">    const int M=205;</div><div class="line">    struct Matrix&#123;</div><div class="line">        int a[M][M];</div><div class="line">        int ans[M];//为了方便起见才将ans放里面 </div><div class="line">    &#125;;</div><div class="line">    inline void Gauss(Matrix&amp;a,ri n)&#123;//n行、n+1列 </div><div class="line">        ri i,j,k,t;</div><div class="line">        for(i=1;i&lt;=n;++i)&#123;</div><div class="line">            k=i;</div><div class="line">            for(j=i;j&lt;=n;++j)</div><div class="line">                if(a.a[j][i])&#123;k=j;break;&#125;</div><div class="line">            if(i!=k)swap(a.a[k],a.a[i]);</div><div class="line">            t=qpow(a.a[i][i],mod-2);</div><div class="line">            for(k=i;k&lt;=n+1;++k)a.a[i][k]=mul(a.a[i][k],t);</div><div class="line">            for(j=i+1;j&lt;=n;++j)&#123;</div><div class="line">                t=a.a[j][i];</div><div class="line">                for(k=i;k&lt;=n+1;++k)</div><div class="line">                    a.a[j][k]=del(a.a[j][k],mul(t,a.a[i][k]));</div><div class="line">            &#125;</div><div class="line">        &#125;a.ans[i]=a.a[n][n+1];</div><div class="line">        for(i=n-1;i;--i)&#123;</div><div class="line">            a.ans[i]=a.a[i][n+1];</div><div class="line">            for(j=i+1;j&lt;=n;++j)</div><div class="line">                a.ans[i]=del(a.ans[i],mul(a.a[i][j],a.ans[j]));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---矩阵*/ </div><div class="line">namespace Matrix&#123;</div><div class="line">    const int N=205;</div><div class="line">    int n;//假定行列都是n </div><div class="line">    struct Matrix&#123;</div><div class="line">        int a[N][N];</div><div class="line">    &#125;;</div><div class="line">    inline void init(Matrix&amp;a)&#123;/*---单位矩阵*/</div><div class="line">        for(ri i=0;i&lt;n;++i)</div><div class="line">            memset(a.a[i],0,n&lt;&lt;2),a.a[i][i]=1;</div><div class="line">    &#125;inline void operator*=(Matrix&amp;a,Matrix b)&#123;</div><div class="line">        static Matrix c;</div><div class="line">        memset(&amp;c,0,sizeof(c));</div><div class="line">        ri i,j,k;</div><div class="line">        for(i=0;i&lt;n;++i)</div><div class="line">            for(k=0;k&lt;n;++k)</div><div class="line">                if(a.a[i][k])</div><div class="line">                    for(j=0;j&lt;n;++j)</div><div class="line">                        c.a[i][j]=add(c.a[i][j],mul(a.a[i][k],b.a[k][j]));</div><div class="line">        memcpy(&amp;a,&amp;c,sizeof(a));</div><div class="line">    &#125;inline Matrix operator*(Matrix a,Matrix b)&#123;</div><div class="line">        static Matrix c;</div><div class="line">        memset(&amp;c,0,sizeof(c));</div><div class="line">        ri i,j,k;</div><div class="line">        for(i=0;i&lt;n;++i)</div><div class="line">            for(k=0;k&lt;n;++k)</div><div class="line">                if(a.a[i][k])</div><div class="line">                    for(j=0;j&lt;n;++j)</div><div class="line">                        c.a[i][j]=add(c.a[i][j],mul(a.a[i][k],b.a[k][j]));</div><div class="line">        return c;</div><div class="line">    &#125;using namespace Poly_NTT;//需要用到多项式</div><div class="line">    inline void my_Div(ri*a,ri n,ri*b,ri m)&#123;//配合常系数线性齐次递推 </div><div class="line">        static int F[N],G[N];</div><div class="line">        memcpy(F,a,(n+1)&lt;&lt;2),memcpy(G,b,(m+1)&lt;&lt;2);</div><div class="line">        reverse(G,G+m+1),reverse(F,F+n+1);</div><div class="line">        for(ri i=n-m+1;i&lt;=m;++i)G[i]=0;</div><div class="line">        Inv(G,n-m+1);</div><div class="line">        for(ri i=n-m+1;i&lt;=n;++i)F[i]=0;</div><div class="line">        Mul(F,n-m+1,G,n-m+1);</div><div class="line">        reverse(F,F+n-m+1);</div><div class="line">        for(ri i=n-m+1;i&lt;=n;++i)F[i]=0;</div><div class="line">        memcpy(G,b,(m+1)&lt;&lt;2);</div><div class="line">        Mul(G,m+1,F,n-m+1);</div><div class="line">        for(ri i=0;i&lt;m;++i)a[i]=del(a[i],G[i]);</div><div class="line">        memset(a+m,0,(n-m+1)&lt;&lt;2);</div><div class="line">    &#125;inline void Multi(ri*a,ri*mod,ri*ans,ri n,ri k)&#123;/*---常系数线性齐次递推 */</div><div class="line">        memset(&amp;ans,0,sizeof(ans));</div><div class="line">        ans[0]=1;</div><div class="line">        while(k)&#123;</div><div class="line">            if(k&amp;1)&#123;</div><div class="line">                Mul(ans,n,a,n);</div><div class="line">                my_Div(ans,2*n-2,mod,n);</div><div class="line">            &#125;Mul(a,n,a,n);</div><div class="line">            my_Div(a,2*n-2,mod,n);</div><div class="line">            k&gt;&gt;=1;</div><div class="line">        &#125;</div><div class="line">    &#125;inline int Inv(Matrix a,Matrix&amp;b)&#123;/*---矩阵求逆*/ </div><div class="line">        //用b存inv(a)</div><div class="line">        init(b);</div><div class="line">        ri i,j,k,t;</div><div class="line">        for(i=0;i&lt;n;++i)&#123;</div><div class="line">            for(j=i;j&lt;n;++j)</div><div class="line">                if(a.a[j][i])&#123;</div><div class="line">                    swap(a.a[i],a.a[j]),swap(b.a[i],b.a[j]);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            if(!a.a[i][i])return -1;</div><div class="line">            t=qpow(a.a[i][i],mod-2);</div><div class="line">            for(j=i;j&lt;n;++j)a.a[i][j]=mul(a.a[i][j],t),b.a[i][j]=mul(b.a[i][j],t);</div><div class="line">            for(j=i+1;j&lt;n;++j)&#123;</div><div class="line">                t=a.a[j][i];</div><div class="line">                for(k=i;j&lt;n;++k)</div><div class="line">                    b.a[j][k]=del(b.a[j][k],mul(t,b.a[i][k])),a.a[j][k]=del(a.a[j][k],mul(t,a.a[i][k]));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---自适应性辛普森*/</div><div class="line">namespace Simpson&#123;</div><div class="line">    double a;</div><div class="line">    inline double f(double x)&#123;return pow(x,a/x-x);&#125;//返回函数值</div><div class="line">    inline double Simpson(double L,double R)&#123;return (R-L)*(f(R)+4*f((L+R)/2)+f(L))/6;&#125;</div><div class="line">    inline double ars(double L,double R,double A,double eps)&#123;</div><div class="line">        double mid=(L+R)/2;</div><div class="line">        double ls=Simpson(L,mid),rs=Simpson(mid,R);</div><div class="line">        if(fabs(ls+rs-A)&lt;15*eps)return ls+rs+(ls+rs-A)/15;</div><div class="line">        return ars(L,mid,ls,eps/2)+ars(mid,R,rs,eps/2);</div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line">/*---线性基*/</div><div class="line">namespace Linear_basis&#123;</div><div class="line">    const int N=1005;</div><div class="line">    bs a[66];</div><div class="line">    inline int Insert(bs x)&#123;</div><div class="line">        for(ri i=60;~i;--i)</div><div class="line">            if(x[i])&#123;</div><div class="line">                if(a[i]!=0)x^=a[i];</div><div class="line">                else &#123;a[i]=x;return 1;&#125;//秩++ </div><div class="line">            &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;inline bs query(bs x)&#123;//可以异或得到的最大 </div><div class="line">        for(ri i=60;~i;--i)</div><div class="line">            if(!x[i]&amp;&amp;a[i]!=0)</div><div class="line">                x^=a[i];</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---杜教筛*/ </div><div class="line">namespace DJS&#123;</div><div class="line">    //求S(n)=\sum_&#123;i=1&#125;^&#123;n&#125;f(i),h=f*g(*为卷积运算),则有g(1)S(n)=\sum_&#123;i=1&#125;^&#123;n&#125;h(i)-\sum_&#123;i=2&#125;^&#123;n&#125;g(i)S(n/i) </div><div class="line">    //这里以求\mu为例,\mu*1=元函数  </div><div class="line">    const int N=1e6+10;</div><div class="line">    using namespace std::tr1;</div><div class="line">    int sum[N];</div><div class="line">    unordered_map&lt;int,int&gt;q;//最好是手写hash </div><div class="line">    inline int S(ri n)&#123;</div><div class="line">        if(n&lt;N)return sum[n];</div><div class="line">        if(q[n])return q[n];</div><div class="line">        ri ans=1,i,j;</div><div class="line">        j=sqrt(n);</div><div class="line">        for(i=2;i&lt;=j;++i)</div><div class="line">            ans-=S(n/i);</div><div class="line">        for(;i&lt;=n;i=j+1)&#123;</div><div class="line">            j=n/(n/i);</div><div class="line">            ans-=(j-i+1)*S(n/i);</div><div class="line">        &#125;return q[n]=ans;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---莫比乌斯反演(只是一个整除分块没什么好写的)*/</div><div class="line"></div><div class="line">/*---Min_25筛*/</div><div class="line">namespace Min_25&#123;//这里以简单的函数LOJ 5063为例 </div><div class="line">    const int N=1e4+10;</div><div class="line">    int n,m,lim,cnt,prime[N],w[N],s[N],c[N];</div><div class="line">    bool no[N];</div><div class="line">    inline int id(ri x)&#123;return x&lt;=lim?x:m-(n/x)+1;&#125;</div><div class="line">    inline int f(ri x,ri c)&#123;return x^c;&#125;//返回f(x的c次方)(那题f(x^(次方)c)=x^(异或)c)</div><div class="line">    inline int g(ri x)&#123;return x;&#125;</div><div class="line">    inline int h(ri x)&#123;return 1;&#125;</div><div class="line">    inline int S(register LL n,ri k)&#123;//\sum_&#123;i=1&#125;^n f(i)*[i\in prime or min_i&gt;=prime[k]]</div><div class="line">        if(n&lt;=1||n&lt;prime[k])return 0;//递归版本 </div><div class="line">        ri i,c;register LL j;</div><div class="line">        ri ans=del(s[id(n)],s[prime[k-1]]);//先算出prime的贡献 </div><div class="line">        for(i=k;i&lt;=cnt&amp;&amp;prime[i]*1ll*prime[i]&lt;=n;++i)</div><div class="line">            for(j=n,c=1;(j/=prime[i])&gt;=prime[i];++c)</div><div class="line">                ans=add(ans,add(mul(f(prime[i],c),S(j,i+1)),f(prime[i],c+1)));</div><div class="line">            //不会统计到因子全是p_i的,所以直接加上 </div><div class="line">        return ans;</div><div class="line">    &#125;inline void pre(ri*F)&#123;//非递归版本 </div><div class="line">        //\sum f(prime_&#123;b&#125;^&#123;i&#125;)*(S(n/prime_&#123;b&#125;^&#123;i&#125;,b+1)-g(prime_&#123;b&#125;)+f(prime_&#123;b&#125;^&#123;i+1&#125;))</div><div class="line">        ri i,j,tmp;</div><div class="line">        for(i=cnt;i;--i)</div><div class="line">            for(j=m;w[j]&gt;=i*i;--j)</div><div class="line">                for(tmp=w[j];(tmp/=prime[i])&gt;=prime[i];)</div><div class="line">                    F[j]+=(f(prime[i],i)*(F[id(tmp)]-s[prime[i]])+f(prime[i],i+1));</div><div class="line">    &#125;inline void init(register LL n)&#123;m=cnt=0;</div><div class="line">        lim=sqrt(n);</div><div class="line">        for(register LL i=1,j;i&lt;=n;i=j+1)&#123;</div><div class="line">            w[++m]=j=n/(n/i);</div><div class="line">            s[m]=del(mul(j%mod,(j+1)%mod),1),c[m]=(j-1)%mod;//代表筛第0轮的初始值 </div><div class="line">        &#125;//g(n,i)筛了i轮后1-n中所有质数的f之和</div><div class="line">        for(ri i=2,j,t;i&lt;=lim;++i)&#123;</div><div class="line">            if(c[i]==c[i-1])continue;//如果不是质数,可以线性筛预处理也可以利用c数组</div><div class="line">            prime[++cnt]=i;</div><div class="line">            for(j=m;w[j]&gt;=i*i;--j)</div><div class="line">                s[j]=del(s[j],mul(g(i),del(s[t=id(w[j]/i)],s[i-1]))),//g(x)=x,1-n指数和 </div><div class="line">                c[j]=del(c[j],mul(h(i),del(c[t],c[i-1])));//g(x)=1,1-n质数个数 </div><div class="line">        &#125;for(ri i=2;i&lt;=m;++i)s[i]=del(s[i],del(c[i],2));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---AC自动机*/</div><div class="line">namespace ACM&#123;</div><div class="line">    const int N=1e4+10;</div><div class="line">    int ch[N][26],nxt[N];</div><div class="line">    queue&lt;int&gt;q;</div><div class="line">    int now,cnt;</div><div class="line">    inline void Insert(register char*s)&#123;</div><div class="line">        ri len=strlen(s+1),c;</div><div class="line">        now=1;</div><div class="line">        for(ri i=1;i&lt;=len;++i)&#123;</div><div class="line">            c=s[i]-&apos;a&apos;;</div><div class="line">            if(!ch[now][c])ch[now][c]=++cnt;</div><div class="line">            now=ch[now][c];</div><div class="line">        &#125;</div><div class="line">        /*</div><div class="line">        is_end[now]=1;</div><div class="line">        or </div><div class="line">        ++siz[now];</div><div class="line">        or else</div><div class="line">        */</div><div class="line">    &#125;inline void build()&#123;</div><div class="line">        ri i,u,x;</div><div class="line">        for(i=0;i&lt;26;++i)ch[0][i]=1;</div><div class="line">        nxt[1]=0,q.push(1);</div><div class="line">        while(!q.empty())&#123;</div><div class="line">            x=q.front();</div><div class="line">            q.pop();</div><div class="line">            for(i=0;i&lt;26;++i)&#123;</div><div class="line">                u=ch[x][i];</div><div class="line">                if(!u)ch[x][i]=ch[nxt[x]][i];</div><div class="line">                else&#123;</div><div class="line">                    q.push(u);</div><div class="line">                    nxt[u]=ch[nxt[x]][i];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---Hash of string字符串hash*/</div><div class="line">namespace hash_of_string&#123;</div><div class="line">    const int N=1e5+10,bas=237;//N,bas自定义</div><div class="line">    ull pw[N];</div><div class="line">    inline void init(ri n)&#123;pw[0]=1;for(ri i=1;i&lt;n;++i)pw[i]=pw[i-1]*bas;&#125;</div><div class="line">    inline void hash(register char*s,register ull*a,ri n)&#123;</div><div class="line">        for(ri i=1;i&lt;=n;++i)</div><div class="line">            a[i]=a[i-1]*bas+(s[i]-&apos;a&apos;);</div><div class="line">    &#125;inline ull get_hash(ri L,ri R,register ull*a)&#123;return a[R]-pw[R-L+1]*a[L-1];&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*--- Hash of num or else */</div><div class="line">namespace hash_of_else&#123;//以二维坐标为例 </div><div class="line">    const int Hash=19260817,N=1e4+10,bas=998244353;</div><div class="line">    struct node&#123;</div><div class="line">        int x,y;</div><div class="line">    &#125;;</div><div class="line">    int d[Hash],nxt[N],tot;</div><div class="line">    node to[N];</div><div class="line">    LL val[N];</div><div class="line">    inline int get_hash(node x)&#123;return (x.x*1ll*bas+x.y)%Hash;&#125;</div><div class="line">    inline bool operator==(node a,node b)&#123;return a.x==b.x&amp;&amp;a.y==b.y;&#125;</div><div class="line">    inline void Insert(node x,LL v)&#123;</div><div class="line">        ri now=get_hash(x);</div><div class="line">        to[++tot]=x,nxt[now]=d[now],d[now]=++tot,val[tot]=v;</div><div class="line">    &#125;inline LL find(node x)&#123;</div><div class="line">        ri now=get_hash(x);</div><div class="line">        for(ri i=d[now];i;i=nxt[i])</div><div class="line">            if(to[i]==x)return val[i];</div><div class="line">        return -1;//返回一个val不会出现的值 </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---KMP*/</div><div class="line">namespace KMP&#123;</div><div class="line">    const int N=1e4+10;</div><div class="line">    inline void get_nxt(register char*s,ri*nxt)&#123;</div><div class="line">        ri n=strlen(s+1);</div><div class="line">        for(ri i=2,j=0;i&lt;=n;++i)&#123;</div><div class="line">            while(j&amp;&amp;s[j+1]!=s[i])j=nxt[j];</div><div class="line">            j+=s[j+1]==s[i];</div><div class="line">            nxt[i]=j;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---马拉车算法,有了PAM还有学Manacher的必要吗(雾*/</div><div class="line">namespace Manacher&#123;</div><div class="line">    inline void Manacher(register char*s,ri*rad,ri n)&#123;</div><div class="line">        for(ri i=1,j=0,k;i&lt;n;i+=k)&#123;</div><div class="line">            while(s[i-j-1]==s[i+j+1])++j;</div><div class="line">            rad[i]=j;</div><div class="line">            for(k=1;k&lt;=rad[i]&amp;&amp;rad[i-k]!=rad[i]-k;++k)</div><div class="line">                rad[i+k]=min(rad[i-k],rad[i]-k);</div><div class="line">            j=max(j-k,0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---trie树(没啥好写的)*/</div><div class="line">namespace trie_tree&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---后缀平衡树*/</div><div class="line">namespace suffix_balance_tree&#123;</div><div class="line">    const double alpha=0.7;</div><div class="line">    const int N=1e4+10;</div><div class="line">    int ch[N][2],pos[N],a[N],siz[N],tail,rt;</div><div class="line">    char s[N];</div><div class="line">    int fail_pos,fail_fa;</div><div class="line">    double v[N],fail_ls,fail_rs;</div><div class="line">    #define lc ch[x][0]</div><div class="line">    #define rc ch[x][1]</div><div class="line">    inline bool cmp(ri x,ri y)&#123;return (s[x]!=s[y])?s[x]&lt;s[y]:v[pos[x]]&lt;v[pos[y]];&#125;//pos代表上一个插入位置 </div><div class="line">    inline int rebuild(ri L,ri R,register double ls,register double rs)&#123;</div><div class="line">        if(L&gt;R)return 0;</div><div class="line">        ri mid=(L+R)&gt;&gt;1,x=a[mid];</div><div class="line">        v[x]=(ls+rs)/2,siz[x]=R-L+1;</div><div class="line">        lc=rebuild(L,mid-1,ls,v[x]),rc=rebuild(mid+1,R,v[x],rs);</div><div class="line">        return x;</div><div class="line">    &#125;inline void ck(ri x,ri k,register double ls,register double rs)&#123;</div><div class="line">        if(siz[ch[x][k]]&gt;alpha*siz[x])fail_pos=x,fail_fa=-1,fail_ls=ls,fail_rs=rs;</div><div class="line">        else if(ch[x][k]==fail_pos)fail_fa=x;</div><div class="line">    &#125;inline void Insert(ri&amp;x,ri y,register double ls,register double rs)&#123;</div><div class="line">        if(!x)&#123;x=y;v[x]=(ls+rs)/2;return;&#125;</div><div class="line">        ++siz[x];</div><div class="line">        ri d=cmp(x,y);</div><div class="line">        if(d)Insert(rc,y,(ls+rs)/2,rs);</div><div class="line">        else Insert(lc,y,ls,(ls+rs)/2);</div><div class="line">        ck(x,d,ls,rs);</div><div class="line">    &#125;inline void recover(ri x)&#123;if(!x)return ;recover(lc),a[++tail]=x,recover(rc);&#125;</div><div class="line">    inline void Insert(ri x)&#123;</div><div class="line">        siz[x]=1,fail_pos=fail_fa=-1;</div><div class="line">        Insert(rt,x,0,1);</div><div class="line">        if(~fail_pos)&#123;</div><div class="line">            tail=0;</div><div class="line">            recover(fail_pos);</div><div class="line">            ri T=rebuild(1,tail,fail_ls,fail_rs);</div><div class="line">            if(~fail_fa)ch[fail_fa][ch[fail_fa][1]==fail_pos]=T;</div><div class="line">            else rt=T;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    #undef lc</div><div class="line">    #undef rc</div><div class="line">&#125; </div><div class="line"></div><div class="line">/*---SA后缀数组*/</div><div class="line">namespace SA&#123;</div><div class="line">    const int N=1e4+10;</div><div class="line">    int tax[N],sa[N],rk[N],tp[N];</div><div class="line">    int h[N],bit[N],s[30];</div><div class="line">    int n,m;</div><div class="line">    int Min[N][19];</div><div class="line">    inline void init(ri n)&#123;//预处理 </div><div class="line">        for(ri i=2;i&lt;=n;++i)bit[i]=bit[i&gt;&gt;1]+1;</div><div class="line">        s[0]=1;</div><div class="line">        for(ri i=1;i&lt;=bit[n];++i)s[i]=s[i-1]&lt;&lt;1;</div><div class="line">    &#125;inline void qsort()&#123;ri i;</div><div class="line">        memset(tax+1,0,m&lt;&lt;2);</div><div class="line">        for(i=1;i&lt;=n;++i)++tax[rk[i]];</div><div class="line">        for(i=1;i&lt;=m;++i)tax[i]+=tax[i-1];</div><div class="line">        for(i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i];</div><div class="line">    &#125;inline void suffix_sort(register char*s)&#123;ri i,j,p;</div><div class="line">        n=strlen(s+1),m=26;</div><div class="line">        for(i=1;i&lt;=n;++i)rk[i]=s[i]-&apos;a&apos;,tp[i]=i;</div><div class="line">        qsort();</div><div class="line">        for(i=1,p=0;p&lt;n;m=p,i&lt;&lt;=1)&#123;</div><div class="line">            p=0;</div><div class="line">            for(j=1;j&lt;=i;++j)tp[++p]=n-i+j;</div><div class="line">            for(j=1;j&lt;=n;++j)if(sa[j]&gt;i)tp[++p]=sa[j]-i;</div><div class="line">            qsort(),swap(tp,rk);</div><div class="line">            rk[sa[1]]=p=1;</div><div class="line">            for(j=2;j&lt;=n;++j)rk[sa[j]]=(tp[sa[j]]==tp[sa[j-1]]&amp;&amp;tp[sa[j]+i]==tp[sa[j-1]+i])?p:++p;</div><div class="line">        &#125;</div><div class="line">    &#125;inline void work(register char*s)&#123;</div><div class="line">        suffix_sort(s);</div><div class="line">        ri i,j,k=0;</div><div class="line">        for(i=1;i&lt;=n;++i)&#123;</div><div class="line">            if(k)--k;</div><div class="line">            j=sa[rk[i]-1];</div><div class="line">            while(s[i+k]==s[j+k])++k;</div><div class="line">            h[rk[i]]=k;</div><div class="line">        &#125;for(i=1;i&lt;=n;++i)Min[i][0]=h[i];</div><div class="line">        for(j=1;j&lt;=bit[n];++j)&#123;</div><div class="line">            ri p=s[j-1],q=s[j];</div><div class="line">            for(i=1;i&lt;=n-q+1;++i)</div><div class="line">                Min[i][j]=min(Min[i][j-1],Min[i+p][j-1]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---后缀自动机*/ </div><div class="line">namespace SAM&#123;</div><div class="line">    const int N=1e4+10;</div><div class="line">    int las,cnt,now,p,q,nq;</div><div class="line">    int len[N&lt;&lt;1],ch[N&lt;&lt;1][26],fa[N&lt;&lt;1];</div><div class="line">    inline void init()&#123;las=cnt=1;&#125;//初始化 </div><div class="line">    inline void Insert(ri c)&#123;/*---普通的SAM构造,广义的如果不涉及拓扑序可以每个串init后insert,否则要有特判*/</div><div class="line">        now=++cnt,p=las,len[now]=len[p]+1;</div><div class="line">        while(p&amp;&amp;!ch[p][c])ch[p][c]=now,p=fa[p];</div><div class="line">        if(!p)fa[now]=1;</div><div class="line">        else&#123;</div><div class="line">            q=ch[p][c];</div><div class="line">            if(len[q]==len[p]+1)fa[now]=q;</div><div class="line">            else&#123;</div><div class="line">                nq=++cnt,len[nq]=len[p]+1;</div><div class="line">                memcpy(ch[nq],ch[q],26&lt;&lt;2);</div><div class="line">                /*---有的题目需要用LCT维护*/</div><div class="line">                fa[nq]=fa[q],fa[q]=fa[now]=nq;</div><div class="line">                /*如若splay维护改成 </div><div class="line">                    fa[nq]=fa[q];</div><div class="line">                    splay(q),New(nq,right[q]);</div><div class="line">                    link(nq,fa[nq]),cut(q,fa[q]);</div><div class="line">                    fa[q]=fa[now]=nq,New(q,right[q]);</div><div class="line">                    link(q,fa[q]);</div><div class="line">                    //New是fa改变或是新建节点或是copy节点更改LCT中节点的信息 </div><div class="line">                */</div><div class="line">                while(p&amp;&amp;ch[p][c]==q)ch[p][c]=nq,p=fa[p];</div><div class="line">            &#125;</div><div class="line">        &#125;/*---同样的如果是LCT维护还要处理now和fa[now]*/</div><div class="line">        /*</div><div class="line">        New(now,1);</div><div class="line">        LCT::link(now,fa[now]);</div><div class="line">        LCT::access(now),LCT::splay(now);</div><div class="line">        c=LCT::s[LCT::ch[now][0]];</div><div class="line">        LCT::pushr(LCT::ch[now][0],1);</div><div class="line">        */</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---回文自动机*/ </div><div class="line">namespace PAM&#123;</div><div class="line">    const int N=1e4+10;</div><div class="line">    struct node&#123;</div><div class="line">        int ch[26],fa,len;</div><div class="line">    &#125;prt[N];</div><div class="line">    char s[N];</div><div class="line">    int pos;//处理到的位置pos </div><div class="line">    inline int get_fa(ri x)&#123;while(s[pos-1-prt[x].len]!=s[pos])x=prt[x].fa;return x;&#125;</div><div class="line">    int las,cnt;</div><div class="line">    inline void init()&#123;prt[0].fa=prt[1].fa=1,prt[1].len=-1,las=cnt=1;&#125;//初始化</div><div class="line">    inline int Insert(ri c)&#123;/*---构建回文自动机*/ </div><div class="line">        ri p=get_fa(las),now;</div><div class="line">        if(!prt[p].ch[c])&#123;</div><div class="line">            now=++cnt;</div><div class="line">            prt[now].len=prt[p].len+2;</div><div class="line">            prt[now].fa=prt[get_fa(prt[p].fa)].ch[c];</div><div class="line">            prt[p].ch[c]=now;</div><div class="line">        &#125;return las=prt[p].ch[c];</div><div class="line">    &#125;//可以用lca求出s串中两个回文串最长公共回文串</div><div class="line">    //亦或者可以快速求出以某个位置开头或者结尾的最长回文串</div><div class="line">    //也可以求出以每个位置为中心的最长回文串,Manacher哭了 </div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---2-SAT*/</div><div class="line">namespace two_SAT&#123;//建图之后跑tarjan即可,貌似没什么可以写的？(雾 </div><div class="line">    //令i是选i,i&apos;是不选i </div><div class="line">    //i-&gt;j连边:选i就必选j</div><div class="line">    //然后就根据题意建图 </div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---Tarjan算法*/ </div><div class="line">namespace Tarjan&#123;//过于简单</div><div class="line">    const int N=1e4+10,M=3e4+10;</div><div class="line">    int d[N],nxt[M&lt;&lt;1],to[M&lt;&lt;1],tot;</div><div class="line">    int dfn[N],low[N],stk[N],tail,cnt;</div><div class="line">    int id[N],cl;</div><div class="line">    bool in[N];</div><div class="line">    inline void tarjan(ri x)&#123;</div><div class="line">        dfn[x]=low[x]=++cnt;</div><div class="line">        stk[++tail]=x,in[x]=1;</div><div class="line">        for(ri i=d[x];i;i=nxt[i])&#123;</div><div class="line">            ri u=to[i];</div><div class="line">            if(in[u])low[x]=min(low[x],dfn[u]);</div><div class="line">            else if(!dfn[u])tarjan(u),low[x]=min(low[x],low[u]);</div><div class="line">        &#125;if(low[x]==dfn[x])&#123;</div><div class="line">            ri now;</div><div class="line">            ++cl;</div><div class="line">            do&#123;</div><div class="line">                now=stk[tail--];</div><div class="line">                in[now]=0;</div><div class="line">                id[now]=cl;</div><div class="line">            &#125;while(now!=x);</div><div class="line">        &#125;</div><div class="line">    &#125;inline void work(ri n)&#123;for(ri i=1;i&lt;=n;++i)if(!dfn[i])tarjan(i);&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---斯坦纳树*/</div><div class="line">namespace Staineer_Tree&#123;</div><div class="line">    const int N=1e4+10,M=1&lt;&lt;7,E=N&lt;&lt;2,inf=1&lt;&lt;27;</div><div class="line">    int dp[N][M],d[N],nxt[E],to[E],cost[E],tot;</div><div class="line">    bool in[N];</div><div class="line">    queue&lt;int&gt;q;</div><div class="line">    inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,cost[tot]=c;&#125;</div><div class="line">    inline void spfa(ri sta)&#123;</div><div class="line">        ri i,x,u;</div><div class="line">        while(!q.empty())&#123;</div><div class="line">            x=q.front(),q.pop();</div><div class="line">            in[x]=1;</div><div class="line">            for(i=d[x];i;i=nxt[i])&#123;</div><div class="line">                u=to[i];</div><div class="line">                if(dp[u][sta]&gt;dp[x][sta]+cost[i])&#123;//以边权为例 </div><div class="line">                    dp[u][sta]=dp[x][sta]+cost[i];</div><div class="line">                    if(!in[u])in[u]=1,q.push(u);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;inline void init()&#123;/*---一般是随机化每个点颜色,因题而异*/&#125;</div><div class="line">    inline void solve(ri n,ri k)&#123;</div><div class="line">        init();ri sta,s,i,lim;</div><div class="line">        lim=k&lt;&lt;1;</div><div class="line">        for(i=1;i&lt;=n;++i)memset(dp[i],0,lim&lt;&lt;2);</div><div class="line">        for(sta=0;sta&lt;lim;++sta)&#123;</div><div class="line">            for(i=1;i&lt;=n;++i)&#123;</div><div class="line">                for(s=(sta-1)&amp;sta;s;s=(s-1)&amp;sta)</div><div class="line">                    dp[i][sta]=min(dp[i][sta],dp[i][s]+dp[i][s^sta]);//如果是点权还有减去v[i] </div><div class="line">                    /*dp[i][sta]=min(dp[i][sta],dp[i][s]+dp[i][s^sta]-v[i]);*/</div><div class="line">                if(dp[i][sta]&lt;inf)q.push(i);</div><div class="line">            &#125;spfa(sta);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---广义圆方树*/</div><div class="line">namespace YF_Tree&#123;</div><div class="line">    const int N=1e4+10,M=4e4+10; </div><div class="line">    struct node&#123;</div><div class="line">        int d[N&lt;&lt;1],nxt[M],to[M],tot;</div><div class="line">        inline void ins(ri a,ri b)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot;&#125;</div><div class="line">    &#125;e,g;//e:原图,g:圆方树  </div><div class="line">    int dfn[N],low[N];</div><div class="line">    int st[N],tail,cnt,cl;//cl初始为n,为方点编号。 </div><div class="line">    inline void tarjan(ri x)&#123;/*---构建广义圆方树(不能用于仙人掌,可以用于一般图)*/ </div><div class="line">        dfn[x]=low[x]=++cnt;</div><div class="line">        st[++tail]=x;</div><div class="line">        for(ri i=e.d[x];i;i=e.nxt[i])&#123;</div><div class="line">            ri u=e.to[i];</div><div class="line">            if(!dfn[u])&#123;</div><div class="line">                tarjan(u);</div><div class="line">                low[x]=min(low[x],low[u]);</div><div class="line">                if(low[u]==dfn[x])&#123;</div><div class="line">                    ++cl;//新建方点</div><div class="line">                    ri now;</div><div class="line">                    do&#123;</div><div class="line">                        now=st[tail--];</div><div class="line">                        g.ins(now,cl),g.ins(cl,now);</div><div class="line">                    &#125; while(now!=u);</div><div class="line">                    g.ins(cl,x),g.ins(x,cl);</div><div class="line">                &#125;</div><div class="line">            &#125;else low[x]=min(low[x],dfn[u]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---正规圆方树(处理仙人掌)*/</div><div class="line">namespace YF_Tree_2&#123;</div><div class="line">    const int N=1e4+10,M=2e4+10;</div><div class="line">    struct node&#123;</div><div class="line">        int d[N&lt;&lt;1],nxt[M],to[M],cost[M],tot;</div><div class="line">        inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot;&#125;</div><div class="line">    &#125;e,g;</div><div class="line">    int sum[N&lt;&lt;1],stk[N],dfn[N],low[N],tail,cnt,cl;</div><div class="line">    inline void tarjan(ri x,ri fa)&#123;</div><div class="line">        dfn[x]=low[x]=++cnt;</div><div class="line">        stk[++tail]=x;</div><div class="line">        for(ri i=e.d[x];i;i=e.nxt[i])&#123;</div><div class="line">            ri u=e.to[i];</div><div class="line">            if(u==fa)continue;</div><div class="line">            if(!dfn[u])&#123;</div><div class="line">                sum[u]=sum[x]+e.cost[i];</div><div class="line">                tarjan(u,x);</div><div class="line">                low[x]=min(low[x],low[u]);</div><div class="line">                if(low[u]&gt;dfn[x])g.ins(x,u,e.cost[i]);</div><div class="line">            &#125;else if(dfn[u]&lt;low[x])&#123;</div><div class="line">                low[x]=dfn[u];</div><div class="line">                sum[++cl]=sum[x]+e.cost[i]-sum[u];</div><div class="line">                for(ri i=tail;stk[i]^u;--i)&#123;</div><div class="line">                    ri p=stk[i];</div><div class="line">                    g.ins(cl,p,min(sum[p]-sum[u],sum[cl]-sum[p]+sum[u]));</div><div class="line">                &#125;g.ins(u,cl,0);</div><div class="line">            &#125;</div><div class="line">        &#125;--tail;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---树上倍增优化建图*/</div><div class="line">namespace unknown_name_1&#123;//通常是某个点和某条链连边或者两条树上的链连边 </div><div class="line">    //这里以XR-1 逛森林 为例(因为我真的没做过其他树上倍增优化建图的题了) </div><div class="line">    const int N=1e4+10,M=N*18;</div><div class="line">    int fa[N][20],cid[N][20],rid[N][20];</div><div class="line">    int D[N],Nxt[N&lt;&lt;1],To[N&lt;&lt;1],Tot;</div><div class="line">    int d[N],nxt[M],to[M],cost[M],tot;</div><div class="line">    inline void ins(ri a,ri b)&#123;To[++Tot]=b,Nxt[Tot]=D[a],D[a]=Tot;&#125;</div><div class="line">    int Log[N],dep[N],cnt;</div><div class="line">    inline void link(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,cost[tot]=c;&#125;</div><div class="line">    inline void init()&#123;for(ri i=2;i&lt;N;++i)Log[i]=Log[i&gt;&gt;1]+1;&#125;</div><div class="line">    inline void clear(ri n)&#123;</div><div class="line">        memset(D,0,sizeof(D)),memset(d,0,sizeof(d));</div><div class="line">        tot=Tot=0;</div><div class="line">        cnt=n;</div><div class="line">    &#125;inline void dfs(ri x)&#123;//预处理 </div><div class="line">        cid[x][0]=rid[x][0]=x;</div><div class="line">        ri i,u;</div><div class="line">        for(i=1;i&lt;20;++i)//这样写可以不用初始化 </div><div class="line">            fa[x][i]=fa[fa[x][i-1]][i-1];</div><div class="line">        for(i=1;i&lt;=Log[dep[x]-1];++i)&#123;</div><div class="line">            cid[x][i]=++cnt;</div><div class="line">            rid[x][i]=++cnt;</div><div class="line">            link(cid[x][i-1],cid[x][i],0),</div><div class="line">            link(cid[fa[x][i-1]][i-1],cid[x][i],0);</div><div class="line">            link(rid[x][i],rid[x][i-1],0),</div><div class="line">            link(rid[x][i],rid[fa[x][i-1]][i-1],0);</div><div class="line">        &#125;for(i=D[x];i;i=Nxt[i])&#123;</div><div class="line">            u=To[i];</div><div class="line">            if(u!=fa[x][0])&#123;</div><div class="line">                fa[u][0]=x;</div><div class="line">                dep[u]=dep[x]+1;</div><div class="line">                dfs(u);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;inline int Lca(ri u,ri v)&#123;</div><div class="line">        if(dep[u]&lt;dep[v])swap(u,v);</div><div class="line">        while(dep[u]&gt;dep[v])u=fa[u][Log[dep[u]-dep[v]]];</div><div class="line">        if(u==v)return u;</div><div class="line">        for(ri i=Log[dep[u]-1];~i;--i)</div><div class="line">            if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i];</div><div class="line">        return fa[u][0];</div><div class="line">    &#125;inline int kfa(ri x,ri k)&#123;/*k-fa*/</div><div class="line">        ri z;</div><div class="line">        while(k)&#123;</div><div class="line">            z=k&amp;-k;</div><div class="line">            x=fa[x][Log[z]];</div><div class="line">            k-=z;</div><div class="line">        &#125;return x;</div><div class="line">    &#125;inline void build(ri u,ri v,ri w,ri t)&#123;//将u-&gt;v(必须满足是祖先关系)和cnt连边,w为边权,t为种类,0/1:连向cnt/cnt连向链 </div><div class="line">        ri c,p;</div><div class="line">        p=Log[dep[u]-dep[v]+1];</div><div class="line">        c=kfa(u,dep[u]-dep[v]+1-(1&lt;&lt;p));</div><div class="line">        link(t?cnt:cid[u][p],t?rid[u][p]:cnt,w);</div><div class="line">        if(c==u)return;</div><div class="line">        link(t?cnt:cid[c][p],t?rid[c][p]:cnt,w);</div><div class="line">    &#125;inline void work(ri u1,ri v1,ri u2,ri v2,ri w)&#123;</div><div class="line">        ++cnt;</div><div class="line">        ri p=Lca(u1,v1);</div><div class="line">        if(dep[u1]&gt;dep[v1])swap(u1,v1);</div><div class="line">        if(dep[u2]&gt;dep[v2])swap(u2,v2);</div><div class="line">        if(u1!=p)</div><div class="line">            build(u1,p,0,0);</div><div class="line">        build(v1,p,0,0);</div><div class="line">        p=Lca(u2,v2);</div><div class="line">        if(u2!=p)</div><div class="line">            build(u2,p,w,1);</div><div class="line">        build(v2,p,w,1);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---线段树优化建图*/</div><div class="line">namespace unknown_name_2&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---spfa(SLF+容错优化)*/</div><div class="line">namespace Spfa&#123;</div><div class="line">    const int N=1e4+10,M=N&lt;&lt;1;</div><div class="line">    int d[N],nxt[M],to[M],cost[M],tot;</div><div class="line">    int dis[N],W,n,m;</div><div class="line">    deque&lt;int&gt;q;</div><div class="line">    bool in[N];</div><div class="line">    inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,cost[tot]=c,W+=abs(c);&#125;</div><div class="line">    inline void init()&#123;W=pow(W/sqrt(m+1),2.0/3),W=W&lt;pow(m+1,1.0/3)?pow(m,1.0/3):W,W=W&gt;pow(m+1,2.0/3)?pow(m+1,2.0/3):W;&#125;</div><div class="line">    inline void spfa(ri S)&#123;</div><div class="line">        memset(dis,0x7f,sizeof(dis));</div><div class="line">        q.push_back(S),dis[S]=0;</div><div class="line">        while(!q.empty())&#123;</div><div class="line">            ri x=q.front();</div><div class="line">            q.pop_front();</div><div class="line">            in[x]=0;</div><div class="line">            for(ri i=d[x];i;i=nxt[i])&#123;</div><div class="line">                ri u=to[i];</div><div class="line">                if(dis[u]&gt;dis[x]+cost[i])&#123;</div><div class="line">                    dis[u]=dis[x]+cost[i];</div><div class="line">                    if(!in[u])&#123;</div><div class="line">                        in[u]=1;</div><div class="line">                        if(!q.empty()&amp;&amp;dis[u]&gt;dis[*q.begin()]+W)</div><div class="line">                            q.push_back(u);</div><div class="line">                        else q.push_back(u);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---dijkstra*/</div><div class="line">namespace Dijkstra&#123;//堆优化dijkstra,可以升级成线段树优化dijkstra </div><div class="line">    const int N=1e5+10; </div><div class="line">    struct node&#123;</div><div class="line">        int id,dis;</div><div class="line">        node(ri a=0,ri b=0)&#123;id=a,dis=b;&#125;</div><div class="line">        bool operator &lt;(const node&amp;other)const&#123;return dis&gt;other.dis;&#125;</div><div class="line">    &#125;;</div><div class="line">    priority_queue&lt;node&gt;q;</div><div class="line">    int d[N],nxt[N],to[N],cost[N],dis[N];</div><div class="line">    inline void dijkstra(ri S)&#123;</div><div class="line">        memset(dis,0x3f,sizeof(dis));</div><div class="line">        q.push(node(S,0)),dis[S]=0;</div><div class="line">        while(!q.empty())&#123;</div><div class="line">            node x=q.top();</div><div class="line">            q.pop();</div><div class="line">            if(x.dis&gt;dis[x.id])continue;</div><div class="line">            for(ri i=d[x.id];i;i=nxt[i])&#123;</div><div class="line">                ri u=to[i];</div><div class="line">                if(dis[u]&gt;dis[x.id]+cost[i])&#123;</div><div class="line">                    dis[u]=dis[x.id]+cost[i];</div><div class="line">                    q.push(node(u,dis[u]));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---虚树*/</div><div class="line">namespace vtree&#123;</div><div class="line">    const int N=1e5+10,M=N&lt;&lt;1;</div><div class="line">    int dfn[N],stk[N],dep[N],top;</div><div class="line">    int st[N],tp;</div><div class="line">    int Min[M][20],bit[M],fir[N];//tarjan求LCA</div><div class="line">    inline bool cmp(ri a,ri b)&#123;return dfn[a]&lt;dfn[b];&#125;</div><div class="line">    #define compare(a,b) (dep[a]&lt;dep[b]?a:b)</div><div class="line">    struct edge&#123;</div><div class="line">        int d[N],nxt[M],to[M],tot;//假设原树无边权 </div><div class="line">        inline void ins(ri a,ri b)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot;&#125;</div><div class="line">    &#125;s,t;</div><div class="line">    inline int lca(ri u,ri v)&#123;</div><div class="line">        u=fir[u],v=fir[v];</div><div class="line">        if(u&gt;v)swap(u,v);</div><div class="line">        ri p=bit[v-u+1];</div><div class="line">        return compare(Min[u][p],Min[v-(1&lt;&lt;p)+1][p]);</div><div class="line">    &#125;inline void buildv(ri x)&#123;</div><div class="line">        if(tp==1)&#123;st[++tp]=x;return;&#125;</div><div class="line">        ri Lca=lca(x,st[tp]);</div><div class="line">        while(tp&gt;1&amp;&amp;dep[st[tp-1]]&gt;=dep[Lca])t.ins(st[tp-1],st[tp]),--tp;</div><div class="line">        if(Lca!=st[tp])t.ins(Lca,st[tp]),st[tp]=Lca;</div><div class="line">        st[++tp]=x;</div><div class="line">    &#125;inline void work()&#123;</div><div class="line">        t.tot=0;</div><div class="line">        sort(stk+1,stk+1+top,cmp);</div><div class="line">        st[tp=1]=1;</div><div class="line">        if(stk[1]!=1)buildv(stk[1]);</div><div class="line">        for(ri i=2;i&lt;=top;++i)buildv(stk[i]);</div><div class="line">        while(tp&gt;1)t.ins(st[tp-1],st[tp]),--tp;</div><div class="line">//      Dp(1);</div><div class="line">    &#125;</div><div class="line">    #undef compare</div><div class="line">&#125; </div><div class="line"></div><div class="line">/*---Dinic*/</div><div class="line">namespace Dinic&#123;</div><div class="line">    const int N=1e4+10,M=2e4+10;</div><div class="line">    int d[N],nxt[M],to[M],flow[M],tot;</div><div class="line">    int dep[N],cur[N];</div><div class="line">    int S,T;//源、汇 </div><div class="line">    queue&lt;int&gt;q;</div><div class="line">    int Maxflow;</div><div class="line">    inline void init()&#123;memset(d,-1,sizeof(d)),tot=-1;&#125;</div><div class="line">    inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,flow[tot]=c;&#125;</div><div class="line">    inline void add(ri a,ri b,ri c)&#123;ins(a,b,c),ins(b,a,0);&#125;</div><div class="line">    inline bool bfs()&#123;</div><div class="line">        memset(dep,0,sizeof(dep));</div><div class="line">        memcpy(cur,d,sizeof(cur));</div><div class="line">        q.push(S),dep[S]=1;</div><div class="line">        while(!q.empty())&#123;</div><div class="line">            ri x=q.front();</div><div class="line">            q.pop();</div><div class="line">            for(ri i=d[x];~i;i=nxt[i])&#123;</div><div class="line">                ri u=to[i];</div><div class="line">                if(!dep[u]&amp;&amp;flow[i])</div><div class="line">                    dep[u]=dep[x]+1,q.push(u);</div><div class="line">            &#125;</div><div class="line">        &#125;return dep[T]!=0;</div><div class="line">    &#125;inline int dfs(ri now,ri lim)&#123;</div><div class="line">        if(now==T||!lim)&#123;Maxflow+=lim;return lim;&#125;</div><div class="line">        int fl=0,f;</div><div class="line">        for(ri i=cur[now];~i;i=nxt[i])&#123;</div><div class="line">            ri u=to[i];</div><div class="line">            cur[now]=i;</div><div class="line">            if(dep[u]==dep[now]+1&amp;&amp;(f=dfs(u,min(flow[i],lim))))&#123;</div><div class="line">                flow[i]-=f,flow[i^1]+=f;</div><div class="line">                fl+=f,lim-=f;</div><div class="line">                if(!lim)break;</div><div class="line">            &#125;</div><div class="line">        &#125;return fl;</div><div class="line">    &#125;inline int Dinic()&#123;Maxflow=0;</div><div class="line">        while(bfs())&#123;</div><div class="line">            while(dfs(S,inf));</div><div class="line">        &#125;return Maxflow;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---ISAP*/</div><div class="line">namespace ISAP&#123;</div><div class="line">    const int N=1e4+10,M=2e4+10;</div><div class="line">    int d[N],nxt[M],to[M],flow[M],tot;</div><div class="line">    int S,T;</div><div class="line">    int cur[N],dep[N],num[N],pre[N];</div><div class="line">    queue&lt;int&gt;q;</div><div class="line">    inline void init()&#123;memset(d,-1,sizeof(d)),tot=-1;&#125;</div><div class="line">    inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,flow[tot]=c;&#125;</div><div class="line">    inline void add(ri a,ri b,ri c)&#123;ins(a,b,c),ins(b,a,0);&#125;</div><div class="line">    inline bool bfs()&#123;</div><div class="line">        memset(dep,0,sizeof(dep));</div><div class="line">        memset(num,0,sizeof(num));</div><div class="line">        memcpy(cur,d,sizeof(cur));</div><div class="line">        dep[T]=1,q.push(T);</div><div class="line">        while(!q.empty())&#123;</div><div class="line">            ri x=q.front();</div><div class="line">            q.pop();</div><div class="line">            ++num[dep[x]];</div><div class="line">            for(ri i=d[x];~i;i=nxt[i])&#123;</div><div class="line">                ri u=to[i];</div><div class="line">                if(!dep[u]&amp;&amp;flow[i^1])</div><div class="line">                    dep[u]=dep[x]+1,q.push(u);</div><div class="line">            &#125;</div><div class="line">        &#125;return dep[S]!=0;</div><div class="line">    &#125;inline int add_flow()&#123;</div><div class="line">        ri now=T,ans=inf;</div><div class="line">        while(now!=S)ans=min(ans,flow[pre[now]]),now=to[pre[now]^1];</div><div class="line">        now=T;</div><div class="line">        while(now!=S)flow[pre[now]]-=ans,flow[pre[now]^1]+=ans,now=to[pre[now]^1];</div><div class="line">        return ans;</div><div class="line">    &#125;inline int ISAP()&#123;</div><div class="line">        if(!bfs())return 0;</div><div class="line">        ri Maxflow=0,now=S;</div><div class="line">        while(233)&#123;</div><div class="line">            if(now==T)&#123;Maxflow+=add_flow(),now=S;&#125;</div><div class="line">            bool have_way=0;</div><div class="line">            for(ri i=cur[now];~i;i=nxt[i])&#123;</div><div class="line">                ri u=to[i];</div><div class="line">                if(flow[i]&amp;&amp;dep[u]+1==dep[now])&#123;</div><div class="line">                    pre[u]=i,have_way=1;</div><div class="line">                    cur[now]=i,now=u;break;</div><div class="line">                &#125;</div><div class="line">            &#125;if(!have_way)&#123;</div><div class="line">                if(!--num[dep[now]])return Maxflow;</div><div class="line">                ++num[++dep[now]];</div><div class="line">                cur[now]=d[now];</div><div class="line">                if(now!=S)now=to[pre[now]^1];</div><div class="line">            &#125;</div><div class="line">        &#125;return Maxflow;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---HLPP*/</div><div class="line">namespace HLPP&#123;//太难写了 </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---费用流(EK,Dinic,zkw)*/</div><div class="line">namespace cost_flow&#123;//以最小费用最大流为例 </div><div class="line">    const int N=205,M=550;</div><div class="line">    int d[N],nxt[M],to[M],flow[M],cost[M],tot;</div><div class="line">    int dis[N],S,T;</div><div class="line">    inline void ins(ri a,ri b,ri c,ri e)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,flow[tot]=c,cost[tot]=e;&#125;</div><div class="line">    inline void add(ri a,ri b,ri c,ri e)&#123;ins(a,b,c,e),ins(b,a,0,-e);&#125;</div><div class="line">    int W;//W为pow(sum w(w&gt;0)/sqrt(n+1),0.666667),W=W&lt;down:down:W,W=W&gt;up?up:W;</div><div class="line">    namespace EK&#123;</div><div class="line">        int pre[N];</div><div class="line">        deque&lt;int&gt;q;</div><div class="line">        bool in[N];</div><div class="line">        inline bool spfa()&#123;//SLF+容错(个人感觉挺不错的) </div><div class="line">            memset(dis,0x7f,sizeof(dis));</div><div class="line">            ri i,u,x;</div><div class="line">            q.push_back(S),dis[S]=0;</div><div class="line">            while(!q.empty())&#123;</div><div class="line">                x=*(q.begin());</div><div class="line">                q.pop_front();</div><div class="line">                in[x]=0;</div><div class="line">                for(i=d[x];~i;i=nxt[i])&#123;</div><div class="line">                    u=to[i];</div><div class="line">                    if(flow[i]&amp;&amp;dis[u]&gt;dis[x]+cost[i])&#123;</div><div class="line">                        dis[u]=dis[x]+cost[i];</div><div class="line">                        pre[u]=i;</div><div class="line">                        if(!in[u])&#123;</div><div class="line">                            in[u]=1;</div><div class="line">                            if(!q.empty()&amp;&amp;dis[u]&gt;dis[*q.begin()]+W)</div><div class="line">                                q.push_back(u);</div><div class="line">                            else q.push_front(u);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;return dis[T]&lt;inf;</div><div class="line">        &#125;inline int EK()&#123;ri Mincost=0,Maxflow=0,now,ans;</div><div class="line">            while(spfa())&#123;</div><div class="line">                ans=inf;</div><div class="line">                for(now=T;now!=S;now=to[pre[now]^1])</div><div class="line">                    ans=min(ans,flow[pre[now]]);</div><div class="line">                for(now=T;now!=S;now=to[pre[now]^1])</div><div class="line">                    flow[pre[now]]-=ans,flow[pre[now]^1]+=ans;</div><div class="line">                Mincost+=ans*dis[T];</div><div class="line">                Maxflow+=ans;</div><div class="line">            &#125;return Mincost;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    namespace Dinic&#123;</div><div class="line">        deque&lt;int&gt;q;</div><div class="line">        bool in[N];</div><div class="line">        int vis[N],cur[N],Tim,Mincost,Maxflow;</div><div class="line">        inline bool spfa()&#123;</div><div class="line">            memset(dis,0x7f,sizeof(dis));</div><div class="line">            memcpy(cur,d,sizeof(cur));</div><div class="line">            ri i,u,x;</div><div class="line">            q.push_back(S),dis[S]=0;</div><div class="line">            while(!q.empty())&#123;</div><div class="line">                x=q.front();</div><div class="line">                q.pop_front();</div><div class="line">                in[x]=0;</div><div class="line">                for(i=d[x];~i;i=nxt[i])&#123;</div><div class="line">                    u=to[i];</div><div class="line">                    if(dis[u]&gt;dis[x]+cost[i])&#123;</div><div class="line">                        dis[u]=dis[x]+cost[i];</div><div class="line">                        if(!in[u])&#123;</div><div class="line">                            in[u]=1;</div><div class="line">                            if(!q.empty()&amp;&amp;dis[u]&gt;dis[*q.begin()]+W)</div><div class="line">                                q.push_back(u);</div><div class="line">                            else q.push_front(u);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;return dis[T]&lt;inf;</div><div class="line">        &#125;inline int dfs(ri now,ri lim)&#123;</div><div class="line">            if(now==T||!lim)&#123;Mincost+=dis[now]*lim,Maxflow+=lim;return lim;&#125;</div><div class="line">            ri fl=0,f;</div><div class="line">            vis[now]=Tim;</div><div class="line">            for(ri i=cur[now];~i;i=nxt[i])&#123;</div><div class="line">                cur[now]=i;</div><div class="line">                ri u=to[i];</div><div class="line">                if(dis[u]==dis[now]+cost[i]&amp;&amp;vis[u]!=Tim&amp;&amp;(f=dfs(u,min(lim,flow[i]))))&#123;</div><div class="line">                    fl+=f,</div><div class="line">                    flow[i]-=f,</div><div class="line">                    flow[i^1]+=f;</div><div class="line">                    lim-=f;</div><div class="line">                    if(!lim)break;</div><div class="line">                &#125;</div><div class="line">            &#125;return fl;</div><div class="line">        &#125;inline int Dinic()&#123;Mincost=Maxflow=0;</div><div class="line">            while(spfa())&#123;</div><div class="line">                do&#123;</div><div class="line">                    ++Tim;</div><div class="line">                &#125;while(dfs(S,inf));</div><div class="line">            &#125;return Mincost;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    namespace zkw&#123;</div><div class="line">        int cur[N],vis[N],Tim,cnt;//节点编号为0-cnt </div><div class="line">        int Mincost,Maxflow;</div><div class="line">        inline bool zkw()&#123;</div><div class="line">            memcpy(cur,d,sizeof(cur));</div><div class="line">            ri i,x,mn=inf;</div><div class="line">            for(x=0;x&lt;=cnt;++x)</div><div class="line">                if(vis[x]==Tim)</div><div class="line">                    for(i=d[x];~i;i=nxt[i])</div><div class="line">                        if(flow[i]&amp;&amp;vis[to[i]]!=Tim)</div><div class="line">                            mn=min(mn,dis[x]-dis[to[i]]+cost[i]);</div><div class="line">            if(mn&gt;=inf)return 0;</div><div class="line">            for(x=0;x&lt;=cnt;++i)if(vis[x]==Tim)dis[x]-=mn;</div><div class="line">            return 1;</div><div class="line">        &#125;inline int dfs(ri now,ri lim)&#123;</div><div class="line">            if(!lim||now==T)&#123;Mincost-=dis[now]*lim,Maxflow+=lim;return lim;&#125;</div><div class="line">            ri fl=0,f;</div><div class="line">            vis[now]=Tim;</div><div class="line">            for(ri i=cur[now];~i;i=nxt[i])&#123;</div><div class="line">                ri u=to[i];</div><div class="line">                cur[now]=i;</div><div class="line">                if(dis[u]==dis[now]+cost[i]&amp;&amp;vis[u]!=Tim&amp;&amp;(f=dfs(u,min(lim,flow[i]))))&#123;</div><div class="line">                    fl+=f,</div><div class="line">                    flow[i]-=f,</div><div class="line">                    flow[i^1]+=f;</div><div class="line">                    lim-=f;</div><div class="line">                    if(!lim)break;</div><div class="line">                &#125;</div><div class="line">            &#125;return lim;</div><div class="line">        &#125;inline int work()&#123;Mincost=Maxflow=0;</div><div class="line">            do&#123;</div><div class="line">                do&#123;</div><div class="line">                    ++Tim;</div><div class="line">                &#125;while(dfs(S,inf));</div><div class="line">            &#125;while(zkw());</div><div class="line">            return Mincost;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---随机化乱搞(模拟退火,随机化数组,爬山算法)*/</div><div class="line">namespace Random_work&#123;</div><div class="line">    /*---模拟退火*/ </div><div class="line">    const double eps=1e-6;</div><div class="line">    namespace SA&#123;</div><div class="line">        struct Pnt&#123;</div><div class="line">            double x,y;</div><div class="line">            Pnt(double a=0,double b=0)&#123;x=a,y=b;&#125;</div><div class="line">            inline void get()&#123;x=rand(),y=rand();&#125;</div><div class="line">        &#125;;</div><div class="line">//      template&lt;typename T&gt;</div><div class="line">        inline double calc(Pnt x)&#123;/*---估价函数*/return 0;&#125;</div><div class="line">        inline double get_rand()&#123;return rand()*1.0/RAND_MAX;&#125;//如果可以是负数再随机一次符号 </div><div class="line">        inline void work()&#123;</div><div class="line">            double tmp=1000;//可以是系数或是步长,这里是步长</div><div class="line">            Pnt O,now;</div><div class="line">            O.get();</div><div class="line">            double Ans=calc(O),ans;</div><div class="line">            bool find;</div><div class="line">            while(tmp&gt;eps)&#123;</div><div class="line">                find=0;</div><div class="line">                now=Pnt(O.x+tmp*get_rand(),O.y+tmp*get_rand());</div><div class="line">                ans=calc(now);</div><div class="line">                if(ans&lt;Ans)Ans=ans,O=now,find=1;</div><div class="line">            &#125;if(!find)tmp/=2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---splay_one*/</div><div class="line">namespace Splay_one&#123;//此处为一个spaly </div><div class="line">    const int N=1e4+10;</div><div class="line">    int ch[N][2],fa[N],siz[N],rt;</div><div class="line">    int v[N],cnt;//以权值排序为例,当然也可以不用排序,</div><div class="line">    #define lc ch[x][0]</div><div class="line">    #define rc ch[x][1]</div><div class="line">    inline void pushup(ri x)&#123;siz[x]=siz[lc]+siz[rc]+1;/*---*/&#125;</div><div class="line">    inline void rotate(ri x)&#123;</div><div class="line">        ri y=fa[x],z=fa[y],k=ch[y][1]!=x;</div><div class="line">        ch[z][ch[z][1]==y]=x,fa[x]=z;</div><div class="line">        ch[y][!k]=ch[x][k],fa[ch[x][k]]=y;</div><div class="line">        ch[x][k]=y,fa[y]=x,pushup(y);//降低常数 </div><div class="line">    &#125;inline void pushdown(ri x)&#123;/*---懒惰标记下放*/&#125;</div><div class="line">    int stk[N],tail;</div><div class="line">    inline void splay(ri x,ri goal)&#123;</div><div class="line">        ri y,z;</div><div class="line">        /*</div><div class="line">        stk[++tail]=x;</div><div class="line">        for(y=x;fa[y]!=goal;y=fa[y])stk[++tail]=fa[y];</div><div class="line">        while(tail)pushdown(stk[tail--]);</div><div class="line">        */</div><div class="line">        while(fa[x]!=goal)&#123;</div><div class="line">            y=fa[x],z=fa[y];</div><div class="line">            if(z!=goal)(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y);</div><div class="line">            rotate(x);</div><div class="line">        &#125;if(!goal)rt=x;</div><div class="line">        pushup(x);</div><div class="line">    &#125;inline void Insert(ri x)&#123;//加入节点,加入前已初始化 </div><div class="line">        ri y=rt;</div><div class="line">        if(!y)&#123;rt=x;return;&#125;</div><div class="line">        ri f=0;</div><div class="line">        //pushdown(y);</div><div class="line">        while(y)&#123;</div><div class="line">            f=y,y=ch[y][v[x]&gt;=v[y]];</div><div class="line">//          pushdown(y);</div><div class="line">        &#125;fa[x]=f,ch[f][v[x]&gt;=v[f]]=x;</div><div class="line">        splay(x,0);</div><div class="line">    &#125;inline void del()&#123;</div><div class="line">        ri x=rt,k;</div><div class="line">        if(lc)k=0;</div><div class="line">        else if(rc)k=1;</div><div class="line">        else &#123;rt=0;lc=rc=fa[x]=0;return;&#125;</div><div class="line">        ri y=ch[x][k];</div><div class="line">//      pushdown(y);</div><div class="line">        while(ch[y][!k])&#123;</div><div class="line">            y=ch[y][!k];</div><div class="line">//          pushdown(y);</div><div class="line">        &#125;splay(y,x);</div><div class="line">        ch[y][!k]=ch[x][!k],fa[ch[x][!k]]=y,fa[y]=0,rt=y;</div><div class="line">        pushup(y),lc=rc=fa[x]=0;</div><div class="line">    &#125;inline void Del(ri val)&#123;//删除权值为val的点,此处如有多个只删一个 </div><div class="line">        ri x=rt;</div><div class="line">        while(x)&#123;</div><div class="line">//          pushdown(x);</div><div class="line">            if(v[x]!=val)x=ch[x][val&gt;v[x]];</div><div class="line">            else&#123;</div><div class="line">                splay(x,0),del();</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;inline int kth(ri k)&#123;</div><div class="line">        ri x=rt;</div><div class="line">        while(x)&#123;</div><div class="line">            pushdown(x);</div><div class="line">            if(siz[lc]&gt;=k)x=lc;</div><div class="line">            else &#123;</div><div class="line">                k-=siz[lc]+1;</div><div class="line">                if(!k)return x;//之后要splay一次 </div><div class="line">                x=rc;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;inline void split(ri L,ri R)&#123;//以加入-inf,inf哨兵为例 </div><div class="line">        ri x=kth(L);splay(x,0);</div><div class="line">        ri y=kth(R+2);splay(y,x);</div><div class="line">        //ch[y][0]即为区间[L,R] </div><div class="line">    &#125;inline int build(ri L,ri R)&#123;//笛卡尔建树 </div><div class="line">        if(L&gt;R)return 0;</div><div class="line">        ri x=(L+R)&gt;&gt;1;</div><div class="line">        lc=build(L,x-1),rc=build(x+1,R);</div><div class="line">        fa[lc]=fa[rc]=x;</div><div class="line">        pushup(x);return x;</div><div class="line">    &#125;//最后别忘了fa[rt]=0;如果多次建树的话 </div><div class="line">    #undef lc</div><div class="line">    #undef rc</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---splay_two*/</div><div class="line">namespace Splay_two&#123;//多颗spaly,内含启发式合并 </div><div class="line">    const int N=1e4+10;</div><div class="line">    int ch[N][2],fa[N],siz[N],rt[N];</div><div class="line">    int v[N];</div><div class="line">    #define lc ch[x][0]</div><div class="line">    #define rc ch[x][1]</div><div class="line">    inline void pushup(ri x)&#123;siz[x]=siz[lc]+siz[rc]+1;&#125;</div><div class="line">    inline void rotate(ri x)&#123;</div><div class="line">        ri y=fa[x],z=fa[y],k=ch[y][1]!=x;</div><div class="line">        ch[z][ch[z][1]==y]=x,fa[x]=z;</div><div class="line">        ch[y][!k]=ch[x][k],fa[ch[x][k]]=y;</div><div class="line">        ch[x][k]=y,fa[y]=x,pushup(y);</div><div class="line">    &#125;inline void pushdown(ri x)&#123;/*---*/&#125;</div><div class="line">    int stk[N],tail;</div><div class="line">    int st[N],tot;</div><div class="line">    /*---begin 这段部分与一棵树的差别只在于记录了是处理哪棵树*/</div><div class="line">    inline void splay(ri p,ri x,ri goal)&#123;</div><div class="line">        ri y,z;</div><div class="line">        /*</div><div class="line">        stk[++tail]=x;</div><div class="line">        for(y=x;fa[y]!=goal;y=fa[y])stk[++tail]=fa[y];</div><div class="line">        while(tail)pushdown(stk[tail--]);</div><div class="line">        */</div><div class="line">        while(fa[x]!=goal)&#123;</div><div class="line">            y=fa[x],z=fa[y];</div><div class="line">            if(z!=goal)(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y);</div><div class="line">            rotate(x);</div><div class="line">        &#125;if(!goal)rt[p]=x;</div><div class="line">        pushup(x);</div><div class="line">    &#125;inline void Insert(ri p,ri x)&#123;</div><div class="line">        ri y=rt[p];</div><div class="line">        if(!y)&#123;rt[p]=x;return;&#125;</div><div class="line">        ri f=0;</div><div class="line">//      pushdown(y);</div><div class="line">        while(y)&#123;</div><div class="line">            f=y,y=ch[y][v[x]&gt;=v[y]];</div><div class="line">//          pushdown(y);</div><div class="line">        &#125;fa[x]=f,ch[f][v[x]&gt;=v[f]]=x;</div><div class="line">        splay(p,x,0);</div><div class="line">    &#125;inline void del(ri p)&#123;</div><div class="line">        ri x=rt[p],k;</div><div class="line">        if(lc)k=0;</div><div class="line">        else if(rc)k=1;</div><div class="line">        else &#123;rt[p]=0;lc=rc=fa[x]=0;return;&#125;</div><div class="line">        ri y=ch[x][k];</div><div class="line">//      pushdown(y);</div><div class="line">        while(ch[y][!k])&#123;</div><div class="line">            y=ch[y][!k];</div><div class="line">//          pushdown(y);</div><div class="line">        &#125;splay(p,y,x);</div><div class="line">        ch[y][!k]=ch[x][!k],fa[ch[x][!k]]=y,fa[y]=0,rt[p]=y;</div><div class="line">        pushup(y),lc=rc=fa[x]=0;</div><div class="line">    &#125;inline void Del(ri p,ri val)&#123;</div><div class="line">        ri x=rt[p];</div><div class="line">        while(x)&#123;</div><div class="line">//          pushdown(x);</div><div class="line">            if(v[x]!=val)x=ch[x][val&gt;v[x]];</div><div class="line">            else&#123;</div><div class="line">                splay(p,x,0),del(p);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;inline int kth(ri p,ri k)&#123;</div><div class="line">        ri x=rt[p];</div><div class="line">        while(x)&#123;</div><div class="line">            //pushdown(x);</div><div class="line">            if(siz[lc]&gt;=k)x=lc;</div><div class="line">            else &#123;</div><div class="line">                k-=siz[lc]+1;</div><div class="line">                if(!k)return x;//之后要splay一次 </div><div class="line">                x=rc;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;inline void split(ri p,ri L,ri R)&#123;//以加入-inf,inf哨兵为例 </div><div class="line">        ri x=kth(p,L);splay(p,x,0);</div><div class="line">        ri y=kth(p,R+2);splay(p,y,x);</div><div class="line">        //ch[y][0]即为区间[L,R] </div><div class="line">    &#125;</div><div class="line">    /*---end*/</div><div class="line">    inline void dfs(ri x)&#123;if(!x)return;dfs(lc),st[++tot]=x,dfs(rc);lc=rc=fa[x]=0;&#125;</div><div class="line">    inline void Merge(ri x,ri y)&#123;//合并两颗splay </div><div class="line">        if(siz[x]&gt;siz[y])swap(x,y);</div><div class="line">        //不过大部分题目用启发式合并并不需要对每个点维护siz,一般只用维护rt的siz,可以降低常数(少pushup) </div><div class="line">        tot=0,dfs(rt[x]);//遍历较小的spaly</div><div class="line">        for(ri i=1;i&lt;=tot;++i)Insert(y,st[i]); </div><div class="line">    &#125;</div><div class="line">    #undef lc</div><div class="line">    #undef rc</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---标准LCT*/</div><div class="line">namespace LCT&#123;</div><div class="line">    const int N=1e5+10;</div><div class="line">    int ch[N][2],fa[N],rev[N],stk[N],top;</div><div class="line">    #define lc ch[x][0]</div><div class="line">    #define rc ch[x][1]</div><div class="line">    inline bool rt(ri x)&#123;ri y=fa[x];return ch[y][0]!=x&amp;&amp;ch[y][1]!=x;&#125;</div><div class="line">    inline void pushdown(ri x)&#123;if(rev[x])swap(lc,rc),rev[lc]^=1,rev[rc]^=1,rev[x]=0;&#125;</div><div class="line">    inline void pushup(ri x)&#123;&#125;</div><div class="line">    inline void rotate(ri x)&#123;</div><div class="line">        ri y=fa[x],z=fa[y],k=ch[y][1]!=x;</div><div class="line">        if(!rt(y))ch[z][ch[z][1]==y]=x;fa[x]=z;</div><div class="line">        ch[y][!k]=ch[x][k],fa[ch[x][k]]=y;</div><div class="line">        ch[x][k]=y,fa[y]=x;pushup(y);</div><div class="line">    &#125;inline void splay(ri x)&#123;</div><div class="line">        ri y,z;</div><div class="line">        for(stk[++top]=y=x;!rt(y);y=fa[y])stk[++top]=fa[y];</div><div class="line">        while(top)pushdown(stk[top--]);</div><div class="line">        while(!rt(x))&#123;</div><div class="line">            y=fa[x],z=fa[y];</div><div class="line">            if(!rt(y))(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y);</div><div class="line">            rotate(x);</div><div class="line">        &#125;pushup(x);</div><div class="line">    &#125;inline int access(ri x)&#123;ri y;</div><div class="line">        for(y=0;x;x=fa[y=x])</div><div class="line">            splay(x),rc=y,pushup(x);</div><div class="line">        return y;</div><div class="line">    &#125;inline void makeroot(ri x)&#123;access(x),splay(x),rev[x]^=1;&#125;</div><div class="line">    inline void link(ri x,ri y)&#123;makeroot(x),fa[x]=y;&#125;</div><div class="line">    inline void split(ri x,ri y)&#123;makeroot(x),access(y),splay(y);&#125;</div><div class="line">    inline int findroot(ri x)&#123;</div><div class="line">        access(x),splay(x);</div><div class="line">        while(lc)x=lc;</div><div class="line">        splay(x);</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line">    #undef lc</div><div class="line">    #undef rc</div><div class="line">&#125; </div><div class="line"></div><div class="line">/*---较难版本LCT*/</div><div class="line">namespace LCT_2&#123;//以可以实现链反转,链求和为例(不带链修改,懒得写) </div><div class="line">    const int N=1e4+10;</div><div class="line">    #define lc ch[x][0]</div><div class="line">    #define rc ch[x][1]</div><div class="line">    struct Splay&#123;</div><div class="line">        int ch[N][2],fa[N],v[N],rev[N],siz[N],s[N];</div><div class="line">        inline void pushup(ri x)&#123;</div><div class="line">            siz[x]=siz[lc]+siz[rc]+1;</div><div class="line">            s[x]=s[lc]+s[rc]+v[x];</div><div class="line">        &#125;inline void pushdown(ri x)&#123;if(rev[x])swap(lc,rc),rev[lc]^=1,rev[rc]^=1,rev[x]=0;&#125;</div><div class="line">        int stk[N],tail;</div><div class="line">        inline void rotate(ri x)&#123;</div><div class="line">            ri y=fa[x],z=fa[y],k=ch[y][1]!=x;</div><div class="line">            ch[z][ch[z][1]==y]=x,fa[x]=z;</div><div class="line">            ch[y][!k]=ch[x][k],fa[ch[x][k]]=y;</div><div class="line">            ch[x][k]=y,fa[y]=x,pushup(y);</div><div class="line">        &#125;inline void splay(ri x,ri goal)&#123;</div><div class="line">            ri y,z;</div><div class="line">            stk[++tail]=x;</div><div class="line">            for(y=x;fa[y]!=goal;y=fa[y])stk[++tail]=fa[y];</div><div class="line">            while(tail)pushdown(stk[tail--]);</div><div class="line">            while(fa[x]!=goal)&#123;</div><div class="line">                y=fa[x],z=fa[y];</div><div class="line">                if(z!=goal)(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y);</div><div class="line">                rotate(x);</div><div class="line">            &#125;pushup(x);</div><div class="line">        &#125;inline void split(ri x,ri k,ri&amp;a,ri&amp;b)&#123;</div><div class="line">            while(x)&#123;</div><div class="line">                pushdown(x);</div><div class="line">                if(siz[lc]&gt;=k)x=lc;</div><div class="line">                else&#123;</div><div class="line">                    k-=siz[lc]+1;</div><div class="line">                    if(!k)&#123;</div><div class="line">                        splay(x,0);</div><div class="line">                        a=x,b=rc;</div><div class="line">                        rc=fa[b]=0;</div><div class="line">                        pushup(x);</div><div class="line">                        return;</div><div class="line">                    &#125;x=rc;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;inline void Merge(ri x,ri y,ri&amp;a)&#123;</div><div class="line">            pushdown(x);</div><div class="line">            while(rc)x=rc,pushdown(x);</div><div class="line">            splay(x,0);</div><div class="line">            rc=y,a=x;</div><div class="line">            pushup(x);</div><div class="line">        &#125;</div><div class="line">    &#125;S;</div><div class="line">    int ch[N][2],fa[N],siz[N];//如果需要实现链反转需要维护siz</div><div class="line">    int rt[N],rev[N];</div><div class="line">    inline bool rot(ri x)&#123;ri y=fa[x];return ch[y][0]!=x&amp;&amp;ch[y][1]!=x;&#125;</div><div class="line">    inline void pushup(ri x)&#123;siz[x]=siz[lc]+siz[rc]+1;&#125;</div><div class="line">    inline void rotate(ri x)&#123;</div><div class="line">        ri y=fa[x],z=fa[y],k=ch[y][1]!=x;</div><div class="line">        if(!rot(y))ch[z][ch[z][1]==y]=x;fa[x]=z;</div><div class="line">        ch[y][!k]=ch[x][k],fa[ch[x][k]]=y;</div><div class="line">        ch[x][k]=y,fa[y]=x,pushup(y);</div><div class="line">    &#125;inline void pushdown(ri x)&#123;if(rev[x])swap(lc,rc),rev[lc]^=1,rev[rc]^=1,rev[x]=0;&#125;</div><div class="line">    int stk[N],tail;</div><div class="line">    inline void splay(ri x)&#123;</div><div class="line">        ri y,z;</div><div class="line">        stk[++tail]=x;</div><div class="line">        for(y=x;!rot(y);y=fa[y])stk[++tail]=fa[y];</div><div class="line">        while(tail)pushdown(stk[tail--]);</div><div class="line">        swap(rt[x],rt[y]);</div><div class="line">        while(!rot(x))&#123;</div><div class="line">            y=fa[x],z=fa[y];</div><div class="line">            if(!rot(y))(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y);</div><div class="line">            rotate(x);</div><div class="line">        &#125;pushup(x);</div><div class="line">    &#125;inline void access(ri x)&#123;</div><div class="line">        for(ri y=0;x;x=fa[y=x])&#123;</div><div class="line">            splay(x);</div><div class="line">            if(rc)S.split(rt[x],siz[lc]+1,rt[x],rt[rc]);</div><div class="line">            if(y)S.Merge(rt[x],rt[y],rt[x]),rt[y]=0;</div><div class="line">            rc=y,pushup(x);</div><div class="line">        &#125;</div><div class="line">    &#125;inline void makeroot(ri x)&#123;access(x),splay(x),rev[x]^=1,S.rev[rt[x]]^=1;&#125;</div><div class="line">    inline void link(ri x,ri y)&#123;makeroot(x),fa[x]=y;&#125;</div><div class="line">    inline void split(ri x,ri y)&#123;makeroot(x),access(y),splay(y);&#125;</div><div class="line">    inline void reverse(ri x,ri y)&#123;split(x,y),S.rev[rt[y]]^=1;&#125;/*---链反转*/ </div><div class="line">    #undef lc</div><div class="line">    #undef rc</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---吉司林线段树*/</div><div class="line">namespace JSL_Segment_Tree&#123;</div><div class="line">    const int N=2e4;</div><div class="line">    int l[N],r[N],mn[N],cn[N],sn[N],sum[N],tag[N];//以取max,求区间和为例,记录最小、次小、最小个数,总和,以及懒惰标记</div><div class="line">    int a[N],rt,cnt;</div><div class="line">    #define lc l[x]</div><div class="line">    #define rc r[x]</div><div class="line">    inline void pushup(ri x)&#123;</div><div class="line">        if(mn[lc]&lt;mn[rc])mn[x]=mn[lc],sn[x]=sn[lc],cn[x]=min(cn[lc],mn[rc]);</div><div class="line">        else if(mn[rc]&lt;mn[lc])mn[x]=mn[rc],sn[x]=sn[rc],cn[x]=min(cn[rc],mn[lc]);</div><div class="line">        else mn[x]=mn[lc],sn[x]=sn[lc]+sn[rc],cn[x]=min(cn[lc],cn[rc]);</div><div class="line">    &#125;inline void build(ri&amp;x,ri L,ri R)&#123;</div><div class="line">        x=++cnt;tag[x]=-inf;</div><div class="line">        if(L==R)&#123;mn[x]=sum[x]=a[L],cn[x]=inf,sn[x]=1;return;&#125;</div><div class="line">        ri mid=(L+R)&gt;&gt;1;</div><div class="line">        build(lc,L,mid),build(rc,mid+1,R);</div><div class="line">        pushup(x);</div><div class="line">    &#125;inline void push_tag(ri x,ri v)&#123;</div><div class="line">        if(v&lt;=tag[x])return;</div><div class="line">        sum[x]+=(v-tag[x])*sn[x],mn[x]=tag[x]=v;</div><div class="line">    &#125;inline void pushdown(ri x)&#123;</div><div class="line">        if(tag[x]!=-inf)push_tag(lc,tag[x]),push_tag(rc,tag[x]),tag[x]=-inf;</div><div class="line">    &#125;inline void Modify(ri x,ri L,ri R,ri ll,ri rr,ri v)&#123;</div><div class="line">        if(mn[x]&gt;=v)return;</div><div class="line">        if(ll&lt;=L&amp;&amp;R&lt;=rr&amp;&amp;cn[x]&gt;v)return push_tag(x,v);</div><div class="line">        ri mid=(L+R)&gt;&gt;1;pushdown(x);</div><div class="line">        if(ll&lt;=mid)Modify(lc,L,mid,ll,rr,v);</div><div class="line">        if(rr&gt;mid)Modify(rc,mid+1,R,ll,rr,v);</div><div class="line">        pushup(x);</div><div class="line">    &#125;inline int query(ri x,ri L,ri R,ri ll,ri rr)&#123;</div><div class="line">        if(ll&lt;=L&amp;&amp;R&lt;=rr)return sum[x];</div><div class="line">        int mid=(L+R)&gt;&gt;1;pushdown(x);</div><div class="line">        if(ll&gt;mid)return query(rc,mid+1,R,ll,rr);</div><div class="line">        else if(rr&lt;=mid)return query(lc,L,mid,ll,rr);</div><div class="line">        else return query(lc,L,mid,ll,rr)+query(rc,mid+1,R,ll,rr);</div><div class="line">    &#125;</div><div class="line">    #undef lc</div><div class="line">    #undef rc</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---李超树*/</div><div class="line">namespace LC_Tree&#123;</div><div class="line">    const int N=1e5+10;</div><div class="line">    #define lc ch[x][0]</div><div class="line">    #define rc ch[x][1]</div><div class="line">    int ch[N][2],l[N],r[N],cnt;</div><div class="line">    LL dl[N],dr[N],K[N],B[N],mn[N],dis[N];</div><div class="line">    inline LL f(ri x,LL k,LL b)&#123;return b+k*x;&#125;</div><div class="line">    inline void pushup(ri x)&#123;mn[x]=min(mn[x],min(mn[lc],mn[rc]));&#125;</div><div class="line">    inline void build(ri&amp;x,ri L,ri R)&#123;</div><div class="line">        x=++cnt;B[x]=mn[x]=inf;l[x]=L,r[x]=R;</div><div class="line">        if(L==R)&#123;dl[x]=dr[x]=dis[L];return;&#125;</div><div class="line">        ri mid=(L+R)&gt;&gt;1;</div><div class="line">        build(lc,L,mid),build(rc,mid+1,R);</div><div class="line">        dl[x]=dl[lc],dr[x]=dr[rc];</div><div class="line">    &#125;inline void extand(ri x,LL k,LL b)&#123;//以维护最下方的线段为例 </div><div class="line">        LL f1,f2,f3,f4;</div><div class="line">        f1=f(dl[x],K[x],B[x]),f2=f(dr[x],K[x],B[x]);</div><div class="line">        f3=f(dl[x],k,b),f4=f(dr[x],k,b);</div><div class="line">        if(f3&lt;=f1&amp;&amp;f4&lt;=f2)&#123;K[x]=k,B[x]=b;mn[x]=min(mn[x],min(f3,f4));return;&#125;</div><div class="line">        if(f3&gt;f1&amp;&amp;f4&gt;f2)return;</div><div class="line">        LL g=(b-B[x])/(K[x]-k);</div><div class="line">        LL h=dr[lc];</div><div class="line">        if(g&lt;=h||f3&lt;=f1)extand(lc,k,b);</div><div class="line">        if(g&gt;h||f4&lt;=f2)extand(rc,k,b);</div><div class="line">        pushup(x);</div><div class="line">    &#125;inline void Modify(ri x,ri ll,ri rr,ri k,ri b)&#123;</div><div class="line">        if(ll&lt;=l[x]&amp;&amp;r[x]&lt;=rr)return extand(x,k,b);</div><div class="line">        ri mid=(l[x]+r[x])&gt;&gt;1;</div><div class="line">        if(ll&lt;=mid)Modify(lc,ll,rr,k,b);</div><div class="line">        if(rr&gt;mid)Modify(rc,ll,rr,k,b);</div><div class="line">        pushup(x);</div><div class="line">    &#125;inline LL query(ri x,ri ll,ri rr)&#123;</div><div class="line">        if(ll&lt;=l[x]&amp;&amp;r[x]&lt;=rr)return mn[x];</div><div class="line">        ri mid=(l[x]+r[x])&gt;&gt;1;</div><div class="line">        LL ans=inf;</div><div class="line">        if(ll&lt;=mid)ans=min(ans,query(lc,ll,rr));</div><div class="line">        if(rr&gt;mid)ans=min(ans,query(rc,ll,rr));</div><div class="line">        ri L=max(ll,l[x]),R=min(rr,r[x]);</div><div class="line">        ans=min(ans,f(dis[L],K[x],B[x]));</div><div class="line">        ans=min(ans,f(dis[R],K[x],B[x]));</div><div class="line">        return ans;</div><div class="line">    &#125;</div><div class="line">    #undef lc</div><div class="line">    #undef rc</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---KD-Tree*/</div><div class="line">namespace KDT&#123;//以k远点对为例 </div><div class="line">    const int N=1e5+10,M=N&lt;&lt;1;</div><div class="line">    #define lc ch[x][0]</div><div class="line">    #define rc ch[x][1]</div><div class="line">    struct pnt&#123;</div><div class="line">        int x[2];</div><div class="line">    &#125;a[N];</div><div class="line">    int opt;</div><div class="line">    struct node&#123;int dis;node(ri a=0)&#123;dis=a;&#125;inline bool operator &lt;(const node&amp;other)const&#123;return dis&gt;other.dis;&#125;&#125;;;//小根堆 </div><div class="line">    priority_queue&lt;node&gt;q;</div><div class="line">    inline bool cmp(register pnt a,register pnt b)&#123;return a.x[opt]&lt;b.x[opt];&#125;</div><div class="line">    inline int f(pnt a,pnt b)&#123;return sqr(a.x[0]-b.x[0])+sqr(a.x[1]-b.x[1]);&#125;</div><div class="line">    struct ST&#123;</div><div class="line">        int ch[M][2],minn[M][2],maxn[M][2],cnt;</div><div class="line">        pnt d[M];</div><div class="line">        inline void pushup(ri x)&#123;</div><div class="line">            for(ri i=0;i&lt;2;++i)maxn[x][i]=minn[x][i]=d[x].x[i];</div><div class="line">            if(lc)for(ri i=0;i&lt;2;++i)maxn[x][i]=max(maxn[x][i],maxn[lc][i]),minn[x][i]=min(minn[x][i],minn[lc][i]);</div><div class="line">            if(rc)for(ri i=0;i&lt;2;++i)maxn[x][i]=max(maxn[x][i],maxn[rc][i]),minn[x][i]=min(minn[x][i],minn[rc][i]);</div><div class="line">        &#125;inline int build(ri L,ri R,ri k)&#123;</div><div class="line">            if(L&gt;R)return 0;</div><div class="line">            ri x=++cnt;opt=k;</div><div class="line">            ri mid=(L+R)&gt;&gt;1;</div><div class="line">            nth_element(a+L,a+mid,a+R+1,cmp);</div><div class="line">            d[x]=a[mid];</div><div class="line">            lc=build(L,mid-1,k^1),rc=build(mid+1,R,k^1);</div><div class="line">            pushup(x);</div><div class="line">        &#125;inline int g(pnt a,ri b)&#123;</div><div class="line">            return max(sqr(maxn[b][0]-a.x[0]),sqr(minn[b][0]-a.x[0]))+max(sqr(maxn[b][1]-a.x[1]),sqr(minn[b][1]-a.x[1]));</div><div class="line">        &#125;inline void query(ri x,pnt O)&#123;</div><div class="line">            ri dl=-inf,dr=-inf;</div><div class="line">            if(lc)dl=g(O,lc);</div><div class="line">            if(rc)dr=g(O,rc);</div><div class="line">            ri dis=f(d[x],O);</div><div class="line">            if(q.top().dis&lt;dis)q.pop(),q.push(dis);</div><div class="line">            if(dl&gt;dr)&#123;if(q.top().dis&lt;dl)query(lc,O);if(q.top().dis&lt;dr)query(rc,O);&#125;</div><div class="line">            else &#123;if(q.top().dis&lt;dr)query(rc,O);if(q.top().dis&lt;dl)query(lc,O);&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    #undef lc</div><div class="line">    #undef rc </div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---左偏树*/</div><div class="line">namespace leftist_heap&#123;</div><div class="line">    const int N=1e4+10;</div><div class="line">    int rt,dep[N],l[N],r[N],v[N];</div><div class="line">    inline void pushr(ri x,ri v)&#123;/*---*/&#125;</div><div class="line">    inline void pushdown(ri x)&#123;/*---下放懒惰标记*/&#125;</div><div class="line">    inline int Merge(ri k1,ri k2)&#123;//以大跟堆为例 </div><div class="line">        if(!k1||!k2)return k1|k2;</div><div class="line">        pushdown(k1),pushdown(k2);</div><div class="line">        if(v[k1]&lt;v[k2])swap(k1,k2);</div><div class="line">        r[k1]=Merge(r[k1],k2);</div><div class="line">        if(dep[r[k1]]&gt;dep[l[k1]])swap(l[k1],r[k1]);</div><div class="line">        dep[k1]=dep[r[k1]]+1;return k1;</div><div class="line">    &#125;inline int top()&#123;return rt;&#125;</div><div class="line">    inline void pop()&#123;rt=Merge(l[rt],r[rt]),l[rt]=r[rt]=0;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---长链剖分(通常是处理树上与dep深度有关的dp问题)*/</div><div class="line">namespace unknown_name_3&#123;</div><div class="line">    const int N=1e4+10;</div><div class="line">    int len[N],d[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],fa[N],son[N];</div><div class="line">    int tmp[N],*id,*dp[N];</div><div class="line">    inline void dfs(ri x)&#123;</div><div class="line">        for(ri i=d[x];i;i=nxt[i])&#123;</div><div class="line">            ri u=to[i];</div><div class="line">            if(u!=fa[x])</div><div class="line">                fa[u]=x,dfs(u),son[x]=len[u]&gt;len[son[x]]?u:son[x];</div><div class="line">        &#125;len[x]=len[son[x]]+1;</div><div class="line">    &#125;inline void Dp(ri x)&#123;</div><div class="line">        /*---此处预处理*/</div><div class="line">        if(son[x])&#123;</div><div class="line">            dp[son[x]]=dp[x]+1;</div><div class="line">            Dp(son[x]);</div><div class="line">            /*---因题而异,有的题需要继承son[x]的答案什么的*/</div><div class="line">        &#125;for(ri i=d[x];i;i=nxt[i])&#123;</div><div class="line">            ri u=to[i];</div><div class="line">            if(u!=fa[x])&#123;</div><div class="line">                Dp(u);</div><div class="line">                /*---work,此处dp*/</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---重链剖分HDT*/</div><div class="line">namespace HDT&#123;//可以用重链剖分将树上的链转化为不超过logn条轻,每条链的编号是连续的 </div><div class="line">    //因此可以将部分较麻烦的树上问题改成维护若干条链。</div><div class="line">    //也可以O(logn)求Lca,自带1/4的常数,还可以实现链反转,以及做动态链反转、链排序等等神仙题qwq</div><div class="line">    const int N=1e5+10;</div><div class="line">    int low[N],dfn[N],top[N],son[N],fa[N],siz[N],Tim; </div><div class="line">    int d[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],tot;</div><div class="line">    int dep[N];</div><div class="line">    inline void dfs1(ri x)&#123;</div><div class="line">        siz[x]=1;</div><div class="line">        for(ri i=d[x];i;i=nxt[i])&#123;</div><div class="line">            ri u=to[i];</div><div class="line">            if(u==fa[x])continue;</div><div class="line">            fa[u]=x,dep[u]=dep[x]+1;</div><div class="line">            dfs1(u),siz[x]+=siz[u];</div><div class="line">            son[x]=siz[u]&gt;siz[son[x]]?u:son[x];</div><div class="line">        &#125;</div><div class="line">    &#125;inline void dfs2(ri x)&#123;</div><div class="line">        low[dfn[x]=++Tim]=x;</div><div class="line">        if(!son[x])return;</div><div class="line">        top[son[x]]=top[x];</div><div class="line">        dfs2(son[x]);</div><div class="line">        for(ri i=d[x];i;i=nxt[i])&#123;</div><div class="line">            ri u=to[i];</div><div class="line">            if(u==fa[x]||u==son[x])continue;</div><div class="line">            top[u]=u;</div><div class="line">            dfs2(u);</div><div class="line">        &#125;</div><div class="line">    &#125;inline void init()&#123;dep[1]=top[1]=1;dfs1(1),dfs2(1);&#125;</div><div class="line">    inline int Lca(ri u,ri v)&#123;while(top[u]!=top[v])&#123;if(dep[top[u]]&lt;dep[top[v]])swap(u,v);u=fa[top[u]];&#125;return dep[u]&lt;dep[v]?u:v;&#125;</div><div class="line">    inline void Modify(ri u,ri v)&#123;</div><div class="line">        while(top[u]!=top[v])&#123;</div><div class="line">            if(dep[top[u]]&lt;dep[top[v]])swap(u,v);</div><div class="line">//          modify(dfn[top[u]],dfn[u]);//因题而异,有的题甚至是将这些链存起来再进行操作 </div><div class="line">        &#125;if(dep[u]&gt;dep[v])swap(u,v);</div><div class="line">//      modify(dfn[u],dfn[v]);</div><div class="line">    &#125;inline int query(ri u,ri v)&#123;</div><div class="line">        //大体同上 </div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"></div><div class="line">/*---线段树合并*/</div><div class="line">namespace unknown_name_4&#123;</div><div class="line">    const int N=1e4+10;</div><div class="line">    int l[N*50],r[N*50],siz[N*50],cnt;//以你的名字为例</div><div class="line">    #define lc l[x]</div><div class="line">    #define rc r[x]</div><div class="line">    inline void New(ri&amp;x,ri L,ri R,ri pos)&#123;</div><div class="line">        siz[x=++cnt]=1;</div><div class="line">        if(L==R)return;</div><div class="line">        ri mid=(L+R)&gt;&gt;1;</div><div class="line">        if(pos&lt;=mid)New(lc,L,mid,pos);</div><div class="line">        else New(rc,mid+1,R,pos);</div><div class="line">    &#125;inline int Merge(ri x,ri y)&#123;</div><div class="line">        if(!x||!y)return x|y;</div><div class="line">        ri o=++cnt;</div><div class="line">        siz[o]=siz[x]+siz[y];</div><div class="line">        l[o]=Merge(l[x],l[y]),r[o]=Merge(r[x],r[y]);</div><div class="line">        return o;</div><div class="line">    &#125;inline int query(ri x,ri L,ri R,ri ll,ri rr)&#123;</div><div class="line">        if(!x)return 0;</div><div class="line">        if(ll&lt;=L&amp;&amp;R&lt;=rr)return siz[x];</div><div class="line">        ri mid=(L+R)&gt;&gt;1;</div><div class="line">        if(ll&gt;mid)return query(rc,mid+1,R,ll,rr);</div><div class="line">        else if(rr&lt;=mid)return query(lc,L,mid,ll,rr);</div><div class="line">        else return query(lc,L,mid,ll,rr)+query(rc,mid+1,R,ll,rr);</div><div class="line">    &#125;</div><div class="line">    #undef lc</div><div class="line">    #undef rc</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---莫队合集*/</div><div class="line">namespace MD&#123;</div><div class="line">    namespace MD_1&#123;//不带修改普通莫队 </div><div class="line"></div><div class="line">    &#125;namespace MD_2&#123;//带修改普通莫队 </div><div class="line"></div><div class="line">    &#125;namespace MD_3&#123;//不带修改树上莫队 </div><div class="line"></div><div class="line">    &#125;namespace MD_4&#123;//带修改树上莫队 </div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---分块*/</div><div class="line">namespace FK&#123;//有预处理出单个块的答案,预处理出块与块之间的答案(部分可用ST表优化),权值分块,将询问分块,树上分块等等 </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/*---Berlekamp-Massey算法*/</div><div class="line">namespace Berlekamp_Massey&#123; </div><div class="line">    const int N=505;</div><div class="line">    const double eps=1e-8;</div><div class="line">    vector&lt;double&gt;ans[N];</div><div class="line">    double delta[N];</div><div class="line">    int fail[N];</div><div class="line">    inline void calc(ri*a,ri n,ri*b,ri&amp;cnt)&#123;</div><div class="line">        ri Max,Mul;</div><div class="line">        for(ri i=1,j,tmp;i&lt;=n;++i)&#123;</div><div class="line">            tmp=a[i];</div><div class="line">            for(j=ans[cnt].size()-1;~j;--j)</div><div class="line">                tmp-=ans[cnt][j]*a[i-j-1];</div><div class="line">            delta[i]=tmp;</div><div class="line">            if(fabs(tmp)&lt;eps)continue;</div><div class="line">            fail[cnt]=i;</div><div class="line">            if(!cnt)&#123;ans[++cnt].resize(i);continue;&#125;</div><div class="line">            Mul=tmp/delta[fail[cnt-1]];</div><div class="line">            ++cnt,ans[cnt].resize(i-fail[cnt-2]-1);</div><div class="line">            ans[cnt].push_back(Mul);</div><div class="line">            Max=ans[cnt-2].size();</div><div class="line">            for(j=0;j&lt;Max;++j)ans[cnt].push_back(ans[cnt-2][j]*-Mul);</div><div class="line">            Max=ans[cnt-1].size();</div><div class="line">            if(ans[cnt].size()&lt;Max)ans[cnt].resize(Max);</div><div class="line">            for(j=0;j&lt;Max;++j)</div><div class="line">                ans[cnt][j]+=ans[cnt-1][j];</div><div class="line">        &#125;for(ri i=ans[cnt].size()-1;~i;--i)b[i]=ans[cnt][i];</div><div class="line">        cnt=ans[cnt].size();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*--- 凸包*/</div><div class="line">namespace convex_hull&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
