<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[to_do_list]]></title>
    <url>%2F2035%2F01%2F01%2Fto-do-list%2F</url>
    <content type="text"><![CDATA[记录一些想学的东西，如果有空或者大家感兴趣可能会写成文章吧 [ ] python [ ] 复习一下算法（都忘得差不多了） [x] 日本近代史 [ ] 中世纪的继承法、法理和宣称 [ ] 国际共运史 Tentative Schedule Week 1: C/C++ Introduction, Editors, IDEs, Version Control, Writing first program, Compiling, Linking, Variables, Datatypes, Arithmetic Operators Week 2: Array, String, Struct, Control Flow (Branching, Loops) Week 3: Pointers, Pointer Arithmetic, Debugging (gdb), Functions and Modular Programming, Variable Scope Week 4: Recursion, Dynamic Memory Allocations, Garbage Collection Week 5: Encapsulation, Object, Class, Constructor, Destructor, Member Function, Overloading Week 6: Inheritance and Polymorphism, Template, STL Week 7: Miscellaneous (Type Cast, Friends, Exception, etc.), Modern C++ (C++ 11 and beyond), Writing Effective C++, Coding Style, Coding Habits Week 8: Code Performance Week 9 - Week 15: Codeing Projects + Discussion Sessions]]></content>
  </entry>
  <entry>
    <title><![CDATA[python学习踩坑记录]]></title>
    <url>%2F2022%2F09%2F21%2Fpython-learning%2F</url>
    <content type="text"><![CDATA[引用 &amp; 拷贝1 可变对象 &amp; 不可变对象 在Python中，对象分为两种：可变对象和不可变对象。 不可变对象包括int，float，long，str，tuple等，可变对象包括list，set，dict等。 不可变对象修改时，事实上创建了新的变量，如： 1234567a = 1print(id(a))a += 1print(id(a))output:22599241566562259924156688 因此，在函数传参时，若传入可变对象，修改之后指向的是新的变量，不影响原变量，而传入不可变对象，修改将涉及原变量。（我戏称为“可变不可变，不可变可变”） 12345678910111213def func(dat): dat += 1a = 1func(a)print(a)output : 1def func(dat): dat += [1]a = [1, 2, 3]func(a)print(a)output : [1, 2, 3, 1] 深复制 &amp; 浅复制一般=代表引用，（浅）复制列表value的语法是`value[:] 1234a = [0, [1, 2], 3]b = a[:]a[0] = 8a[1][1] = 9 问：此时 a 和 b 分别是多少？ 正确答案是 a 为 [8, [1, 9], 3]，b 为 [0, [1, 9], 3]。发现没？b 的第二个元素也被改变了。想想是为什么？不明白的话看下图 真正的深复制（完全创造一份新的副本） 123import copya = [0, [1, 2], 3]b = copy.deepcopy(a) 1:部分引自python基础： 深入理解 python 中的赋值、引用、拷贝、作用域]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机入门]]></title>
    <url>%2F2022%2F09%2F21%2Fcs-introduction%2F</url>
    <content type="text"><![CDATA[A Crash Course of Linear AlgebraNorms \begin{cases} p(x + y) = 0, p(x) = 0 \ only \ if \ x = 0 \end{cases}p-norms: \begin{Vmatrix} \vec{v} \end{Vmatrix}_p = \left(\sum \limits _i |v_i|^p\right)^{\frac{1}{p}}norm equivalence: \exists c, C, s.t. \ cp(x)]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线性代数笔记]]></title>
    <url>%2F2022%2F09%2F14%2Flinear-algebra%2F</url>
    <content type="text"><![CDATA[System of linear equations \begin{cases} x_1 + a_{12}x_2 = b_1 \\ x_1 + a_{22}x_2 = b_2 \end{cases}consistent: there are solutions (cross) inconsistent : …… (parallel) \sum \limits^{n}_{i = 1}a_{ji}x_i=b_j \ , j = 1,2,...,ncoefficient matrix 系数矩阵 augmented matrix 增广矩阵 echelon form 阶梯形式 增广矩阵最后一列也是主元！！！！！！]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微积分笔记]]></title>
    <url>%2F2022%2F09%2F14%2Fcalculus%2F</url>
    <content type="text"><![CDATA[实数系与实数列的极限 实数系自然数 N = \{ 0, 1, 2, 3, ... \} 半群\begin{cases} 加法: a + b = c \\ 零元：0 + a = a = a + 0 \\ 结合律: (a + b) + c = a + (b + c) \\ （若有逆元）: a + (-a) = 0 \rightarrow 群\end{cases} 整数 Z = \{ 0, \pm 1, \pm 2, \pm 3, ... \} \underbrace{\underbrace {+, 0, -} _{加法群} \underbrace {\times, 1} _{乘法半群}} _{环（交换群加半群）} 有理数 Q = \{ \frac {p} {q} | p, q \in Z, q \not= 0 \} \underbrace {+, 0, -, \times , 1, \div} _域 实数 R 直观：直线上的点 \leftrightarrow 直线无洞 复数 C 代数封闭 定义:A是非空数集， 若\exists M \in R, s.t. \forall x \in A, 有 x \leq M, 则称M为A的上界 定义:A的最小上界称为A的上（下）确界 sup \ A \ (inf \ A) 如果 sup A \in A, max A := sup A 确界定理：有上界的非空数集必有上确界。 数列极限的基本概念定义（极限）： 对数列\{a_n\}及常数A,\forall\epsilon>0,\exists N \in N s.t. \ \forall n>N \ |a_n - A| < \epsilon，则称\{a_n\}有极限A， 也称收敛于A，记为\lim _{n \rightarrow \infty} = A，或 a_n \rightarrow Ae.g. 设 0 < |q| < 1 求证 \lim\limits_{n \rightarrow \infty} q^n = 0 证： |a_n - A| = |q|^n < \epsilon \Leftrightarrow n > \frac {\log \epsilon} {\log |q|} ​ \forall \epsilon > 0, N := \frac {\log \epsilon} {\log |q|}, when \ n > N, |a_n - A| < \epsilon 收敛数列的性质性质1 若数列\{a_n\}收敛，则它的极限是唯一的 性质2 在一个收敛数列\{a_n\}中任意添加、删去有限项，或者任意改变有限项的值，不会改变该数列的收敛性与极限值 定义 设\{a_n\}是一个数列,0 N , |x_n - x_ m| < \epsilon)]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日本的近代化01 序言和背景（更新中）]]></title>
    <url>%2F2022%2F05%2F10%2Fjapan-modernization-1%2F</url>
    <content type="text"><![CDATA[写在前面声明：笔者为业余历史爱好者，本文中将不可避免出现考据不严谨或者历史暴论，希望读者不吝赐教，感激不尽。 众所周知，简中互联网上关于日本战国和旧日本帝国的内容非常充实,但对日本的近代化历程的关注度一直有限。 从某乎的关注度可见一斑 然而“明治维新”这一在义务教育课本中都有所涉猎课题，讨论度如此有限让笔者感到惊讶。经过一些粗浅的研究后，笔者的收获包括但不限于了解到了日本海陆矛盾的起源，大正民主的幻想如何从起源到破灭，法西斯分子如何夺取政权，旧日本帝国军队的诞生和异化，等等有趣的话题。笔者希望通过一系列大纲性质的专栏，为大家科普日本的近代化进程。同时也希望抛砖引玉，吸引更多的朋友来研究该领域。 序言1853年7月8日，大清咸丰三年，也是日本嘉永六年，美国东印度舰队司令官马修·佩里率领四艘蒸汽战舰“萨斯喀那”号、“普利茅斯”号、“萨拉托加”号和“密西西比”号，驶入江户湾的门户——浦贺港，向日本递交美国总统的国书。 黑船来航事件 在日本人看来如天狗下凡，喷吐着浓烟，发出巨响的美国军舰，全身涂抹着玄黑色，于是被称为“黑船”，这就是著名的“黑船事件”。 是时，江户城中居民们惊恐地望向这些不可撼动的钢铁巨兽；武士们奔走于街巷，忙于备战；城外的寺院钟声齐鸣，人们涌入神社，祷告神灵，祈求曾经击败蒙古大军的“护国神风”再临，赶走米利幹国来的侵略者。 当天午夜，江户城的信鸽将“黑船”到来的消息送往京都，孝明天皇天颜失色，幕府两百年来维持的统治正遭受严峻的挑战，而幕府上下都毫无应对之策。孝明天皇本人一筹莫展，只得亲自前往神社连续祈祷十七天，祈求天下太平，皇祚长久。征夷大将军德川家庆接到美国国书之后，带病与幕阁讨论时急火攻心而逝世。 7月14日，幕府最终决定接受国书，双方在久里滨举行了接受仪式，日方承诺向美方开放港口，提供煤水补给，保护美国船员等，但对条款的细节拖延到次年答复。在返航前夕，佩里舰队开入江户湾深处测量水文，面对日本官员的质问，佩里告诉日方，来年春天将带着一支更大的舰队再来日本，在寻求一个更大的锚地。7月17日，佩里舰队经琉球返回上海。 自德川家康的“锁国令”颁布以来，日本的国门就这样向西方国家再次洞开了。 1854年《日美和亲条约》（神奈川条约）、《日美修好通商条约》（下田条约）、《日英协约》、《日俄和亲条约》相继签订，随后1858年更是与美、俄、英、荷、法签订了有关开港、领事裁判权、居留地的《安政五国条约》，作为中国人的我们无疑会有“既视感”：幕府似乎正步大清国之后尘，落入西方列强的殖民深渊。 但历史告诉我们，在短短二十年之后，幕府的封建统治被各藩联军推翻，而日本也在追赶工业化末班车的道路上狂奔，作为近代东亚率先掀起文明开化浪潮的日本，却选择了走向军国主义道路。从德川时代的和平，到明治时代的内战外战，从大正民主的幻梦，到昭和民族主义的野兽，近代日本历史的“变异性”在此展现无遗。 大起大落，沉浮兴亡。是为序。 历史背景江户幕府的统治作为日本统一以来事实上的统治者，自1603年德川家康自立为征夷大将军以来，江户幕府已走过了两个多世纪的历史。终结战国乱世的德川家康试图不依靠皇室、贵族的旧有权威管理国家，无论德川一派，还是与德川对抗的一派大名均得到了新的封地。全国大名分为三大类，即亲藩、谱带和外样。亲藩之中御三家的藩祖都是家康的亲儿子，代代子孙可为将军候补者，确保幕府将军血统纯正。除御三家外，又有将军庶子一系的御三卿，御三家的庶子分流而出的御连枝等，枝繁叶茂支撑起江户幕府。谱代大名的藩主大多是以“德川四天王”为代表的德川老根据地三河国的地头家族。而位居下层的外样大名，多是曾与德川家对抗或在秀吉死后才归顺的，他们在幕末蜂起打破幕藩制度，是开创明治新时代的主力。 所谓幕藩体制，由幕府和藩组成，最大的特征是遵照分割统治与世袭的身份制原则来进行统治。在这一体制下，全国的土地主要分为幕领和大名领，幕领又分为直辖地（天领）和旗本领（幕府的直参家臣），大名领分为藩直辖地和家臣给地。幕府直参的武士和各藩藩士都没有给地，有的由幕府或藩支给一部分禄米。 大名的参觐交代队列 幕府与各大名之间的关系是以幕府可以要求各大名的军役，但幕府对各大名不行使征税权，各藩的领地收入原则上由各藩支配。于是幕府控制大名的主要手段——参觐交代——各藩的大名需要前往江户替幕府将军执行政务一段时间，然后返回自己领土执行政务。等于是让大名定期作人质。除此之外，各大名还要承担“普请”劳役，为幕府修筑城池、道路、水利工程等。 幕藩体制下的等级制社会经历了日本战国乱象，无论是统一日本过程中的织田信长、丰臣秀吉，还是德川家康，都希望建立起组织严密的封建政权。以丰臣秀吉的“太阁检地”丈量土地并确立耕地所有权为标志，庄园制宣告解体，一方面将农民世世代代束缚在土地上，从事农业生产，另一方面也切断了武士阶级与农业的联系，使他们依赖俸禄为生。即所谓“兵农分离”。 在这里我们可以聊一聊在日本家喻户晓的《忠臣藏》的原型，也就是江户时代的“赤穗事件” 播磨国赤穗藩藩主浅野长矩在奉命接待朝廷敕使一事上深觉受到总指导高家旗本吉良义央的刁难与侮辱，愤而在幕府将军居城江户城的大廊上拔刀砍伤吉良义央。此事让将军德川纲吉在敕使面前蒙羞，将军怒不可遏，在尚未深究事件原由的情况下，当日便命令浅野长矩切腹谢罪并将赤穗废藩，而吉良义央未受任何处分。以首席家老大石良雄为首的赤穗家臣们虽然试图向幕府请愿以图复藩再兴，但一年后确定复藩无望，大石遂率领赤穗家臣共47人夜袭吉良宅邸，斩杀吉良义央，将其首级供在泉岳寺主君墓前，成功复仇。事发后虽然舆论皆谓之为忠臣义士，但幕府最后仍决定命令与事的赤穗家臣切腹自尽，而吉良家也遭到没收领地及流放的处分。1 在这里我不讨论故事本身，而是想借此指明一点，驱使四十七士赴死的除了为主复仇的忠诚之外，很大一部分的原因是灭藩之后生活没有保障，无奈舍命抗争。大石留下的账簿反映出义士们的生活落魄，由此可见“兵农分离”确实使武士阶级成为了仰仗上级俸禄为生的寄生阶级，无法脱离藩而独活。由此，江户幕府也得以维持长期的平稳统治。同样，当先进的外国火器传入日本，武士军队可以被平民军队所轻松击败时，幕府的倒台也是可以预见的了。 关于江户时代等级社会的细节，这里引用一段材料2 兵农分离，奠定了士农工商社会等级身份制的基础。在德川时代，据享保六年（1721）进行的首次人口统计，日本全国被编入身份制的人口大约为2600万，加上身份制之外人口，大约为3000万左右。据幕末人口统计，武士约为总人口的6％—7％，农民约为总人口的80％—85％，也就是说，仅士农两个等级，已占据了日本人口总数的90％左右；其下依次为：町人为5％—6％，秽多、非人等贱民为1.6％，神官、僧尼为1.5％。兵农分离的结果，使绝大多数的日本人分别被划定在武士与农民等两大身份等级之内，其余的数百万日本人，主要是手工业者“职人”和商人“町人”，从而形成了士农工商顺序排列的身份等级制。 在士农工商等级身份制度的框架内，统治阶级武士作为世袭的职业军人，垄断军事、警察部门，拥有佩刀、称姓，即通称“苗字带刀”和“杀人而官不问其罪”，即“切舍御免”等特权，凌驾于农工商等其他社会等级之上。在武士内部，又分成从执掌幕藩各级政权的家臣幕僚到冲锋陷阵的步兵“足轻”等几十个等级。武士内部的上下级之间层层隶属，个人不得“退仕”自行改变武士身份或“脱藩”擅离职守，以效忠主君为第一要务，形成相对稳固的统治序列。作为体现武士阶级的人生价值观念、道德准绳和社会优越意识的精神信条，武士道在德川时期非常盛行。 农民在德川时代被称为“百姓”，是农业社会的主要生产劳动者。封建领主认为“百姓乃天下之根本” ，推行重农抑商政策。因此，农民的社会地位仅次于武士，而居工匠、商人之上。在农民等级内部，也按照各自在村中的地位、财产的多寡、担负封建地税的能力和数量，划分成不同层次。地位最高者，是在当地素有影响和实力的“草分百姓”、“持高百姓”，有权出任村吏，管理和代表本村，完成赋役、治安、禁教等各项差遣。位居其下者，是农民中人数最多的自耕农“本百姓”，他们的名字被写进土地户口账簿“检地账”，拥有家屋和耕地使用权；他们也被记入村内收租账本“名寄账”，承担缴纳年贡、杂税等义务。作为交换，他们拥有领主承认其在村社地位的“百姓株”，享有田渠用水权和山林用益权。地位又等而次之的，是相当于佃农的“名子”、“被官”，他们是隶属于“本百姓”的依附农民，不具有相应的权利。处于农民等级最下层的赤贫农民，称为“水吞百姓”，他们未被记入检地账，也无任何权力，经常流离失所。 居住在城市街区城下町的手工业者和商人，也各按行业分工分别居住在职人町或商人町，各由职人头或商人司负责管理，内部实行自治。职人分成效劳于领主的“御职人”或从事一般手工业生产的“平职人”，彼此地位高低不同。商人则分成地产和店铺的规模很大、独立经营并拥有专卖权的御用商人“本町人”，其中少数御用大豪商为“扶持町人”，可以称姓、佩刀、骑马，分享准武士的特权待遇；“家持”、“大屋”等上层本町人把持了町街事务。无地产、房产的商人地位低下，其中借地租房者“借家人”无权参与町政，也不受任何保护，处于被支配的地位；“驻马”、“连雀”，是摆地摊的小商贩或走街串巷的流动商贩，地位最低，无任何权利保障。 在士农工商等级序列之外，还存在一种特殊的贱民。他们居住在町街特别划定的区域内，与外界隔绝，备受屈辱和蔑视。贱民分成从事屠宰、制革等被佛教视为不洁行业的“秽多”，由“秽多头”管理；此外，行乞者“非人”主要从事行刑时的服务性工作，他们被禁止束发，以示区别。 当然，稳定的江户幕府也不能逃脱历史周期律，在18世纪中叶，幕府统治的腐化已经不可质疑。尽管武士仍尊为士农工商之首，但由于普遍贫穷或冒名顶替服役，武士阶级的战斗力正如八旗一样下降到了难以置信的地步。脱离生产又远离战乱的武士家族，人口自然飞速增长。同时维持着奢侈生活的武士家族走向破产，于是不得不拿出不动产，以至于武器、盔甲，典当给商人维持生活。 江户时代的经济发展经济基础决定上层建筑，日本步入资本主义社会，离不开江户时代的经济积累和市场发展。 社会思潮的演变参考阅读一些本人研究该课题的参考书目： 日本的近代化——与中国的比较 【日】依田憙家 （较为成体系地论述了日本各领域的近代化，推荐阅读） 黑船来航 【日】三谷博 （关于日本开国前后的一些讨论） 日俄战争：起源和开战【日】和田春树 日本陆军史：近代化的异化 【日】户部良一 （对旧日本帝国陆军的综述性讨论） 菊花与锚 刘怡、阎京生 （对旧日本帝国海军的兴亡史的全面总结，其中不乏对政治格局和历史背景的讨论） 1. 赤穗事件维基百科 &#8617; 2. 新编日本近代史 宋成有 &#8617;]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[施图姆-刘维尔的一些研究]]></title>
    <url>%2F2022%2F02%2F26%2FStorm_liouville_equation_researches%2F</url>
    <content type="text"><![CDATA[简介我们知道，任何二阶线性常微分方程都可以化为施图姆-刘维尔方程： \frac {\rm d} {\rm dx} \left [p(x)\frac {\rm dy} {\rm dx} \right] + q(x)y+\lambda \rho(x) y = 0鉴于一般的施图姆-刘维尔理论没什么意思，因为我不会，我们来看一些特殊情况。 （不想写，摸了）]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>数学物理方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复健计划第一弹：mathjax]]></title>
    <url>%2F2022%2F02%2F25%2Fmathjax_learning%2F</url>
    <content type="text"><![CDATA[我回来辣（大声） 断网三年了，常用工具都忘得差不多了，接下来的文章是个人复习的笔记，所以取个名叫“复健”。 基本语法 $...$代表行内引用，$$...$$代表行外引用。 ^ _为上下标，{}用于分组举例: 12sample $C_&#123;a&#125;^b$ sample$$C_&#123;a&#125;^&#123;b&#125;$$ sample $C_{a}^b$ sample C_{a}^{b}常用字符 注意在任意字符前添加\not即可添加不等符号。 字符 含义 效果 \gamma \Gamma \varGamma 希腊字母 $\gamma$ $\Gamma$ $\varGamma$ \vec {a} 矢量 $\vec {a}$ \overline {a} 上划线 $\overline {a}$ \underline {a} 下划线 $\underline {a}$ \hat {a} ^ $\hat {a}$ a \ a 空格 $a \ a$ \langle \rangle 尖括号 $\langle \rangle$ \vert \vert 绝对值 $\vert \vert$ \Vert \Vert 双竖线 $\Vert \Vert$ \frac {a} {b} 分数线 $\frac {a} {b}$ \times \div \pm \mp \cdot \bigotimes 各种算符 $\times \div \pm \mp \cdot \bigotimes$ \leq \geq \approx \not = \equiv 关系 $\leq \geq \approx \not= \equiv$ \in \subset \subseteq \cap \cup \varnothing 集合 $\in \subset \subseteq \cap \cup \varnothing$ \overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0} 上下括号 $\overbrace{a+\underbrace{b+c}_{1}+d}^{2}$ \ldots \partial \rightarrow \Rightarrow 符号 $\ldots \ \partial \rightarrow \ \Rightarrow$ \lim{x\to\infty} \sum{i=1}^N \int_a^b 符号 $\lim{x\to\infty} \sum{i=1}^N \int_a^b$ \nabla \infty \forall \exists \triangle 符号 $\nabla \infty \forall \exists \triangle$ 特殊结构通用规则 起始/结束标记\begin{name} \end{name} 换行\\ 元素分隔符&amp; 矩阵常用的关键字有：无框matrix,小括号pmatrix,中括号bmatrix，单竖线（也就是行列式）vmatrix。如12345$$\begin&#123;bmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;bmatrix&#125;$$ \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \\ \end{bmatrix}在省略元素时，可以用： 横省略号：\cdots 竖省略号：\vdots 斜省略号：\ddots 如123456$$\begin&#123;bmatrix&#125;a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; \cdots &amp; a_&#123;1n&#125; \\a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; \cdots &amp; a_&#123;2n&#125; \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_&#123;n1&#125; &amp; a_&#123;n2&#125; &amp; \cdots &amp; a_&#123;nn&#125; \\\end&#123;bmatrix&#125;$$ \begin{bmatrix} a_{11} & a_{12} & \cdots & a_{1n} \\ a_{21} & a_{22} & \cdots & a_{2n} \\ \vdots & \vdots & \ddots & \vdots \\ a_{n1} & a_{n2} & \cdots & a_{nn} \\ \end{bmatrix}方程组 关键词cases 如1234$$\begin&#123;cases&#125;a_1x+b_1y=c_1 \\a_2x+b_2y=c_2 \\\end&#123;cases&#125;$$ \begin{cases} a_1x+b_1y=c_1 \\ a_2x+b_2y=c_2 \\ \end{cases}连等式 注意把我们期望对齐的符号前加&amp;即可。 1234$$\begin&#123;align&#125;C &amp;= a \\ &amp;= b\end&#123;align&#125;$$ \begin{align} C &= a \\ &= b \end{align}]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSP 2019 游记]]></title>
    <url>%2F2019%2F11%2F17%2Fcsp_2019%2F</url>
    <content type="text"><![CDATA[NOIP CSP 2019 游记 Day -n to Day -1停课，每天一场模拟赛，发现我还是太菜了，日常被全机房吊打。 Day 0今天考了一场所谓信心赛（自闭赛），然后是喜闻乐见的CS1.6环节。（传统艺能） 晚上机房毒奶 LLouver 奶了一口今年考DP，看来不用复习DP了（逃 （然而还是考了DP，被爆踩了） Day 1T1一眼切了，就注意一下unsigned long long最大为 $2^{64} - 1$，读入之后如果k++会炸。 T2脑子抽了，直接写的 $n ^ 2$ 暴力，还是太菜了。 T3考虑菊花图，做了1个多小时之后发现讨论的情况太多了，自闭。 期望得分:100 + 50 + 0 = 150pts luogu数据:100 + 90 + 0 = 190pts Day 2开考先看了一遍题，发现没一道题可做，T2，T3暴力比较好打，先开T2，T3。 T2设dp[i][j]为上一次划分点在 $j$，这次在 $i$，暴力转移即可。 T3考虑链的情况，长为奇数时，可以得到 $ans$ 为所有编号之和加开头，结尾，中间点的编号。然后考虑 $n^2$ 暴力删边，获得40pts的好成绩QAQ 然后我猜完美二叉树的情况应该比较可做，（然后找了一个小时的规律，并不会） 最后开T1的时候只有20$min$了，不想写暴力，特判n = 2的情况滚粗。 期望得分:8 + 36 + 55 = 99pts luogu数据:8 + 48 + 55 = 111pts Conclusion首先吐槽一下你谷数据忒水了点吧，(居然上300pts了QAQ)，然后喷一下神奇的题目顺序和难度曲线，CCF:非专业级比专业级更简单 然后好像每道题打的都是暴力。 果然菜是原罪，退役了，再见。]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种模版]]></title>
    <url>%2F2019%2F08%2F15%2Fstd%2F</url>
    <content type="text"><![CDATA[原文地址搬给自己看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598159916001601160216031604160516061607160816091610161116121613161416151616161716181619162016211622162316241625162616271628162916301631163216331634163516361637163816391640164116421643164416451646164716481649165016511652165316541655165616571658165916601661166216631664166516661667166816691670167116721673167416751676167716781679168016811682168316841685168616871688168916901691169216931694169516961697169816991700170117021703170417051706170717081709171017111712171317141715171617171718171917201721172217231724172517261727172817291730173117321733173417351736173717381739174017411742174317441745174617471748174917501751175217531754175517561757175817591760176117621763176417651766176717681769177017711772177317741775177617771778177917801781178217831784178517861787178817891790179117921793179417951796179717981799180018011802180318041805180618071808180918101811181218131814181518161817181818191820182118221823182418251826182718281829183018311832183318341835183618371838183918401841184218431844184518461847184818491850185118521853185418551856185718581859186018611862186318641865186618671868186918701871187218731874187518761877187818791880188118821883188418851886188718881889189018911892189318941895189618971898189919001901190219031904190519061907190819091910191119121913191419151916191719181919192019211922192319241925192619271928192919301931193219331934193519361937193819391940194119421943194419451946194719481949195019511952195319541955195619571958195919601961196219631964196519661967196819691970197119721973197419751976197719781979198019811982198319841985198619871988198919901991199219931994199519961997199819992000200120022003200420052006200720082009201020112012201320142015201620172018#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;deque&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;tr1/unordered_map&gt;using namespace std;#define ri register int#define ull unsigned long long#define uint unsigned int#define bs bitset&lt;N&gt;typedef long long LL;namespace wjr&#123; const int mod=998244353,inv2=499122177,inf=1&lt;&lt;30; inline int mul(ri a,ri b)&#123;return a*1ll*b%mod;&#125; inline int add(ri a,ri b)&#123;return a+=b,a&gt;=mod?a-mod:a;&#125; inline int del(ri a,ri b)&#123;return a-=b,a&lt;0?a+mod:a;&#125; inline int qpow(ri a,ri b)&#123;ri s=1;for(;b;b&gt;&gt;=1,a=mul(a,a))if(b&amp;1)s=mul(s,a);return s;&#125; template&lt;typename T&gt; inline T sqr(register T x)&#123;return x*x;&#125;&#125;using namespace wjr;//* --- 目录 --- *///*--- 36-520 数学、快速变换等 ---*//*--- 522-585反演、杜教筛、Min_25筛 ---*//*--- 587-839 字符串 ---*//*--- 841-1140 图论 ---*//*--- 1142-1376 网络流 ---*//*--- - 随机化*/ /*--- 1378-1782 数据结构 ---*/ /*--- 1784-1813 BM算法*//*--- - 计算几何*/ /*---快速沃尔什变换*/namespace FWT&#123; inline void FWT_and(ri*a,ri n,ri p)&#123; ri step,s,i,j; for(step=1,s=2;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1) for(i=0;i&lt;n;i+=s) for(j=i;j&lt;i+step;++j) a[j]=~p?add(a[j],a[j+step]):del(a[j],a[j+step]); &#125;inline void FWT_or(ri*a,ri n,ri p)&#123; ri step,s,i,j; for(step=1,s=2;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1) for(i=0;i&lt;n;i+=s) for(j=i;j&lt;i+step;++j) a[j+step]=~p?add(a[j+step],a[j]):del(a[j+step],a[j]); &#125;inline void FWT_xor(ri*a,ri n,ri p)&#123; ri step,s,i,j,x; for(step=1,s=2;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1) for(i=0;i&lt;n;i+=s) for(j=i;j&lt;i+step;++j)&#123; x=a[j]; a[j]=add(a[j],a[j+step]); a[j+step]=del(x,a[j+step]); if(~p)continue; a[j]=mul(a[j],inv2); a[j+step]=mul(a[j+step],inv2); &#125; &#125;&#125;/*---快速子集变换*/namespace FST&#123; const int N=1&lt;&lt;15; inline void work(ri a[][N],ri b[][N],ri c[][N],ri n)&#123;/*---c[x][|x|]即为原来要求的dp[x]*/ ri lim=1&lt;&lt;n; for(ri i=1;i&lt;=n;++i)FWT::FWT_or(a[i],lim,1),FWT::FWT_or(b[i],lim,1); for(ri i=1;i&lt;=n;++i) for(ri j=1;j&lt;=i;++j) for(ri k=0;k&lt;=lim;++k) c[i][k]=add(c[i][k],mul(a[i-j][k],b[j][k])); for(ri i=1;i&lt;=n;++i)FWT::FWT_or(c[i],lim,-1); &#125;inline void work(ri a[][N],ri b[][N],ri n)&#123; ri lim=1&lt;&lt;n; for(ri i=1;i&lt;=n;++i)FWT::FWT_or(b[i],lim,1); a[0][0]=1,FWT::FWT_or(a[0],lim,1); for(ri i=1;i&lt;=n;++i) for(ri j=1;j&lt;=i;++j) for(ri k=0;k&lt;=lim;++k) a[i][k]=add(a[i][k],mul(a[i-j][k],b[j][k])); for(ri i=1;i&lt;=n;++i)FWT::FWT_or(a[i],lim,-1); &#125;&#125;/*---多项式 - NTT */namespace Poly_NTT&#123; const int N=1&lt;&lt;15; int g[25],gi[25],rev[N],INV[N|1]; inline void init(ri n)&#123;/*---初始化*/ ri bit=1; while((1&lt;&lt;bit)&lt;(n&lt;&lt;1))++bit; ri I=qpow(3,mod-2); for(ri i=1;i&lt;=bit;++i)g[i]=qpow(3,(mod-1)&gt;&gt;i),gi[i]=qpow(I,(mod-1)&gt;&gt;i); INV[0]=INV[1]=1;for(ri i=2;i&lt;=(1&lt;&lt;bit);++i)INV[i]=mul(INV[mod%i],mod-mod/i); &#125;inline void NTT(ri*a,ri n,ri p)&#123; ri i,j,step,s,enk,wn,x,now; for(i=0;i&lt;n;++i)if(i&lt;rev[i])swap(a[i],a[rev[i]]); for(step=1,s=2,now=1;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1,++now)&#123; wn=~p?g[now]:gi[now]; for(i=0;i&lt;n;i+=s)&#123; enk=1; for(j=i;j&lt;i+step;++j)&#123; x=mul(enk,a[j+step]); a[j+step]=del(a[j],x); a[j]=add(a[j],x); enk=mul(enk,wn); &#125; &#125; &#125;if(~p)return; for(i=0;i&lt;n;++i)a[i]=mul(a[i],INV[n]); &#125;inline void get_rev(ri s)&#123;ri Maxn=1&lt;&lt;s;for(ri i=0;i&lt;Maxn;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(s-1));&#125; inline void Mul(ri*a,ri n,ri*b,ri m)&#123;/*---多项式乘法*/ static int A[N],B[N]; ri i,bit,s,len;len=n+m-1; bit=1,s=2; while(s&lt;len)++bit,s&lt;&lt;=1; get_rev(bit); memcpy(A,a,n&lt;&lt;2),memset(A+n,0,(s-n)&lt;&lt;2); memcpy(B,b,m&lt;&lt;2),memset(B+m,0,(s-m)&lt;&lt;2); NTT(A,s,1),NTT(B,s,1); for(i=0;i&lt;s;++i)A[i]=mul(A[i],B[i]); NTT(A,s,-1);memcpy(a,A,len&lt;&lt;2); &#125;inline void Inv(ri*a,ri n)&#123;/*---多项式逆元*/ static int A[N],B[N],s,i,j,k,now; s=2;while(s&lt;n)s&lt;&lt;=1; memset(a+n,0,(s-n)&lt;&lt;2); memset(B,0,s&lt;&lt;3); B[0]=a[0]&lt;=N?INV[a[0]]:qpow(a[0],mod-2); for(i=2,j=4,now=2;i&lt;=s;i&lt;&lt;=1,j&lt;&lt;=1,++now)&#123; memcpy(A,a,i&lt;&lt;2),memset(A+i,0,i&lt;&lt;2); get_rev(now); NTT(A,j,1),NTT(B,j,1); for(k=0;k&lt;j;++k)B[k]=mul(B[k],del(2,mul(A[k],B[k]))); NTT(B,j,-1),memset(B+i,0,i&lt;&lt;2); &#125;memcpy(a,B,n&lt;&lt;2); &#125;inline void deriv(ri*a,ri n)&#123;/*---求导函数*/ for(ri i=0;i&lt;n;++i)a[i]=mul(a[i+1],i+1);a[n-1]=0; &#125;inline void intag(ri*a,ri n)&#123;/*---求原函数*/ for(ri i=n-1;i;--i)a[i]=mul(a[i-1],INV[i]);a[0]=0; &#125;inline void Ln(ri*a,ri n)&#123;/*---对数函数*/ static int A[N]; memcpy(A,a,n&lt;&lt;2),Inv(A,n); deriv(a,n), Mul(a,n,A,n); intag(a,n),memset(a+n,0,(n-1)&lt;&lt;2); &#125;inline void Exp(ri*a,ri n)&#123;/*---指数函数*/ static int A[N],B[N],i,j,k,now,s; s=2;while(s&lt;n)s&lt;&lt;=1; memset(a+n,0,(s-n)&lt;&lt;2); memset(B,0,s&lt;&lt;3); B[0]=1; for(i=2,j=4,now=2;i&lt;=s;i&lt;&lt;=1,j&lt;&lt;=1,++now)&#123; memcpy(A,B,i&lt;&lt;2),memset(A+i,0,i&lt;&lt;2); Ln(A,i);for(k=0;k&lt;i;++k)A[k]=del(a[k],A[k]); A[0]=add(A[0],1),get_rev(now); NTT(A,j,1),NTT(B,j,1); for(k=0;k&lt;j;++k)B[k]=mul(B[k],A[k]); NTT(B,j,-1),memset(B+i,0,i&lt;&lt;2); &#125;memcpy(a,B,n&lt;&lt;2); &#125;inline void Ksm(ri*a,ri n,ri k)&#123;/*---快速幂*/ ri t,p,inv; t=0;while(!a[t]&amp;&amp;t&lt;n)++t; if(t&gt;=n)return; p=a[t],inv=p&lt;=N?INV[p]:qpow(p,mod-2); for(ri i=0;i&lt;n-t;++i)a[i]=mul(a[i+t],inv); memset(a+n-t,0,t&lt;&lt;2); Ln(a,n); for(ri i=0;i&lt;n;++i)a[i]=mul(a[i],k); a[0]=0,Exp(a,n); for(ri i=n-1;i&gt;=t;--i) a[i]=mul(p,a[i-t]); memset(a,0,t&lt;&lt;2); &#125;inline void Div(ri*a,ri n,ri*b,ri m)&#123;/*---多项式除法+取模*/ static int F[N],G[N]; memcpy(F,a,(n+1)&lt;&lt;2),memcpy(G,b,(m+1)&lt;&lt;2); reverse(b,b+1+m),reverse(F,F+1+n); for(ri i=n-m+1;i&lt;=m;++i)b[i]=0; Inv(b,n-m+1); for(ri i=n-m+1;i&lt;=n;++i)F[i]=0; Mul(F,n-m+1,b,n-m+1); reverse(F,F+n-m+1); for(ri i=n-m+1;i&lt;=n;++i)F[i]=0; Mul(G,m+1,F,n-m+1); for(ri i=0;i&lt;m;++i)b[i]=del(a[i],G[i]); memcpy(a,F,n&lt;&lt;2); &#125;inline void Sqrt(ri*a,ri n)&#123;//多项式开根 static int A[N],B[N]; ri s,i,j,k,now; s=2;while(s&lt;n)s&lt;&lt;=1; memset(a+n,0,(s-n)&lt;&lt;2),memset(B,0,s&lt;&lt;3); B[0]=1; for(i=2,j=4,now=2;i&lt;=s;i&lt;&lt;=1,j&lt;&lt;=1,++now)&#123; memcpy(A,B,i&lt;&lt;2),memset(A+i,0,i&lt;&lt;2); for(k=0;k&lt;i;++k)A[k]=mul(A[k],2); Inv(A,i); get_rev(now-1); NTT(B,i,1); for(k=0;k&lt;i;++k)B[k]=mul(B[k],B[k]); NTT(B,i,-1); for(k=0;k&lt;i;++k)B[k]=add(B[k],a[k]); get_rev(now); NTT(B,j,1),NTT(A,j,1); for(k=0;k&lt;j;++k)B[k]=mul(B[k],A[k]); NTT(B,j,-1),memset(B+i,0,i&lt;&lt;2); &#125;memcpy(a,B,n&lt;&lt;2); &#125;&#125;/*---多项式 - FFT*/namespace Ploy_FFT&#123; const int N=1&lt;&lt;18,zw=(1&lt;&lt;15)-1; const double PI=acos(-1); int rev[N]; struct cd&#123; double x,y; cd(double a=0,double b=0)&#123;x=a,y=b;&#125; &#125;w[18][N]; inline cd operator+(cd a,cd b)&#123;return cd(a.x+b.x,a.y+b.y);&#125; inline cd operator-(cd a,cd b)&#123;return cd(a.x-b.x,a.y-b.y);&#125; inline cd operator*(cd a,cd b)&#123;return cd(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125; inline cd operator*(cd a,ri b)&#123;return cd(a.x,a.y*b);&#125; inline void init(ri n)&#123; for(ri i=0,k=1,j;i&lt;=17;++i,k&lt;&lt;=1) for(j=0;j&lt;k;++j) w[i][j]=cd(cos(PI*j/k),sin(PI*j/k)); &#125;inline void get_rev(ri s)&#123;ri Maxn=1&lt;&lt;s;for(ri i=0;i&lt;Maxn;++i)rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(s-1));&#125; inline void FFT(register cd*a,ri n,ri p)&#123; ri step,s,i,j,now; cd x; for(i=0;i&lt;n;++i)if(i&lt;rev[i])swap(a[i],a[rev[i]]); for(step=1,s=2,now=0;step&lt;n;step&lt;&lt;=1,s&lt;&lt;=1,++now) for(i=0;i&lt;n;i+=s) for(j=i;j&lt;i+step;++j)&#123; x=a[j+step]*(w[now][j-i]*p); a[j+step]=a[j]-x; a[j]=a[j]+x; &#125; if(~p)return; for(i=0;i&lt;n;++i)a[i].x/=n; &#125;inline LL get(cd x,ri Mod)&#123;return LL(x.x+0.5)%Mod;&#125; int siz=sizeof(cd); const int pw=32767; inline void MTT(ri*a,ri*b,ri*c,ri n,ri m,ri Mod)&#123; static cd A[N],B[N],C[N],D[N],e[N],f[N],g[N],h[N]; ri i,s,len;len=n+m-1; s=2;while(s&lt;len)s&lt;&lt;=1; for(i=0;i&lt;s;++i)&#123; A[i]=cd(a[i]&gt;&gt;15,0),B[i]=cd(a[i]&amp;pw,0); C[i]=cd(b[i]&gt;&gt;15,0),D[i]=cd(b[i]&amp;pw,0); &#125;FFT(A,s,1),FFT(B,s,1),FFT(C,s,1),FFT(D,s,1); for(i=0;i&lt;s;++i)e[i]=A[i]*C[i],f[i]=A[i]*D[i],g[i]=B[i]*C[i],h[i]=B[i]*D[i]; FFT(e,s,-1),FFT(f,s,-1),FFT(g,s,-1),FFT(h,s,-1); for(i=0;i&lt;len;++i) c[i]=(((get(e[i],Mod)&lt;&lt;30)%Mod+(get(f[i],Mod)&lt;&lt;15)%Mod)%Mod+(get(g[i],Mod)&lt;&lt;15)%Mod+get(h[i],Mod)%Mod)%Mod; &#125;inline void MTT_2(ri*a,ri n,ri*b,ri m)&#123;//黑科技优化版本 static cd A[N],B[N],C[N],D[N]; ri len=n+m-1,s=2,i,t; register LL q,w,e,r; while(s&lt;len)s&lt;&lt;=1; for(i=0;i&lt;n;++i)A[i]=cd(a[i]&amp;zw,a[i]&gt;&gt;15); for(i=n;i&lt;s;++i)A[i]=cd(0,0); for(i=0;i&lt;m;++i)B[i]=cd(b[i]&amp;zw,b[i]&gt;&gt;15); for(i=m;i&lt;s;++i)B[i]=cd(0,0); FFT(A,s,1),FFT(B,s,1); for(i=0;i&lt;s;++i)&#123; t=(s-i)&amp;(s-1); C[i]=cd(0.5*(A[i].x+A[t].x),0.5*(A[i].y-A[t].y))*B[i]; D[i]=cd(0.5*(A[i].y+A[t].y),0.5*(A[t].x-A[i].x))*B[i]; &#125;FFT(C,s,-1),FFT(D,s,-1); for(i=0;i&lt;len;++i)&#123; q=LL(C[i].x+0.5)%mod,w=LL(C[i].y+0.5)%mod,e=LL(D[i].x+0.5)%mod,r=LL(D[i].y+0.5)%mod; a[i]=(q+((w+e)&lt;&lt;15)+(r&lt;&lt;30))%mod;// a[i]=(q+((w+e)&lt;&lt;15)+(r&lt;&lt;30))%mod+mod;// a[i]=a[i]&gt;=mod?a[i]-mod:a[i]; //此题没卡,一般是要写%mod+mod,然后再取模的。 &#125; &#125;&#125;/*---斯特林数*/namespace Stirling&#123; //暂时不想写 &#125;/*---BSGS*/namespace BSGS&#123; const int Hash=19260817,N=1e4+10; int d[Hash],nxt[N],to[N],id[N],tot; int stk[N],tail; inline int get(ri x)&#123;return (x*1ll*x)%Hash;&#125; inline void Insert(ri x,ri i)&#123; ri now=get(x); if(!d[now])stk[++tail]=d[now]; to[++tot]=x,nxt[tot]=d[now],d[now]=tot,id[tot]=i; &#125;inline int query(ri x)&#123; ri now=get(x); for(ri i=d[now];i;i=nxt[i]) if(to[i]==x)return id[i]; return -1; &#125;inline void init()&#123;while(tail)d[stk[tail--]]=0;tot=0;&#125; inline int qpow(ri a,ri b,ri p)&#123;ri s=1;for(;b;b&gt;&gt;=1,a=a*1ll*a%p)if(b&amp;1)s=s*1ll*a%p;return s;&#125; inline int BSGS(ri a,ri b,ri p)&#123;//求a^t ≡b (mod p) if(b==1)return 0; ri tmp=ceil(sqrt(p)); ri t=qpow(a,tmp,p),x=1; for(ri i=1;i&lt;=tmp;++i)&#123; x=x*1ll*t%p; Insert(x,i); &#125;x=1; for(ri i=0;i&lt;tmp;++i)&#123; t=query(x); if(~t)return t*tmp-i; x=x*1ll*a%p; &#125;return -1; &#125;&#125;/*---Matrix_Tree矩阵树*/namespace Matrix_tree&#123;//用于求解生成树个数 const int N=205; int a[N][N]; inline void ins(ri u,ri v)&#123;++a[u][u],++a[v][v],--a[u][v],--a[v][u];&#125; inline int Gauss(ri n)&#123;//如果是m*m矩阵,n=m-1,即忽略最后一行 ri ans=1,i,j,k,div,tmp; for(i=1;i&lt;=n;++i)&#123; k=i; for(j=i;j&lt;=n;++j) if(a[j][i])&#123;k=j;break;&#125; if(k!=i)ans=-ans,swap(a[i],a[k]); if(!a[i][i])return 0; ans=mul(ans,a[i][i]); div=qpow(a[i][i],mod-2); for(j=i+1;j&lt;=n;++j)&#123; if(!a[j][i])continue; tmp=mul(div,a[j][i]); for(k=i;k&lt;=n;++k) a[j][k]=del(a[j][k],mul(tmp,a[i][k])); &#125; &#125;return ans&lt;0?ans+mod:ans; &#125;&#125;/*---中国剩余定理*/ namespace EXCRT&#123; const int N=1e4+10; const double eps=1e-2; typedef long long LL; struct node&#123; LL a[N],b[N]; LL ans,M; &#125;; LL x,y; inline LL exgcd(LL a,LL b,LL&amp;x,LL&amp;y)&#123; if(!b)&#123;x=1,y=0;return a;&#125; LL g=exgcd(b,a%b,y,x); y-=(a/b)*x; return g; &#125;inline LL Mul(LL a,LL b,LL p)&#123; LL d=((long double)a/p*b+eps); LL r=a*b-p*d; return r&lt;0?r+p:r; &#125;inline LL Del(LL a,LL b,LL p)&#123;return a-=b,a&lt;0?a+p:a;&#125; inline void Excrt(node&amp;a,ri n)&#123; a.ans=a.a[1],a.M=a.b[1]; LL c,g,p; for(ri i=2;i&lt;=n;++i)&#123;//a.ans+x*a.M≡a.a[i](mod a.b[i]) c=Del(a.a[i],a.ans,a.b[i]);//x*a.M≡a.a[i]-a.ans(mod a.b[i]) g=exgcd(a.M,a.b[i],x,y); p=a.b[i]/g; if(c%g!=0)&#123;a.ans=-1;return;&#125; x=Mul(x,c/g,p); a.ans+=x*a.M; a.M*=p; a.ans=(a.ans%a.M+a.M)%a.M; &#125; &#125;&#125;/*---高斯消元*/ namespace Gauss&#123; const int M=205; struct Matrix&#123; int a[M][M]; int ans[M];//为了方便起见才将ans放里面 &#125;; inline void Gauss(Matrix&amp;a,ri n)&#123;//n行、n+1列 ri i,j,k,t; for(i=1;i&lt;=n;++i)&#123; k=i; for(j=i;j&lt;=n;++j) if(a.a[j][i])&#123;k=j;break;&#125; if(i!=k)swap(a.a[k],a.a[i]); t=qpow(a.a[i][i],mod-2); for(k=i;k&lt;=n+1;++k)a.a[i][k]=mul(a.a[i][k],t); for(j=i+1;j&lt;=n;++j)&#123; t=a.a[j][i]; for(k=i;k&lt;=n+1;++k) a.a[j][k]=del(a.a[j][k],mul(t,a.a[i][k])); &#125; &#125;a.ans[i]=a.a[n][n+1]; for(i=n-1;i;--i)&#123; a.ans[i]=a.a[i][n+1]; for(j=i+1;j&lt;=n;++j) a.ans[i]=del(a.ans[i],mul(a.a[i][j],a.ans[j])); &#125; &#125;&#125;/*---矩阵*/ namespace Matrix&#123; const int N=205; int n;//假定行列都是n struct Matrix&#123; int a[N][N]; &#125;; inline void init(Matrix&amp;a)&#123;/*---单位矩阵*/ for(ri i=0;i&lt;n;++i) memset(a.a[i],0,n&lt;&lt;2),a.a[i][i]=1; &#125;inline void operator*=(Matrix&amp;a,Matrix b)&#123; static Matrix c; memset(&amp;c,0,sizeof(c)); ri i,j,k; for(i=0;i&lt;n;++i) for(k=0;k&lt;n;++k) if(a.a[i][k]) for(j=0;j&lt;n;++j) c.a[i][j]=add(c.a[i][j],mul(a.a[i][k],b.a[k][j])); memcpy(&amp;a,&amp;c,sizeof(a)); &#125;inline Matrix operator*(Matrix a,Matrix b)&#123; static Matrix c; memset(&amp;c,0,sizeof(c)); ri i,j,k; for(i=0;i&lt;n;++i) for(k=0;k&lt;n;++k) if(a.a[i][k]) for(j=0;j&lt;n;++j) c.a[i][j]=add(c.a[i][j],mul(a.a[i][k],b.a[k][j])); return c; &#125;using namespace Poly_NTT;//需要用到多项式 inline void my_Div(ri*a,ri n,ri*b,ri m)&#123;//配合常系数线性齐次递推 static int F[N],G[N]; memcpy(F,a,(n+1)&lt;&lt;2),memcpy(G,b,(m+1)&lt;&lt;2); reverse(G,G+m+1),reverse(F,F+n+1); for(ri i=n-m+1;i&lt;=m;++i)G[i]=0; Inv(G,n-m+1); for(ri i=n-m+1;i&lt;=n;++i)F[i]=0; Mul(F,n-m+1,G,n-m+1); reverse(F,F+n-m+1); for(ri i=n-m+1;i&lt;=n;++i)F[i]=0; memcpy(G,b,(m+1)&lt;&lt;2); Mul(G,m+1,F,n-m+1); for(ri i=0;i&lt;m;++i)a[i]=del(a[i],G[i]); memset(a+m,0,(n-m+1)&lt;&lt;2); &#125;inline void Multi(ri*a,ri*mod,ri*ans,ri n,ri k)&#123;/*---常系数线性齐次递推 */ memset(&amp;ans,0,sizeof(ans)); ans[0]=1; while(k)&#123; if(k&amp;1)&#123; Mul(ans,n,a,n); my_Div(ans,2*n-2,mod,n); &#125;Mul(a,n,a,n); my_Div(a,2*n-2,mod,n); k&gt;&gt;=1; &#125; &#125;inline int Inv(Matrix a,Matrix&amp;b)&#123;/*---矩阵求逆*/ //用b存inv(a) init(b); ri i,j,k,t; for(i=0;i&lt;n;++i)&#123; for(j=i;j&lt;n;++j) if(a.a[j][i])&#123; swap(a.a[i],a.a[j]),swap(b.a[i],b.a[j]); break; &#125; if(!a.a[i][i])return -1; t=qpow(a.a[i][i],mod-2); for(j=i;j&lt;n;++j)a.a[i][j]=mul(a.a[i][j],t),b.a[i][j]=mul(b.a[i][j],t); for(j=i+1;j&lt;n;++j)&#123; t=a.a[j][i]; for(k=i;j&lt;n;++k) b.a[j][k]=del(b.a[j][k],mul(t,b.a[i][k])),a.a[j][k]=del(a.a[j][k],mul(t,a.a[i][k])); &#125; &#125; &#125;&#125;/*---自适应性辛普森*/namespace Simpson&#123; double a; inline double f(double x)&#123;return pow(x,a/x-x);&#125;//返回函数值 inline double Simpson(double L,double R)&#123;return (R-L)*(f(R)+4*f((L+R)/2)+f(L))/6;&#125; inline double ars(double L,double R,double A,double eps)&#123; double mid=(L+R)/2; double ls=Simpson(L,mid),rs=Simpson(mid,R); if(fabs(ls+rs-A)&lt;15*eps)return ls+rs+(ls+rs-A)/15; return ars(L,mid,ls,eps/2)+ars(mid,R,rs,eps/2); &#125; &#125; /*---线性基*/namespace Linear_basis&#123; const int N=1005; bs a[66]; inline int Insert(bs x)&#123; for(ri i=60;~i;--i) if(x[i])&#123; if(a[i]!=0)x^=a[i]; else &#123;a[i]=x;return 1;&#125;//秩++ &#125; return 0; &#125;inline bs query(bs x)&#123;//可以异或得到的最大 for(ri i=60;~i;--i) if(!x[i]&amp;&amp;a[i]!=0) x^=a[i]; return x; &#125;&#125;/*---杜教筛*/ namespace DJS&#123; //求S(n)=\sum_&#123;i=1&#125;^&#123;n&#125;f(i),h=f*g(*为卷积运算),则有g(1)S(n)=\sum_&#123;i=1&#125;^&#123;n&#125;h(i)-\sum_&#123;i=2&#125;^&#123;n&#125;g(i)S(n/i) //这里以求\mu为例,\mu*1=元函数 const int N=1e6+10; using namespace std::tr1; int sum[N]; unordered_map&lt;int,int&gt;q;//最好是手写hash inline int S(ri n)&#123; if(n&lt;N)return sum[n]; if(q[n])return q[n]; ri ans=1,i,j; j=sqrt(n); for(i=2;i&lt;=j;++i) ans-=S(n/i); for(;i&lt;=n;i=j+1)&#123; j=n/(n/i); ans-=(j-i+1)*S(n/i); &#125;return q[n]=ans; &#125;&#125;/*---莫比乌斯反演(只是一个整除分块没什么好写的)*//*---Min_25筛*/namespace Min_25&#123;//这里以简单的函数LOJ 5063为例 const int N=1e4+10; int n,m,lim,cnt,prime[N],w[N],s[N],c[N]; bool no[N]; inline int id(ri x)&#123;return x&lt;=lim?x:m-(n/x)+1;&#125; inline int f(ri x,ri c)&#123;return x^c;&#125;//返回f(x的c次方)(那题f(x^(次方)c)=x^(异或)c) inline int g(ri x)&#123;return x;&#125; inline int h(ri x)&#123;return 1;&#125; inline int S(register LL n,ri k)&#123;//\sum_&#123;i=1&#125;^n f(i)*[i\in prime or min_i&gt;=prime[k]] if(n&lt;=1||n&lt;prime[k])return 0;//递归版本 ri i,c;register LL j; ri ans=del(s[id(n)],s[prime[k-1]]);//先算出prime的贡献 for(i=k;i&lt;=cnt&amp;&amp;prime[i]*1ll*prime[i]&lt;=n;++i) for(j=n,c=1;(j/=prime[i])&gt;=prime[i];++c) ans=add(ans,add(mul(f(prime[i],c),S(j,i+1)),f(prime[i],c+1))); //不会统计到因子全是p_i的,所以直接加上 return ans; &#125;inline void pre(ri*F)&#123;//非递归版本 //\sum f(prime_&#123;b&#125;^&#123;i&#125;)*(S(n/prime_&#123;b&#125;^&#123;i&#125;,b+1)-g(prime_&#123;b&#125;)+f(prime_&#123;b&#125;^&#123;i+1&#125;)) ri i,j,tmp; for(i=cnt;i;--i) for(j=m;w[j]&gt;=i*i;--j) for(tmp=w[j];(tmp/=prime[i])&gt;=prime[i];) F[j]+=(f(prime[i],i)*(F[id(tmp)]-s[prime[i]])+f(prime[i],i+1)); &#125;inline void init(register LL n)&#123;m=cnt=0; lim=sqrt(n); for(register LL i=1,j;i&lt;=n;i=j+1)&#123; w[++m]=j=n/(n/i); s[m]=del(mul(j%mod,(j+1)%mod),1),c[m]=(j-1)%mod;//代表筛第0轮的初始值 &#125;//g(n,i)筛了i轮后1-n中所有质数的f之和 for(ri i=2,j,t;i&lt;=lim;++i)&#123; if(c[i]==c[i-1])continue;//如果不是质数,可以线性筛预处理也可以利用c数组 prime[++cnt]=i; for(j=m;w[j]&gt;=i*i;--j) s[j]=del(s[j],mul(g(i),del(s[t=id(w[j]/i)],s[i-1]))),//g(x)=x,1-n指数和 c[j]=del(c[j],mul(h(i),del(c[t],c[i-1])));//g(x)=1,1-n质数个数 &#125;for(ri i=2;i&lt;=m;++i)s[i]=del(s[i],del(c[i],2)); &#125;&#125;/*---AC自动机*/namespace ACM&#123; const int N=1e4+10; int ch[N][26],nxt[N]; queue&lt;int&gt;q; int now,cnt; inline void Insert(register char*s)&#123; ri len=strlen(s+1),c; now=1; for(ri i=1;i&lt;=len;++i)&#123; c=s[i]-&apos;a&apos;; if(!ch[now][c])ch[now][c]=++cnt; now=ch[now][c]; &#125; /* is_end[now]=1; or ++siz[now]; or else */ &#125;inline void build()&#123; ri i,u,x; for(i=0;i&lt;26;++i)ch[0][i]=1; nxt[1]=0,q.push(1); while(!q.empty())&#123; x=q.front(); q.pop(); for(i=0;i&lt;26;++i)&#123; u=ch[x][i]; if(!u)ch[x][i]=ch[nxt[x]][i]; else&#123; q.push(u); nxt[u]=ch[nxt[x]][i]; &#125; &#125; &#125; &#125;&#125;/*---Hash of string字符串hash*/namespace hash_of_string&#123; const int N=1e5+10,bas=237;//N,bas自定义 ull pw[N]; inline void init(ri n)&#123;pw[0]=1;for(ri i=1;i&lt;n;++i)pw[i]=pw[i-1]*bas;&#125; inline void hash(register char*s,register ull*a,ri n)&#123; for(ri i=1;i&lt;=n;++i) a[i]=a[i-1]*bas+(s[i]-&apos;a&apos;); &#125;inline ull get_hash(ri L,ri R,register ull*a)&#123;return a[R]-pw[R-L+1]*a[L-1];&#125;&#125;/*--- Hash of num or else */namespace hash_of_else&#123;//以二维坐标为例 const int Hash=19260817,N=1e4+10,bas=998244353; struct node&#123; int x,y; &#125;; int d[Hash],nxt[N],tot; node to[N]; LL val[N]; inline int get_hash(node x)&#123;return (x.x*1ll*bas+x.y)%Hash;&#125; inline bool operator==(node a,node b)&#123;return a.x==b.x&amp;&amp;a.y==b.y;&#125; inline void Insert(node x,LL v)&#123; ri now=get_hash(x); to[++tot]=x,nxt[now]=d[now],d[now]=++tot,val[tot]=v; &#125;inline LL find(node x)&#123; ri now=get_hash(x); for(ri i=d[now];i;i=nxt[i]) if(to[i]==x)return val[i]; return -1;//返回一个val不会出现的值 &#125;&#125;/*---KMP*/namespace KMP&#123; const int N=1e4+10; inline void get_nxt(register char*s,ri*nxt)&#123; ri n=strlen(s+1); for(ri i=2,j=0;i&lt;=n;++i)&#123; while(j&amp;&amp;s[j+1]!=s[i])j=nxt[j]; j+=s[j+1]==s[i]; nxt[i]=j; &#125; &#125;&#125;/*---马拉车算法,有了PAM还有学Manacher的必要吗(雾*/namespace Manacher&#123; inline void Manacher(register char*s,ri*rad,ri n)&#123; for(ri i=1,j=0,k;i&lt;n;i+=k)&#123; while(s[i-j-1]==s[i+j+1])++j; rad[i]=j; for(k=1;k&lt;=rad[i]&amp;&amp;rad[i-k]!=rad[i]-k;++k) rad[i+k]=min(rad[i-k],rad[i]-k); j=max(j-k,0); &#125; &#125;&#125;/*---trie树(没啥好写的)*/namespace trie_tree&#123;&#125;/*---后缀平衡树*/namespace suffix_balance_tree&#123; const double alpha=0.7; const int N=1e4+10; int ch[N][2],pos[N],a[N],siz[N],tail,rt; char s[N]; int fail_pos,fail_fa; double v[N],fail_ls,fail_rs; #define lc ch[x][0] #define rc ch[x][1] inline bool cmp(ri x,ri y)&#123;return (s[x]!=s[y])?s[x]&lt;s[y]:v[pos[x]]&lt;v[pos[y]];&#125;//pos代表上一个插入位置 inline int rebuild(ri L,ri R,register double ls,register double rs)&#123; if(L&gt;R)return 0; ri mid=(L+R)&gt;&gt;1,x=a[mid]; v[x]=(ls+rs)/2,siz[x]=R-L+1; lc=rebuild(L,mid-1,ls,v[x]),rc=rebuild(mid+1,R,v[x],rs); return x; &#125;inline void ck(ri x,ri k,register double ls,register double rs)&#123; if(siz[ch[x][k]]&gt;alpha*siz[x])fail_pos=x,fail_fa=-1,fail_ls=ls,fail_rs=rs; else if(ch[x][k]==fail_pos)fail_fa=x; &#125;inline void Insert(ri&amp;x,ri y,register double ls,register double rs)&#123; if(!x)&#123;x=y;v[x]=(ls+rs)/2;return;&#125; ++siz[x]; ri d=cmp(x,y); if(d)Insert(rc,y,(ls+rs)/2,rs); else Insert(lc,y,ls,(ls+rs)/2); ck(x,d,ls,rs); &#125;inline void recover(ri x)&#123;if(!x)return ;recover(lc),a[++tail]=x,recover(rc);&#125; inline void Insert(ri x)&#123; siz[x]=1,fail_pos=fail_fa=-1; Insert(rt,x,0,1); if(~fail_pos)&#123; tail=0; recover(fail_pos); ri T=rebuild(1,tail,fail_ls,fail_rs); if(~fail_fa)ch[fail_fa][ch[fail_fa][1]==fail_pos]=T; else rt=T; &#125; &#125; #undef lc #undef rc&#125; /*---SA后缀数组*/namespace SA&#123; const int N=1e4+10; int tax[N],sa[N],rk[N],tp[N]; int h[N],bit[N],s[30]; int n,m; int Min[N][19]; inline void init(ri n)&#123;//预处理 for(ri i=2;i&lt;=n;++i)bit[i]=bit[i&gt;&gt;1]+1; s[0]=1; for(ri i=1;i&lt;=bit[n];++i)s[i]=s[i-1]&lt;&lt;1; &#125;inline void qsort()&#123;ri i; memset(tax+1,0,m&lt;&lt;2); for(i=1;i&lt;=n;++i)++tax[rk[i]]; for(i=1;i&lt;=m;++i)tax[i]+=tax[i-1]; for(i=n;i;--i)sa[tax[rk[tp[i]]]--]=tp[i]; &#125;inline void suffix_sort(register char*s)&#123;ri i,j,p; n=strlen(s+1),m=26; for(i=1;i&lt;=n;++i)rk[i]=s[i]-&apos;a&apos;,tp[i]=i; qsort(); for(i=1,p=0;p&lt;n;m=p,i&lt;&lt;=1)&#123; p=0; for(j=1;j&lt;=i;++j)tp[++p]=n-i+j; for(j=1;j&lt;=n;++j)if(sa[j]&gt;i)tp[++p]=sa[j]-i; qsort(),swap(tp,rk); rk[sa[1]]=p=1; for(j=2;j&lt;=n;++j)rk[sa[j]]=(tp[sa[j]]==tp[sa[j-1]]&amp;&amp;tp[sa[j]+i]==tp[sa[j-1]+i])?p:++p; &#125; &#125;inline void work(register char*s)&#123; suffix_sort(s); ri i,j,k=0; for(i=1;i&lt;=n;++i)&#123; if(k)--k; j=sa[rk[i]-1]; while(s[i+k]==s[j+k])++k; h[rk[i]]=k; &#125;for(i=1;i&lt;=n;++i)Min[i][0]=h[i]; for(j=1;j&lt;=bit[n];++j)&#123; ri p=s[j-1],q=s[j]; for(i=1;i&lt;=n-q+1;++i) Min[i][j]=min(Min[i][j-1],Min[i+p][j-1]); &#125; &#125;&#125;/*---后缀自动机*/ namespace SAM&#123; const int N=1e4+10; int las,cnt,now,p,q,nq; int len[N&lt;&lt;1],ch[N&lt;&lt;1][26],fa[N&lt;&lt;1]; inline void init()&#123;las=cnt=1;&#125;//初始化 inline void Insert(ri c)&#123;/*---普通的SAM构造,广义的如果不涉及拓扑序可以每个串init后insert,否则要有特判*/ now=++cnt,p=las,len[now]=len[p]+1; while(p&amp;&amp;!ch[p][c])ch[p][c]=now,p=fa[p]; if(!p)fa[now]=1; else&#123; q=ch[p][c]; if(len[q]==len[p]+1)fa[now]=q; else&#123; nq=++cnt,len[nq]=len[p]+1; memcpy(ch[nq],ch[q],26&lt;&lt;2); /*---有的题目需要用LCT维护*/ fa[nq]=fa[q],fa[q]=fa[now]=nq; /*如若splay维护改成 fa[nq]=fa[q]; splay(q),New(nq,right[q]); link(nq,fa[nq]),cut(q,fa[q]); fa[q]=fa[now]=nq,New(q,right[q]); link(q,fa[q]); //New是fa改变或是新建节点或是copy节点更改LCT中节点的信息 */ while(p&amp;&amp;ch[p][c]==q)ch[p][c]=nq,p=fa[p]; &#125; &#125;/*---同样的如果是LCT维护还要处理now和fa[now]*/ /* New(now,1); LCT::link(now,fa[now]); LCT::access(now),LCT::splay(now); c=LCT::s[LCT::ch[now][0]]; LCT::pushr(LCT::ch[now][0],1); */ &#125;&#125;/*---回文自动机*/ namespace PAM&#123; const int N=1e4+10; struct node&#123; int ch[26],fa,len; &#125;prt[N]; char s[N]; int pos;//处理到的位置pos inline int get_fa(ri x)&#123;while(s[pos-1-prt[x].len]!=s[pos])x=prt[x].fa;return x;&#125; int las,cnt; inline void init()&#123;prt[0].fa=prt[1].fa=1,prt[1].len=-1,las=cnt=1;&#125;//初始化 inline int Insert(ri c)&#123;/*---构建回文自动机*/ ri p=get_fa(las),now; if(!prt[p].ch[c])&#123; now=++cnt; prt[now].len=prt[p].len+2; prt[now].fa=prt[get_fa(prt[p].fa)].ch[c]; prt[p].ch[c]=now; &#125;return las=prt[p].ch[c]; &#125;//可以用lca求出s串中两个回文串最长公共回文串 //亦或者可以快速求出以某个位置开头或者结尾的最长回文串 //也可以求出以每个位置为中心的最长回文串,Manacher哭了 &#125;/*---2-SAT*/namespace two_SAT&#123;//建图之后跑tarjan即可,貌似没什么可以写的？(雾 //令i是选i,i&apos;是不选i //i-&gt;j连边:选i就必选j //然后就根据题意建图 &#125;/*---Tarjan算法*/ namespace Tarjan&#123;//过于简单 const int N=1e4+10,M=3e4+10; int d[N],nxt[M&lt;&lt;1],to[M&lt;&lt;1],tot; int dfn[N],low[N],stk[N],tail,cnt; int id[N],cl; bool in[N]; inline void tarjan(ri x)&#123; dfn[x]=low[x]=++cnt; stk[++tail]=x,in[x]=1; for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(in[u])low[x]=min(low[x],dfn[u]); else if(!dfn[u])tarjan(u),low[x]=min(low[x],low[u]); &#125;if(low[x]==dfn[x])&#123; ri now; ++cl; do&#123; now=stk[tail--]; in[now]=0; id[now]=cl; &#125;while(now!=x); &#125; &#125;inline void work(ri n)&#123;for(ri i=1;i&lt;=n;++i)if(!dfn[i])tarjan(i);&#125;&#125;/*---斯坦纳树*/namespace Staineer_Tree&#123; const int N=1e4+10,M=1&lt;&lt;7,E=N&lt;&lt;2,inf=1&lt;&lt;27; int dp[N][M],d[N],nxt[E],to[E],cost[E],tot; bool in[N]; queue&lt;int&gt;q; inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,cost[tot]=c;&#125; inline void spfa(ri sta)&#123; ri i,x,u; while(!q.empty())&#123; x=q.front(),q.pop(); in[x]=1; for(i=d[x];i;i=nxt[i])&#123; u=to[i]; if(dp[u][sta]&gt;dp[x][sta]+cost[i])&#123;//以边权为例 dp[u][sta]=dp[x][sta]+cost[i]; if(!in[u])in[u]=1,q.push(u); &#125; &#125; &#125; &#125;inline void init()&#123;/*---一般是随机化每个点颜色,因题而异*/&#125; inline void solve(ri n,ri k)&#123; init();ri sta,s,i,lim; lim=k&lt;&lt;1; for(i=1;i&lt;=n;++i)memset(dp[i],0,lim&lt;&lt;2); for(sta=0;sta&lt;lim;++sta)&#123; for(i=1;i&lt;=n;++i)&#123; for(s=(sta-1)&amp;sta;s;s=(s-1)&amp;sta) dp[i][sta]=min(dp[i][sta],dp[i][s]+dp[i][s^sta]);//如果是点权还有减去v[i] /*dp[i][sta]=min(dp[i][sta],dp[i][s]+dp[i][s^sta]-v[i]);*/ if(dp[i][sta]&lt;inf)q.push(i); &#125;spfa(sta); &#125; &#125;&#125;/*---广义圆方树*/namespace YF_Tree&#123; const int N=1e4+10,M=4e4+10; struct node&#123; int d[N&lt;&lt;1],nxt[M],to[M],tot; inline void ins(ri a,ri b)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot;&#125; &#125;e,g;//e:原图,g:圆方树 int dfn[N],low[N]; int st[N],tail,cnt,cl;//cl初始为n,为方点编号。 inline void tarjan(ri x)&#123;/*---构建广义圆方树(不能用于仙人掌,可以用于一般图)*/ dfn[x]=low[x]=++cnt; st[++tail]=x; for(ri i=e.d[x];i;i=e.nxt[i])&#123; ri u=e.to[i]; if(!dfn[u])&#123; tarjan(u); low[x]=min(low[x],low[u]); if(low[u]==dfn[x])&#123; ++cl;//新建方点 ri now; do&#123; now=st[tail--]; g.ins(now,cl),g.ins(cl,now); &#125; while(now!=u); g.ins(cl,x),g.ins(x,cl); &#125; &#125;else low[x]=min(low[x],dfn[u]); &#125; &#125;&#125;/*---正规圆方树(处理仙人掌)*/namespace YF_Tree_2&#123; const int N=1e4+10,M=2e4+10; struct node&#123; int d[N&lt;&lt;1],nxt[M],to[M],cost[M],tot; inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot;&#125; &#125;e,g; int sum[N&lt;&lt;1],stk[N],dfn[N],low[N],tail,cnt,cl; inline void tarjan(ri x,ri fa)&#123; dfn[x]=low[x]=++cnt; stk[++tail]=x; for(ri i=e.d[x];i;i=e.nxt[i])&#123; ri u=e.to[i]; if(u==fa)continue; if(!dfn[u])&#123; sum[u]=sum[x]+e.cost[i]; tarjan(u,x); low[x]=min(low[x],low[u]); if(low[u]&gt;dfn[x])g.ins(x,u,e.cost[i]); &#125;else if(dfn[u]&lt;low[x])&#123; low[x]=dfn[u]; sum[++cl]=sum[x]+e.cost[i]-sum[u]; for(ri i=tail;stk[i]^u;--i)&#123; ri p=stk[i]; g.ins(cl,p,min(sum[p]-sum[u],sum[cl]-sum[p]+sum[u])); &#125;g.ins(u,cl,0); &#125; &#125;--tail; &#125;&#125;/*---树上倍增优化建图*/namespace unknown_name_1&#123;//通常是某个点和某条链连边或者两条树上的链连边 //这里以XR-1 逛森林 为例(因为我真的没做过其他树上倍增优化建图的题了) const int N=1e4+10,M=N*18; int fa[N][20],cid[N][20],rid[N][20]; int D[N],Nxt[N&lt;&lt;1],To[N&lt;&lt;1],Tot; int d[N],nxt[M],to[M],cost[M],tot; inline void ins(ri a,ri b)&#123;To[++Tot]=b,Nxt[Tot]=D[a],D[a]=Tot;&#125; int Log[N],dep[N],cnt; inline void link(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,cost[tot]=c;&#125; inline void init()&#123;for(ri i=2;i&lt;N;++i)Log[i]=Log[i&gt;&gt;1]+1;&#125; inline void clear(ri n)&#123; memset(D,0,sizeof(D)),memset(d,0,sizeof(d)); tot=Tot=0; cnt=n; &#125;inline void dfs(ri x)&#123;//预处理 cid[x][0]=rid[x][0]=x; ri i,u; for(i=1;i&lt;20;++i)//这样写可以不用初始化 fa[x][i]=fa[fa[x][i-1]][i-1]; for(i=1;i&lt;=Log[dep[x]-1];++i)&#123; cid[x][i]=++cnt; rid[x][i]=++cnt; link(cid[x][i-1],cid[x][i],0), link(cid[fa[x][i-1]][i-1],cid[x][i],0); link(rid[x][i],rid[x][i-1],0), link(rid[x][i],rid[fa[x][i-1]][i-1],0); &#125;for(i=D[x];i;i=Nxt[i])&#123; u=To[i]; if(u!=fa[x][0])&#123; fa[u][0]=x; dep[u]=dep[x]+1; dfs(u); &#125; &#125; &#125;inline int Lca(ri u,ri v)&#123; if(dep[u]&lt;dep[v])swap(u,v); while(dep[u]&gt;dep[v])u=fa[u][Log[dep[u]-dep[v]]]; if(u==v)return u; for(ri i=Log[dep[u]-1];~i;--i) if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i]; return fa[u][0]; &#125;inline int kfa(ri x,ri k)&#123;/*k-fa*/ ri z; while(k)&#123; z=k&amp;-k; x=fa[x][Log[z]]; k-=z; &#125;return x; &#125;inline void build(ri u,ri v,ri w,ri t)&#123;//将u-&gt;v(必须满足是祖先关系)和cnt连边,w为边权,t为种类,0/1:连向cnt/cnt连向链 ri c,p; p=Log[dep[u]-dep[v]+1]; c=kfa(u,dep[u]-dep[v]+1-(1&lt;&lt;p)); link(t?cnt:cid[u][p],t?rid[u][p]:cnt,w); if(c==u)return; link(t?cnt:cid[c][p],t?rid[c][p]:cnt,w); &#125;inline void work(ri u1,ri v1,ri u2,ri v2,ri w)&#123; ++cnt; ri p=Lca(u1,v1); if(dep[u1]&gt;dep[v1])swap(u1,v1); if(dep[u2]&gt;dep[v2])swap(u2,v2); if(u1!=p) build(u1,p,0,0); build(v1,p,0,0); p=Lca(u2,v2); if(u2!=p) build(u2,p,w,1); build(v2,p,w,1); &#125;&#125;/*---线段树优化建图*/namespace unknown_name_2&#123;&#125;/*---spfa(SLF+容错优化)*/namespace Spfa&#123; const int N=1e4+10,M=N&lt;&lt;1; int d[N],nxt[M],to[M],cost[M],tot; int dis[N],W,n,m; deque&lt;int&gt;q; bool in[N]; inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,cost[tot]=c,W+=abs(c);&#125; inline void init()&#123;W=pow(W/sqrt(m+1),2.0/3),W=W&lt;pow(m+1,1.0/3)?pow(m,1.0/3):W,W=W&gt;pow(m+1,2.0/3)?pow(m+1,2.0/3):W;&#125; inline void spfa(ri S)&#123; memset(dis,0x7f,sizeof(dis)); q.push_back(S),dis[S]=0; while(!q.empty())&#123; ri x=q.front(); q.pop_front(); in[x]=0; for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(dis[u]&gt;dis[x]+cost[i])&#123; dis[u]=dis[x]+cost[i]; if(!in[u])&#123; in[u]=1; if(!q.empty()&amp;&amp;dis[u]&gt;dis[*q.begin()]+W) q.push_back(u); else q.push_back(u); &#125; &#125; &#125; &#125; &#125;&#125;/*---dijkstra*/namespace Dijkstra&#123;//堆优化dijkstra,可以升级成线段树优化dijkstra const int N=1e5+10; struct node&#123; int id,dis; node(ri a=0,ri b=0)&#123;id=a,dis=b;&#125; bool operator &lt;(const node&amp;other)const&#123;return dis&gt;other.dis;&#125; &#125;; priority_queue&lt;node&gt;q; int d[N],nxt[N],to[N],cost[N],dis[N]; inline void dijkstra(ri S)&#123; memset(dis,0x3f,sizeof(dis)); q.push(node(S,0)),dis[S]=0; while(!q.empty())&#123; node x=q.top(); q.pop(); if(x.dis&gt;dis[x.id])continue; for(ri i=d[x.id];i;i=nxt[i])&#123; ri u=to[i]; if(dis[u]&gt;dis[x.id]+cost[i])&#123; dis[u]=dis[x.id]+cost[i]; q.push(node(u,dis[u])); &#125; &#125; &#125; &#125;&#125;/*---虚树*/namespace vtree&#123; const int N=1e5+10,M=N&lt;&lt;1; int dfn[N],stk[N],dep[N],top; int st[N],tp; int Min[M][20],bit[M],fir[N];//tarjan求LCA inline bool cmp(ri a,ri b)&#123;return dfn[a]&lt;dfn[b];&#125; #define compare(a,b) (dep[a]&lt;dep[b]?a:b) struct edge&#123; int d[N],nxt[M],to[M],tot;//假设原树无边权 inline void ins(ri a,ri b)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot;&#125; &#125;s,t; inline int lca(ri u,ri v)&#123; u=fir[u],v=fir[v]; if(u&gt;v)swap(u,v); ri p=bit[v-u+1]; return compare(Min[u][p],Min[v-(1&lt;&lt;p)+1][p]); &#125;inline void buildv(ri x)&#123; if(tp==1)&#123;st[++tp]=x;return;&#125; ri Lca=lca(x,st[tp]); while(tp&gt;1&amp;&amp;dep[st[tp-1]]&gt;=dep[Lca])t.ins(st[tp-1],st[tp]),--tp; if(Lca!=st[tp])t.ins(Lca,st[tp]),st[tp]=Lca; st[++tp]=x; &#125;inline void work()&#123; t.tot=0; sort(stk+1,stk+1+top,cmp); st[tp=1]=1; if(stk[1]!=1)buildv(stk[1]); for(ri i=2;i&lt;=top;++i)buildv(stk[i]); while(tp&gt;1)t.ins(st[tp-1],st[tp]),--tp;// Dp(1); &#125; #undef compare&#125; /*---Dinic*/namespace Dinic&#123; const int N=1e4+10,M=2e4+10; int d[N],nxt[M],to[M],flow[M],tot; int dep[N],cur[N]; int S,T;//源、汇 queue&lt;int&gt;q; int Maxflow; inline void init()&#123;memset(d,-1,sizeof(d)),tot=-1;&#125; inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,flow[tot]=c;&#125; inline void add(ri a,ri b,ri c)&#123;ins(a,b,c),ins(b,a,0);&#125; inline bool bfs()&#123; memset(dep,0,sizeof(dep)); memcpy(cur,d,sizeof(cur)); q.push(S),dep[S]=1; while(!q.empty())&#123; ri x=q.front(); q.pop(); for(ri i=d[x];~i;i=nxt[i])&#123; ri u=to[i]; if(!dep[u]&amp;&amp;flow[i]) dep[u]=dep[x]+1,q.push(u); &#125; &#125;return dep[T]!=0; &#125;inline int dfs(ri now,ri lim)&#123; if(now==T||!lim)&#123;Maxflow+=lim;return lim;&#125; int fl=0,f; for(ri i=cur[now];~i;i=nxt[i])&#123; ri u=to[i]; cur[now]=i; if(dep[u]==dep[now]+1&amp;&amp;(f=dfs(u,min(flow[i],lim))))&#123; flow[i]-=f,flow[i^1]+=f; fl+=f,lim-=f; if(!lim)break; &#125; &#125;return fl; &#125;inline int Dinic()&#123;Maxflow=0; while(bfs())&#123; while(dfs(S,inf)); &#125;return Maxflow; &#125;&#125;/*---ISAP*/namespace ISAP&#123; const int N=1e4+10,M=2e4+10; int d[N],nxt[M],to[M],flow[M],tot; int S,T; int cur[N],dep[N],num[N],pre[N]; queue&lt;int&gt;q; inline void init()&#123;memset(d,-1,sizeof(d)),tot=-1;&#125; inline void ins(ri a,ri b,ri c)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,flow[tot]=c;&#125; inline void add(ri a,ri b,ri c)&#123;ins(a,b,c),ins(b,a,0);&#125; inline bool bfs()&#123; memset(dep,0,sizeof(dep)); memset(num,0,sizeof(num)); memcpy(cur,d,sizeof(cur)); dep[T]=1,q.push(T); while(!q.empty())&#123; ri x=q.front(); q.pop(); ++num[dep[x]]; for(ri i=d[x];~i;i=nxt[i])&#123; ri u=to[i]; if(!dep[u]&amp;&amp;flow[i^1]) dep[u]=dep[x]+1,q.push(u); &#125; &#125;return dep[S]!=0; &#125;inline int add_flow()&#123; ri now=T,ans=inf; while(now!=S)ans=min(ans,flow[pre[now]]),now=to[pre[now]^1]; now=T; while(now!=S)flow[pre[now]]-=ans,flow[pre[now]^1]+=ans,now=to[pre[now]^1]; return ans; &#125;inline int ISAP()&#123; if(!bfs())return 0; ri Maxflow=0,now=S; while(233)&#123; if(now==T)&#123;Maxflow+=add_flow(),now=S;&#125; bool have_way=0; for(ri i=cur[now];~i;i=nxt[i])&#123; ri u=to[i]; if(flow[i]&amp;&amp;dep[u]+1==dep[now])&#123; pre[u]=i,have_way=1; cur[now]=i,now=u;break; &#125; &#125;if(!have_way)&#123; if(!--num[dep[now]])return Maxflow; ++num[++dep[now]]; cur[now]=d[now]; if(now!=S)now=to[pre[now]^1]; &#125; &#125;return Maxflow; &#125;&#125;/*---HLPP*/namespace HLPP&#123;//太难写了 &#125;/*---费用流(EK,Dinic,zkw)*/namespace cost_flow&#123;//以最小费用最大流为例 const int N=205,M=550; int d[N],nxt[M],to[M],flow[M],cost[M],tot; int dis[N],S,T; inline void ins(ri a,ri b,ri c,ri e)&#123;to[++tot]=b,nxt[tot]=d[a],d[a]=tot,flow[tot]=c,cost[tot]=e;&#125; inline void add(ri a,ri b,ri c,ri e)&#123;ins(a,b,c,e),ins(b,a,0,-e);&#125; int W;//W为pow(sum w(w&gt;0)/sqrt(n+1),0.666667),W=W&lt;down:down:W,W=W&gt;up?up:W; namespace EK&#123; int pre[N]; deque&lt;int&gt;q; bool in[N]; inline bool spfa()&#123;//SLF+容错(个人感觉挺不错的) memset(dis,0x7f,sizeof(dis)); ri i,u,x; q.push_back(S),dis[S]=0; while(!q.empty())&#123; x=*(q.begin()); q.pop_front(); in[x]=0; for(i=d[x];~i;i=nxt[i])&#123; u=to[i]; if(flow[i]&amp;&amp;dis[u]&gt;dis[x]+cost[i])&#123; dis[u]=dis[x]+cost[i]; pre[u]=i; if(!in[u])&#123; in[u]=1; if(!q.empty()&amp;&amp;dis[u]&gt;dis[*q.begin()]+W) q.push_back(u); else q.push_front(u); &#125; &#125; &#125; &#125;return dis[T]&lt;inf; &#125;inline int EK()&#123;ri Mincost=0,Maxflow=0,now,ans; while(spfa())&#123; ans=inf; for(now=T;now!=S;now=to[pre[now]^1]) ans=min(ans,flow[pre[now]]); for(now=T;now!=S;now=to[pre[now]^1]) flow[pre[now]]-=ans,flow[pre[now]^1]+=ans; Mincost+=ans*dis[T]; Maxflow+=ans; &#125;return Mincost; &#125; &#125; namespace Dinic&#123; deque&lt;int&gt;q; bool in[N]; int vis[N],cur[N],Tim,Mincost,Maxflow; inline bool spfa()&#123; memset(dis,0x7f,sizeof(dis)); memcpy(cur,d,sizeof(cur)); ri i,u,x; q.push_back(S),dis[S]=0; while(!q.empty())&#123; x=q.front(); q.pop_front(); in[x]=0; for(i=d[x];~i;i=nxt[i])&#123; u=to[i]; if(dis[u]&gt;dis[x]+cost[i])&#123; dis[u]=dis[x]+cost[i]; if(!in[u])&#123; in[u]=1; if(!q.empty()&amp;&amp;dis[u]&gt;dis[*q.begin()]+W) q.push_back(u); else q.push_front(u); &#125; &#125; &#125; &#125;return dis[T]&lt;inf; &#125;inline int dfs(ri now,ri lim)&#123; if(now==T||!lim)&#123;Mincost+=dis[now]*lim,Maxflow+=lim;return lim;&#125; ri fl=0,f; vis[now]=Tim; for(ri i=cur[now];~i;i=nxt[i])&#123; cur[now]=i; ri u=to[i]; if(dis[u]==dis[now]+cost[i]&amp;&amp;vis[u]!=Tim&amp;&amp;(f=dfs(u,min(lim,flow[i]))))&#123; fl+=f, flow[i]-=f, flow[i^1]+=f; lim-=f; if(!lim)break; &#125; &#125;return fl; &#125;inline int Dinic()&#123;Mincost=Maxflow=0; while(spfa())&#123; do&#123; ++Tim; &#125;while(dfs(S,inf)); &#125;return Mincost; &#125; &#125; namespace zkw&#123; int cur[N],vis[N],Tim,cnt;//节点编号为0-cnt int Mincost,Maxflow; inline bool zkw()&#123; memcpy(cur,d,sizeof(cur)); ri i,x,mn=inf; for(x=0;x&lt;=cnt;++x) if(vis[x]==Tim) for(i=d[x];~i;i=nxt[i]) if(flow[i]&amp;&amp;vis[to[i]]!=Tim) mn=min(mn,dis[x]-dis[to[i]]+cost[i]); if(mn&gt;=inf)return 0; for(x=0;x&lt;=cnt;++i)if(vis[x]==Tim)dis[x]-=mn; return 1; &#125;inline int dfs(ri now,ri lim)&#123; if(!lim||now==T)&#123;Mincost-=dis[now]*lim,Maxflow+=lim;return lim;&#125; ri fl=0,f; vis[now]=Tim; for(ri i=cur[now];~i;i=nxt[i])&#123; ri u=to[i]; cur[now]=i; if(dis[u]==dis[now]+cost[i]&amp;&amp;vis[u]!=Tim&amp;&amp;(f=dfs(u,min(lim,flow[i]))))&#123; fl+=f, flow[i]-=f, flow[i^1]+=f; lim-=f; if(!lim)break; &#125; &#125;return lim; &#125;inline int work()&#123;Mincost=Maxflow=0; do&#123; do&#123; ++Tim; &#125;while(dfs(S,inf)); &#125;while(zkw()); return Mincost; &#125; &#125;&#125;/*---随机化乱搞(模拟退火,随机化数组,爬山算法)*/namespace Random_work&#123; /*---模拟退火*/ const double eps=1e-6; namespace SA&#123; struct Pnt&#123; double x,y; Pnt(double a=0,double b=0)&#123;x=a,y=b;&#125; inline void get()&#123;x=rand(),y=rand();&#125; &#125;;// template&lt;typename T&gt; inline double calc(Pnt x)&#123;/*---估价函数*/return 0;&#125; inline double get_rand()&#123;return rand()*1.0/RAND_MAX;&#125;//如果可以是负数再随机一次符号 inline void work()&#123; double tmp=1000;//可以是系数或是步长,这里是步长 Pnt O,now; O.get(); double Ans=calc(O),ans; bool find; while(tmp&gt;eps)&#123; find=0; now=Pnt(O.x+tmp*get_rand(),O.y+tmp*get_rand()); ans=calc(now); if(ans&lt;Ans)Ans=ans,O=now,find=1; &#125;if(!find)tmp/=2; &#125; &#125;&#125;/*---splay_one*/namespace Splay_one&#123;//此处为一个spaly const int N=1e4+10; int ch[N][2],fa[N],siz[N],rt; int v[N],cnt;//以权值排序为例,当然也可以不用排序, #define lc ch[x][0] #define rc ch[x][1] inline void pushup(ri x)&#123;siz[x]=siz[lc]+siz[rc]+1;/*---*/&#125; inline void rotate(ri x)&#123; ri y=fa[x],z=fa[y],k=ch[y][1]!=x; ch[z][ch[z][1]==y]=x,fa[x]=z; ch[y][!k]=ch[x][k],fa[ch[x][k]]=y; ch[x][k]=y,fa[y]=x,pushup(y);//降低常数 &#125;inline void pushdown(ri x)&#123;/*---懒惰标记下放*/&#125; int stk[N],tail; inline void splay(ri x,ri goal)&#123; ri y,z; /* stk[++tail]=x; for(y=x;fa[y]!=goal;y=fa[y])stk[++tail]=fa[y]; while(tail)pushdown(stk[tail--]); */ while(fa[x]!=goal)&#123; y=fa[x],z=fa[y]; if(z!=goal)(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y); rotate(x); &#125;if(!goal)rt=x; pushup(x); &#125;inline void Insert(ri x)&#123;//加入节点,加入前已初始化 ri y=rt; if(!y)&#123;rt=x;return;&#125; ri f=0; //pushdown(y); while(y)&#123; f=y,y=ch[y][v[x]&gt;=v[y]];// pushdown(y); &#125;fa[x]=f,ch[f][v[x]&gt;=v[f]]=x; splay(x,0); &#125;inline void del()&#123; ri x=rt,k; if(lc)k=0; else if(rc)k=1; else &#123;rt=0;lc=rc=fa[x]=0;return;&#125; ri y=ch[x][k];// pushdown(y); while(ch[y][!k])&#123; y=ch[y][!k];// pushdown(y); &#125;splay(y,x); ch[y][!k]=ch[x][!k],fa[ch[x][!k]]=y,fa[y]=0,rt=y; pushup(y),lc=rc=fa[x]=0; &#125;inline void Del(ri val)&#123;//删除权值为val的点,此处如有多个只删一个 ri x=rt; while(x)&#123;// pushdown(x); if(v[x]!=val)x=ch[x][val&gt;v[x]]; else&#123; splay(x,0),del(); return; &#125; &#125; &#125;inline int kth(ri k)&#123; ri x=rt; while(x)&#123; pushdown(x); if(siz[lc]&gt;=k)x=lc; else &#123; k-=siz[lc]+1; if(!k)return x;//之后要splay一次 x=rc; &#125; &#125; &#125;inline void split(ri L,ri R)&#123;//以加入-inf,inf哨兵为例 ri x=kth(L);splay(x,0); ri y=kth(R+2);splay(y,x); //ch[y][0]即为区间[L,R] &#125;inline int build(ri L,ri R)&#123;//笛卡尔建树 if(L&gt;R)return 0; ri x=(L+R)&gt;&gt;1; lc=build(L,x-1),rc=build(x+1,R); fa[lc]=fa[rc]=x; pushup(x);return x; &#125;//最后别忘了fa[rt]=0;如果多次建树的话 #undef lc #undef rc&#125;/*---splay_two*/namespace Splay_two&#123;//多颗spaly,内含启发式合并 const int N=1e4+10; int ch[N][2],fa[N],siz[N],rt[N]; int v[N]; #define lc ch[x][0] #define rc ch[x][1] inline void pushup(ri x)&#123;siz[x]=siz[lc]+siz[rc]+1;&#125; inline void rotate(ri x)&#123; ri y=fa[x],z=fa[y],k=ch[y][1]!=x; ch[z][ch[z][1]==y]=x,fa[x]=z; ch[y][!k]=ch[x][k],fa[ch[x][k]]=y; ch[x][k]=y,fa[y]=x,pushup(y); &#125;inline void pushdown(ri x)&#123;/*---*/&#125; int stk[N],tail; int st[N],tot; /*---begin 这段部分与一棵树的差别只在于记录了是处理哪棵树*/ inline void splay(ri p,ri x,ri goal)&#123; ri y,z; /* stk[++tail]=x; for(y=x;fa[y]!=goal;y=fa[y])stk[++tail]=fa[y]; while(tail)pushdown(stk[tail--]); */ while(fa[x]!=goal)&#123; y=fa[x],z=fa[y]; if(z!=goal)(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y); rotate(x); &#125;if(!goal)rt[p]=x; pushup(x); &#125;inline void Insert(ri p,ri x)&#123; ri y=rt[p]; if(!y)&#123;rt[p]=x;return;&#125; ri f=0;// pushdown(y); while(y)&#123; f=y,y=ch[y][v[x]&gt;=v[y]];// pushdown(y); &#125;fa[x]=f,ch[f][v[x]&gt;=v[f]]=x; splay(p,x,0); &#125;inline void del(ri p)&#123; ri x=rt[p],k; if(lc)k=0; else if(rc)k=1; else &#123;rt[p]=0;lc=rc=fa[x]=0;return;&#125; ri y=ch[x][k];// pushdown(y); while(ch[y][!k])&#123; y=ch[y][!k];// pushdown(y); &#125;splay(p,y,x); ch[y][!k]=ch[x][!k],fa[ch[x][!k]]=y,fa[y]=0,rt[p]=y; pushup(y),lc=rc=fa[x]=0; &#125;inline void Del(ri p,ri val)&#123; ri x=rt[p]; while(x)&#123;// pushdown(x); if(v[x]!=val)x=ch[x][val&gt;v[x]]; else&#123; splay(p,x,0),del(p); return; &#125; &#125; &#125;inline int kth(ri p,ri k)&#123; ri x=rt[p]; while(x)&#123; //pushdown(x); if(siz[lc]&gt;=k)x=lc; else &#123; k-=siz[lc]+1; if(!k)return x;//之后要splay一次 x=rc; &#125; &#125; &#125;inline void split(ri p,ri L,ri R)&#123;//以加入-inf,inf哨兵为例 ri x=kth(p,L);splay(p,x,0); ri y=kth(p,R+2);splay(p,y,x); //ch[y][0]即为区间[L,R] &#125; /*---end*/ inline void dfs(ri x)&#123;if(!x)return;dfs(lc),st[++tot]=x,dfs(rc);lc=rc=fa[x]=0;&#125; inline void Merge(ri x,ri y)&#123;//合并两颗splay if(siz[x]&gt;siz[y])swap(x,y); //不过大部分题目用启发式合并并不需要对每个点维护siz,一般只用维护rt的siz,可以降低常数(少pushup) tot=0,dfs(rt[x]);//遍历较小的spaly for(ri i=1;i&lt;=tot;++i)Insert(y,st[i]); &#125; #undef lc #undef rc&#125;/*---标准LCT*/namespace LCT&#123; const int N=1e5+10; int ch[N][2],fa[N],rev[N],stk[N],top; #define lc ch[x][0] #define rc ch[x][1] inline bool rt(ri x)&#123;ri y=fa[x];return ch[y][0]!=x&amp;&amp;ch[y][1]!=x;&#125; inline void pushdown(ri x)&#123;if(rev[x])swap(lc,rc),rev[lc]^=1,rev[rc]^=1,rev[x]=0;&#125; inline void pushup(ri x)&#123;&#125; inline void rotate(ri x)&#123; ri y=fa[x],z=fa[y],k=ch[y][1]!=x; if(!rt(y))ch[z][ch[z][1]==y]=x;fa[x]=z; ch[y][!k]=ch[x][k],fa[ch[x][k]]=y; ch[x][k]=y,fa[y]=x;pushup(y); &#125;inline void splay(ri x)&#123; ri y,z; for(stk[++top]=y=x;!rt(y);y=fa[y])stk[++top]=fa[y]; while(top)pushdown(stk[top--]); while(!rt(x))&#123; y=fa[x],z=fa[y]; if(!rt(y))(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y); rotate(x); &#125;pushup(x); &#125;inline int access(ri x)&#123;ri y; for(y=0;x;x=fa[y=x]) splay(x),rc=y,pushup(x); return y; &#125;inline void makeroot(ri x)&#123;access(x),splay(x),rev[x]^=1;&#125; inline void link(ri x,ri y)&#123;makeroot(x),fa[x]=y;&#125; inline void split(ri x,ri y)&#123;makeroot(x),access(y),splay(y);&#125; inline int findroot(ri x)&#123; access(x),splay(x); while(lc)x=lc; splay(x); return x; &#125; #undef lc #undef rc&#125; /*---较难版本LCT*/namespace LCT_2&#123;//以可以实现链反转,链求和为例(不带链修改,懒得写) const int N=1e4+10; #define lc ch[x][0] #define rc ch[x][1] struct Splay&#123; int ch[N][2],fa[N],v[N],rev[N],siz[N],s[N]; inline void pushup(ri x)&#123; siz[x]=siz[lc]+siz[rc]+1; s[x]=s[lc]+s[rc]+v[x]; &#125;inline void pushdown(ri x)&#123;if(rev[x])swap(lc,rc),rev[lc]^=1,rev[rc]^=1,rev[x]=0;&#125; int stk[N],tail; inline void rotate(ri x)&#123; ri y=fa[x],z=fa[y],k=ch[y][1]!=x; ch[z][ch[z][1]==y]=x,fa[x]=z; ch[y][!k]=ch[x][k],fa[ch[x][k]]=y; ch[x][k]=y,fa[y]=x,pushup(y); &#125;inline void splay(ri x,ri goal)&#123; ri y,z; stk[++tail]=x; for(y=x;fa[y]!=goal;y=fa[y])stk[++tail]=fa[y]; while(tail)pushdown(stk[tail--]); while(fa[x]!=goal)&#123; y=fa[x],z=fa[y]; if(z!=goal)(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y); rotate(x); &#125;pushup(x); &#125;inline void split(ri x,ri k,ri&amp;a,ri&amp;b)&#123; while(x)&#123; pushdown(x); if(siz[lc]&gt;=k)x=lc; else&#123; k-=siz[lc]+1; if(!k)&#123; splay(x,0); a=x,b=rc; rc=fa[b]=0; pushup(x); return; &#125;x=rc; &#125; &#125; &#125;inline void Merge(ri x,ri y,ri&amp;a)&#123; pushdown(x); while(rc)x=rc,pushdown(x); splay(x,0); rc=y,a=x; pushup(x); &#125; &#125;S; int ch[N][2],fa[N],siz[N];//如果需要实现链反转需要维护siz int rt[N],rev[N]; inline bool rot(ri x)&#123;ri y=fa[x];return ch[y][0]!=x&amp;&amp;ch[y][1]!=x;&#125; inline void pushup(ri x)&#123;siz[x]=siz[lc]+siz[rc]+1;&#125; inline void rotate(ri x)&#123; ri y=fa[x],z=fa[y],k=ch[y][1]!=x; if(!rot(y))ch[z][ch[z][1]==y]=x;fa[x]=z; ch[y][!k]=ch[x][k],fa[ch[x][k]]=y; ch[x][k]=y,fa[y]=x,pushup(y); &#125;inline void pushdown(ri x)&#123;if(rev[x])swap(lc,rc),rev[lc]^=1,rev[rc]^=1,rev[x]=0;&#125; int stk[N],tail; inline void splay(ri x)&#123; ri y,z; stk[++tail]=x; for(y=x;!rot(y);y=fa[y])stk[++tail]=fa[y]; while(tail)pushdown(stk[tail--]); swap(rt[x],rt[y]); while(!rot(x))&#123; y=fa[x],z=fa[y]; if(!rot(y))(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y); rotate(x); &#125;pushup(x); &#125;inline void access(ri x)&#123; for(ri y=0;x;x=fa[y=x])&#123; splay(x); if(rc)S.split(rt[x],siz[lc]+1,rt[x],rt[rc]); if(y)S.Merge(rt[x],rt[y],rt[x]),rt[y]=0; rc=y,pushup(x); &#125; &#125;inline void makeroot(ri x)&#123;access(x),splay(x),rev[x]^=1,S.rev[rt[x]]^=1;&#125; inline void link(ri x,ri y)&#123;makeroot(x),fa[x]=y;&#125; inline void split(ri x,ri y)&#123;makeroot(x),access(y),splay(y);&#125; inline void reverse(ri x,ri y)&#123;split(x,y),S.rev[rt[y]]^=1;&#125;/*---链反转*/ #undef lc #undef rc&#125;/*---吉司林线段树*/namespace JSL_Segment_Tree&#123; const int N=2e4; int l[N],r[N],mn[N],cn[N],sn[N],sum[N],tag[N];//以取max,求区间和为例,记录最小、次小、最小个数,总和,以及懒惰标记 int a[N],rt,cnt; #define lc l[x] #define rc r[x] inline void pushup(ri x)&#123; if(mn[lc]&lt;mn[rc])mn[x]=mn[lc],sn[x]=sn[lc],cn[x]=min(cn[lc],mn[rc]); else if(mn[rc]&lt;mn[lc])mn[x]=mn[rc],sn[x]=sn[rc],cn[x]=min(cn[rc],mn[lc]); else mn[x]=mn[lc],sn[x]=sn[lc]+sn[rc],cn[x]=min(cn[lc],cn[rc]); &#125;inline void build(ri&amp;x,ri L,ri R)&#123; x=++cnt;tag[x]=-inf; if(L==R)&#123;mn[x]=sum[x]=a[L],cn[x]=inf,sn[x]=1;return;&#125; ri mid=(L+R)&gt;&gt;1; build(lc,L,mid),build(rc,mid+1,R); pushup(x); &#125;inline void push_tag(ri x,ri v)&#123; if(v&lt;=tag[x])return; sum[x]+=(v-tag[x])*sn[x],mn[x]=tag[x]=v; &#125;inline void pushdown(ri x)&#123; if(tag[x]!=-inf)push_tag(lc,tag[x]),push_tag(rc,tag[x]),tag[x]=-inf; &#125;inline void Modify(ri x,ri L,ri R,ri ll,ri rr,ri v)&#123; if(mn[x]&gt;=v)return; if(ll&lt;=L&amp;&amp;R&lt;=rr&amp;&amp;cn[x]&gt;v)return push_tag(x,v); ri mid=(L+R)&gt;&gt;1;pushdown(x); if(ll&lt;=mid)Modify(lc,L,mid,ll,rr,v); if(rr&gt;mid)Modify(rc,mid+1,R,ll,rr,v); pushup(x); &#125;inline int query(ri x,ri L,ri R,ri ll,ri rr)&#123; if(ll&lt;=L&amp;&amp;R&lt;=rr)return sum[x]; int mid=(L+R)&gt;&gt;1;pushdown(x); if(ll&gt;mid)return query(rc,mid+1,R,ll,rr); else if(rr&lt;=mid)return query(lc,L,mid,ll,rr); else return query(lc,L,mid,ll,rr)+query(rc,mid+1,R,ll,rr); &#125; #undef lc #undef rc&#125;/*---李超树*/namespace LC_Tree&#123; const int N=1e5+10; #define lc ch[x][0] #define rc ch[x][1] int ch[N][2],l[N],r[N],cnt; LL dl[N],dr[N],K[N],B[N],mn[N],dis[N]; inline LL f(ri x,LL k,LL b)&#123;return b+k*x;&#125; inline void pushup(ri x)&#123;mn[x]=min(mn[x],min(mn[lc],mn[rc]));&#125; inline void build(ri&amp;x,ri L,ri R)&#123; x=++cnt;B[x]=mn[x]=inf;l[x]=L,r[x]=R; if(L==R)&#123;dl[x]=dr[x]=dis[L];return;&#125; ri mid=(L+R)&gt;&gt;1; build(lc,L,mid),build(rc,mid+1,R); dl[x]=dl[lc],dr[x]=dr[rc]; &#125;inline void extand(ri x,LL k,LL b)&#123;//以维护最下方的线段为例 LL f1,f2,f3,f4; f1=f(dl[x],K[x],B[x]),f2=f(dr[x],K[x],B[x]); f3=f(dl[x],k,b),f4=f(dr[x],k,b); if(f3&lt;=f1&amp;&amp;f4&lt;=f2)&#123;K[x]=k,B[x]=b;mn[x]=min(mn[x],min(f3,f4));return;&#125; if(f3&gt;f1&amp;&amp;f4&gt;f2)return; LL g=(b-B[x])/(K[x]-k); LL h=dr[lc]; if(g&lt;=h||f3&lt;=f1)extand(lc,k,b); if(g&gt;h||f4&lt;=f2)extand(rc,k,b); pushup(x); &#125;inline void Modify(ri x,ri ll,ri rr,ri k,ri b)&#123; if(ll&lt;=l[x]&amp;&amp;r[x]&lt;=rr)return extand(x,k,b); ri mid=(l[x]+r[x])&gt;&gt;1; if(ll&lt;=mid)Modify(lc,ll,rr,k,b); if(rr&gt;mid)Modify(rc,ll,rr,k,b); pushup(x); &#125;inline LL query(ri x,ri ll,ri rr)&#123; if(ll&lt;=l[x]&amp;&amp;r[x]&lt;=rr)return mn[x]; ri mid=(l[x]+r[x])&gt;&gt;1; LL ans=inf; if(ll&lt;=mid)ans=min(ans,query(lc,ll,rr)); if(rr&gt;mid)ans=min(ans,query(rc,ll,rr)); ri L=max(ll,l[x]),R=min(rr,r[x]); ans=min(ans,f(dis[L],K[x],B[x])); ans=min(ans,f(dis[R],K[x],B[x])); return ans; &#125; #undef lc #undef rc&#125;/*---KD-Tree*/namespace KDT&#123;//以k远点对为例 const int N=1e5+10,M=N&lt;&lt;1; #define lc ch[x][0] #define rc ch[x][1] struct pnt&#123; int x[2]; &#125;a[N]; int opt; struct node&#123;int dis;node(ri a=0)&#123;dis=a;&#125;inline bool operator &lt;(const node&amp;other)const&#123;return dis&gt;other.dis;&#125;&#125;;;//小根堆 priority_queue&lt;node&gt;q; inline bool cmp(register pnt a,register pnt b)&#123;return a.x[opt]&lt;b.x[opt];&#125; inline int f(pnt a,pnt b)&#123;return sqr(a.x[0]-b.x[0])+sqr(a.x[1]-b.x[1]);&#125; struct ST&#123; int ch[M][2],minn[M][2],maxn[M][2],cnt; pnt d[M]; inline void pushup(ri x)&#123; for(ri i=0;i&lt;2;++i)maxn[x][i]=minn[x][i]=d[x].x[i]; if(lc)for(ri i=0;i&lt;2;++i)maxn[x][i]=max(maxn[x][i],maxn[lc][i]),minn[x][i]=min(minn[x][i],minn[lc][i]); if(rc)for(ri i=0;i&lt;2;++i)maxn[x][i]=max(maxn[x][i],maxn[rc][i]),minn[x][i]=min(minn[x][i],minn[rc][i]); &#125;inline int build(ri L,ri R,ri k)&#123; if(L&gt;R)return 0; ri x=++cnt;opt=k; ri mid=(L+R)&gt;&gt;1; nth_element(a+L,a+mid,a+R+1,cmp); d[x]=a[mid]; lc=build(L,mid-1,k^1),rc=build(mid+1,R,k^1); pushup(x); &#125;inline int g(pnt a,ri b)&#123; return max(sqr(maxn[b][0]-a.x[0]),sqr(minn[b][0]-a.x[0]))+max(sqr(maxn[b][1]-a.x[1]),sqr(minn[b][1]-a.x[1])); &#125;inline void query(ri x,pnt O)&#123; ri dl=-inf,dr=-inf; if(lc)dl=g(O,lc); if(rc)dr=g(O,rc); ri dis=f(d[x],O); if(q.top().dis&lt;dis)q.pop(),q.push(dis); if(dl&gt;dr)&#123;if(q.top().dis&lt;dl)query(lc,O);if(q.top().dis&lt;dr)query(rc,O);&#125; else &#123;if(q.top().dis&lt;dr)query(rc,O);if(q.top().dis&lt;dl)query(lc,O);&#125; &#125; &#125;; #undef lc #undef rc &#125;/*---左偏树*/namespace leftist_heap&#123; const int N=1e4+10; int rt,dep[N],l[N],r[N],v[N]; inline void pushr(ri x,ri v)&#123;/*---*/&#125; inline void pushdown(ri x)&#123;/*---下放懒惰标记*/&#125; inline int Merge(ri k1,ri k2)&#123;//以大跟堆为例 if(!k1||!k2)return k1|k2; pushdown(k1),pushdown(k2); if(v[k1]&lt;v[k2])swap(k1,k2); r[k1]=Merge(r[k1],k2); if(dep[r[k1]]&gt;dep[l[k1]])swap(l[k1],r[k1]); dep[k1]=dep[r[k1]]+1;return k1; &#125;inline int top()&#123;return rt;&#125; inline void pop()&#123;rt=Merge(l[rt],r[rt]),l[rt]=r[rt]=0;&#125;&#125;/*---长链剖分(通常是处理树上与dep深度有关的dp问题)*/namespace unknown_name_3&#123; const int N=1e4+10; int len[N],d[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],fa[N],son[N]; int tmp[N],*id,*dp[N]; inline void dfs(ri x)&#123; for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(u!=fa[x]) fa[u]=x,dfs(u),son[x]=len[u]&gt;len[son[x]]?u:son[x]; &#125;len[x]=len[son[x]]+1; &#125;inline void Dp(ri x)&#123; /*---此处预处理*/ if(son[x])&#123; dp[son[x]]=dp[x]+1; Dp(son[x]); /*---因题而异,有的题需要继承son[x]的答案什么的*/ &#125;for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(u!=fa[x])&#123; Dp(u); /*---work,此处dp*/ &#125; &#125; &#125;&#125;/*---重链剖分HDT*/namespace HDT&#123;//可以用重链剖分将树上的链转化为不超过logn条轻,每条链的编号是连续的 //因此可以将部分较麻烦的树上问题改成维护若干条链。 //也可以O(logn)求Lca,自带1/4的常数,还可以实现链反转,以及做动态链反转、链排序等等神仙题qwq const int N=1e5+10; int low[N],dfn[N],top[N],son[N],fa[N],siz[N],Tim; int d[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],tot; int dep[N]; inline void dfs1(ri x)&#123; siz[x]=1; for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(u==fa[x])continue; fa[u]=x,dep[u]=dep[x]+1; dfs1(u),siz[x]+=siz[u]; son[x]=siz[u]&gt;siz[son[x]]?u:son[x]; &#125; &#125;inline void dfs2(ri x)&#123; low[dfn[x]=++Tim]=x; if(!son[x])return; top[son[x]]=top[x]; dfs2(son[x]); for(ri i=d[x];i;i=nxt[i])&#123; ri u=to[i]; if(u==fa[x]||u==son[x])continue; top[u]=u; dfs2(u); &#125; &#125;inline void init()&#123;dep[1]=top[1]=1;dfs1(1),dfs2(1);&#125; inline int Lca(ri u,ri v)&#123;while(top[u]!=top[v])&#123;if(dep[top[u]]&lt;dep[top[v]])swap(u,v);u=fa[top[u]];&#125;return dep[u]&lt;dep[v]?u:v;&#125; inline void Modify(ri u,ri v)&#123; while(top[u]!=top[v])&#123; if(dep[top[u]]&lt;dep[top[v]])swap(u,v);// modify(dfn[top[u]],dfn[u]);//因题而异,有的题甚至是将这些链存起来再进行操作 &#125;if(dep[u]&gt;dep[v])swap(u,v);// modify(dfn[u],dfn[v]); &#125;inline int query(ri u,ri v)&#123; //大体同上 &#125;&#125; /*---线段树合并*/namespace unknown_name_4&#123; const int N=1e4+10; int l[N*50],r[N*50],siz[N*50],cnt;//以你的名字为例 #define lc l[x] #define rc r[x] inline void New(ri&amp;x,ri L,ri R,ri pos)&#123; siz[x=++cnt]=1; if(L==R)return; ri mid=(L+R)&gt;&gt;1; if(pos&lt;=mid)New(lc,L,mid,pos); else New(rc,mid+1,R,pos); &#125;inline int Merge(ri x,ri y)&#123; if(!x||!y)return x|y; ri o=++cnt; siz[o]=siz[x]+siz[y]; l[o]=Merge(l[x],l[y]),r[o]=Merge(r[x],r[y]); return o; &#125;inline int query(ri x,ri L,ri R,ri ll,ri rr)&#123; if(!x)return 0; if(ll&lt;=L&amp;&amp;R&lt;=rr)return siz[x]; ri mid=(L+R)&gt;&gt;1; if(ll&gt;mid)return query(rc,mid+1,R,ll,rr); else if(rr&lt;=mid)return query(lc,L,mid,ll,rr); else return query(lc,L,mid,ll,rr)+query(rc,mid+1,R,ll,rr); &#125; #undef lc #undef rc&#125;/*---莫队合集*/namespace MD&#123; namespace MD_1&#123;//不带修改普通莫队 &#125;namespace MD_2&#123;//带修改普通莫队 &#125;namespace MD_3&#123;//不带修改树上莫队 &#125;namespace MD_4&#123;//带修改树上莫队 &#125;&#125;/*---分块*/namespace FK&#123;//有预处理出单个块的答案,预处理出块与块之间的答案(部分可用ST表优化),权值分块,将询问分块,树上分块等等 &#125;/*---Berlekamp-Massey算法*/namespace Berlekamp_Massey&#123; const int N=505; const double eps=1e-8; vector&lt;double&gt;ans[N]; double delta[N]; int fail[N]; inline void calc(ri*a,ri n,ri*b,ri&amp;cnt)&#123; ri Max,Mul; for(ri i=1,j,tmp;i&lt;=n;++i)&#123; tmp=a[i]; for(j=ans[cnt].size()-1;~j;--j) tmp-=ans[cnt][j]*a[i-j-1]; delta[i]=tmp; if(fabs(tmp)&lt;eps)continue; fail[cnt]=i; if(!cnt)&#123;ans[++cnt].resize(i);continue;&#125; Mul=tmp/delta[fail[cnt-1]]; ++cnt,ans[cnt].resize(i-fail[cnt-2]-1); ans[cnt].push_back(Mul); Max=ans[cnt-2].size(); for(j=0;j&lt;Max;++j)ans[cnt].push_back(ans[cnt-2][j]*-Mul); Max=ans[cnt-1].size(); if(ans[cnt].size()&lt;Max)ans[cnt].resize(Max); for(j=0;j&lt;Max;++j) ans[cnt][j]+=ans[cnt-1][j]; &#125;for(ri i=ans[cnt].size()-1;~i;--i)b[i]=ans[cnt][i]; cnt=ans[cnt].size(); &#125;&#125;/*--- 凸包*/namespace convex_hull&#123;&#125;int main()&#123; return 0;&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
